/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const _CACHED_RUNES: u32 = 256;
pub const _CRMASK: i32 = -256;
pub const _RUNE_MAGIC_A: &[u8; 9usize] = b"RuneMagA\0";
pub const _CTYPE_A: u32 = 256;
pub const _CTYPE_C: u32 = 512;
pub const _CTYPE_D: u32 = 1024;
pub const _CTYPE_G: u32 = 2048;
pub const _CTYPE_L: u32 = 4096;
pub const _CTYPE_P: u32 = 8192;
pub const _CTYPE_S: u32 = 16384;
pub const _CTYPE_U: u32 = 32768;
pub const _CTYPE_X: u32 = 65536;
pub const _CTYPE_B: u32 = 131072;
pub const _CTYPE_R: u32 = 262144;
pub const _CTYPE_I: u32 = 524288;
pub const _CTYPE_T: u32 = 1048576;
pub const _CTYPE_Q: u32 = 2097152;
pub const _CTYPE_SW0: u32 = 536870912;
pub const _CTYPE_SW1: u32 = 1073741824;
pub const _CTYPE_SW2: u32 = 2147483648;
pub const _CTYPE_SW3: u32 = 3221225472;
pub const _CTYPE_SWM: u32 = 3758096384;
pub const _CTYPE_SWS: u32 = 30;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130000;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __GNUC_VA_LIST: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_PRIMARY_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_DL_LOW_POWER_MODE_CHANGED: u32 = 30;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const KEV_INET6_REQUEST_NAT64_PREFIX: u32 = 7;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const SO_RESOLVER_SIGNATURE: u32 = 4401;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const NET_MAXID: u32 = 41;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_FLAGS_PRIV: u32 = 10;
pub const NET_RT_MAXID: u32 = 11;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const MSG_NOSIGNAL: u32 = 524288;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_DONTFRAG: u32 = 28;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &[u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_ADDR_MC_FLAGS_TRANSIENT: u32 = 16;
pub const IPV6_ADDR_MC_FLAGS_PREFIX: u32 = 32;
pub const IPV6_ADDR_MC_FLAGS_UNICAST_BASED: u32 = 48;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_ULA_USETEMPADDR: u32 = 51;
pub const IPV6CTL_MAXID: u32 = 51;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const __DTF_SKIPREAD: u32 = 16;
pub const __DTF_ATEND: u32 = 32;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_ACCMODE: u32 = 3;
pub const FREAD: u32 = 1;
pub const FWRITE: u32 = 2;
pub const O_NONBLOCK: u32 = 4;
pub const O_APPEND: u32 = 8;
pub const O_SYNC: u32 = 128;
pub const O_SHLOCK: u32 = 16;
pub const O_EXLOCK: u32 = 32;
pub const O_ASYNC: u32 = 64;
pub const O_FSYNC: u32 = 128;
pub const O_NOFOLLOW: u32 = 256;
pub const O_CREAT: u32 = 512;
pub const O_TRUNC: u32 = 1024;
pub const O_EXCL: u32 = 2048;
pub const O_EVTONLY: u32 = 32768;
pub const O_NOCTTY: u32 = 131072;
pub const O_DIRECTORY: u32 = 1048576;
pub const O_SYMLINK: u32 = 2097152;
pub const O_DSYNC: u32 = 4194304;
pub const O_CLOEXEC: u32 = 16777216;
pub const O_NOFOLLOW_ANY: u32 = 536870912;
pub const O_EXEC: u32 = 1073741824;
pub const O_SEARCH: u32 = 1074790400;
pub const AT_FDCWD: i32 = -2;
pub const AT_EACCESS: u32 = 16;
pub const AT_SYMLINK_NOFOLLOW: u32 = 32;
pub const AT_SYMLINK_FOLLOW: u32 = 64;
pub const AT_REMOVEDIR: u32 = 128;
pub const AT_REALDEV: u32 = 512;
pub const AT_FDONLY: u32 = 1024;
pub const AT_SYMLINK_NOFOLLOW_ANY: u32 = 2048;
pub const O_DP_GETRAWENCRYPTED: u32 = 1;
pub const O_DP_GETRAWUNENCRYPTED: u32 = 2;
pub const O_DP_AUTHENTICATE: u32 = 4;
pub const AUTH_OPEN_NOAUTHFD: i32 = -1;
pub const FAPPEND: u32 = 8;
pub const FASYNC: u32 = 64;
pub const FFSYNC: u32 = 128;
pub const FFDSYNC: u32 = 4194304;
pub const FNONBLOCK: u32 = 4;
pub const FNDELAY: u32 = 4;
pub const O_NDELAY: u32 = 4;
pub const CPF_OVERWRITE: u32 = 1;
pub const CPF_IGNORE_MODE: u32 = 2;
pub const CPF_MASK: u32 = 3;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETOWN: u32 = 5;
pub const F_SETOWN: u32 = 6;
pub const F_GETLK: u32 = 7;
pub const F_SETLK: u32 = 8;
pub const F_SETLKW: u32 = 9;
pub const F_SETLKWTIMEOUT: u32 = 10;
pub const F_FLUSH_DATA: u32 = 40;
pub const F_CHKCLEAN: u32 = 41;
pub const F_PREALLOCATE: u32 = 42;
pub const F_SETSIZE: u32 = 43;
pub const F_RDADVISE: u32 = 44;
pub const F_RDAHEAD: u32 = 45;
pub const F_NOCACHE: u32 = 48;
pub const F_LOG2PHYS: u32 = 49;
pub const F_GETPATH: u32 = 50;
pub const F_FULLFSYNC: u32 = 51;
pub const F_PATHPKG_CHECK: u32 = 52;
pub const F_FREEZE_FS: u32 = 53;
pub const F_THAW_FS: u32 = 54;
pub const F_GLOBAL_NOCACHE: u32 = 55;
pub const F_ADDSIGS: u32 = 59;
pub const F_ADDFILESIGS: u32 = 61;
pub const F_NODIRECT: u32 = 62;
pub const F_GETPROTECTIONCLASS: u32 = 63;
pub const F_SETPROTECTIONCLASS: u32 = 64;
pub const F_LOG2PHYS_EXT: u32 = 65;
pub const F_GETLKPID: u32 = 66;
pub const F_SETBACKINGSTORE: u32 = 70;
pub const F_GETPATH_MTMINFO: u32 = 71;
pub const F_GETCODEDIR: u32 = 72;
pub const F_SETNOSIGPIPE: u32 = 73;
pub const F_GETNOSIGPIPE: u32 = 74;
pub const F_TRANSCODEKEY: u32 = 75;
pub const F_SINGLE_WRITER: u32 = 76;
pub const F_GETPROTECTIONLEVEL: u32 = 77;
pub const F_FINDSIGS: u32 = 78;
pub const F_ADDFILESIGS_FOR_DYLD_SIM: u32 = 83;
pub const F_BARRIERFSYNC: u32 = 85;
pub const F_ADDFILESIGS_RETURN: u32 = 97;
pub const F_CHECK_LV: u32 = 98;
pub const F_PUNCHHOLE: u32 = 99;
pub const F_TRIM_ACTIVE_FILE: u32 = 100;
pub const F_SPECULATIVE_READ: u32 = 101;
pub const F_GETPATH_NOFIRMLINK: u32 = 102;
pub const F_ADDFILESIGS_INFO: u32 = 103;
pub const F_ADDFILESUPPL: u32 = 104;
pub const F_GETSIGSINFO: u32 = 105;
pub const F_SETLEASE: u32 = 106;
pub const F_GETLEASE: u32 = 107;
pub const F_TRANSFEREXTENTS: u32 = 110;
pub const FCNTL_FS_SPECIFIC_BASE: u32 = 65536;
pub const F_DUPFD_CLOEXEC: u32 = 67;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_WRLCK: u32 = 3;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const S_IFMT: u32 = 61440;
pub const S_IFIFO: u32 = 4096;
pub const S_IFCHR: u32 = 8192;
pub const S_IFDIR: u32 = 16384;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFWHT: u32 = 57344;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_ISTXT: u32 = 512;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const F_ALLOCATECONTIG: u32 = 2;
pub const F_ALLOCATEALL: u32 = 4;
pub const F_ALLOCATEPERSIST: u32 = 8;
pub const F_PEOFPOSMODE: u32 = 3;
pub const F_VOLPOSMODE: u32 = 4;
pub const USER_FSIGNATURES_CDHASH_LEN: u32 = 20;
pub const GETSIGSINFO_PLATFORM_BINARY: u32 = 1;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const O_POPUP: u32 = 2147483648;
pub const O_ALERT: u32 = 536870912;
pub const API_TO_BE_DEPRECATED: u32 = 100000;
pub const API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const _PATH_HEQUIV: &[u8; 17usize] = b"/etc/hosts.equiv\0";
pub const _PATH_HOSTS: &[u8; 11usize] = b"/etc/hosts\0";
pub const _PATH_NETWORKS: &[u8; 14usize] = b"/etc/networks\0";
pub const _PATH_PROTOCOLS: &[u8; 15usize] = b"/etc/protocols\0";
pub const _PATH_SERVICES: &[u8; 14usize] = b"/etc/services\0";
pub const NETDB_INTERNAL: i32 = -1;
pub const NETDB_SUCCESS: u32 = 0;
pub const HOST_NOT_FOUND: u32 = 1;
pub const TRY_AGAIN: u32 = 2;
pub const NO_RECOVERY: u32 = 3;
pub const NO_DATA: u32 = 4;
pub const NO_ADDRESS: u32 = 4;
pub const EAI_ADDRFAMILY: u32 = 1;
pub const EAI_AGAIN: u32 = 2;
pub const EAI_BADFLAGS: u32 = 3;
pub const EAI_FAIL: u32 = 4;
pub const EAI_FAMILY: u32 = 5;
pub const EAI_MEMORY: u32 = 6;
pub const EAI_NODATA: u32 = 7;
pub const EAI_NONAME: u32 = 8;
pub const EAI_SERVICE: u32 = 9;
pub const EAI_SOCKTYPE: u32 = 10;
pub const EAI_SYSTEM: u32 = 11;
pub const EAI_BADHINTS: u32 = 12;
pub const EAI_PROTOCOL: u32 = 13;
pub const EAI_OVERFLOW: u32 = 14;
pub const EAI_MAX: u32 = 15;
pub const AI_PASSIVE: u32 = 1;
pub const AI_CANONNAME: u32 = 2;
pub const AI_NUMERICHOST: u32 = 4;
pub const AI_NUMERICSERV: u32 = 4096;
pub const AI_ALL: u32 = 256;
pub const AI_V4MAPPED_CFG: u32 = 512;
pub const AI_ADDRCONFIG: u32 = 1024;
pub const AI_V4MAPPED: u32 = 2048;
pub const AI_DEFAULT: u32 = 1536;
pub const AI_UNUSABLE: u32 = 268435456;
pub const NI_MAXHOST: u32 = 1025;
pub const NI_MAXSERV: u32 = 32;
pub const NI_NOFQDN: u32 = 1;
pub const NI_NUMERICHOST: u32 = 2;
pub const NI_NAMEREQD: u32 = 4;
pub const NI_NUMERICSERV: u32 = 8;
pub const NI_NUMERICSCOPE: u32 = 256;
pub const NI_DGRAM: u32 = 16;
pub const NI_WITHSCOPEID: u32 = 32;
pub const SCOPE_DELIMITER: u8 = 37u8;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLWRNORM: u32 = 4;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRBAND: u32 = 256;
pub const POLLEXTEND: u32 = 512;
pub const POLLATTRIB: u32 = 1024;
pub const POLLNLINK: u32 = 2048;
pub const POLLWRITE: u32 = 4096;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLSTANDARD: u32 = 511;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const PTHREAD_MUTEX_POLICY_FAIRSHARE_NP: u32 = 1;
pub const PTHREAD_MUTEX_POLICY_FIRSTFIT_NP: u32 = 3;
pub const SEM_VALUE_MAX: u32 = 32767;
pub const _PATH_LOG: &[u8; 16usize] = b"/var/run/syslog\0";
pub const LOG_EMERG: u32 = 0;
pub const LOG_ALERT: u32 = 1;
pub const LOG_CRIT: u32 = 2;
pub const LOG_ERR: u32 = 3;
pub const LOG_WARNING: u32 = 4;
pub const LOG_NOTICE: u32 = 5;
pub const LOG_INFO: u32 = 6;
pub const LOG_DEBUG: u32 = 7;
pub const LOG_PRIMASK: u32 = 7;
pub const LOG_KERN: u32 = 0;
pub const LOG_USER: u32 = 8;
pub const LOG_MAIL: u32 = 16;
pub const LOG_DAEMON: u32 = 24;
pub const LOG_AUTH: u32 = 32;
pub const LOG_SYSLOG: u32 = 40;
pub const LOG_LPR: u32 = 48;
pub const LOG_NEWS: u32 = 56;
pub const LOG_UUCP: u32 = 64;
pub const LOG_CRON: u32 = 72;
pub const LOG_AUTHPRIV: u32 = 80;
pub const LOG_FTP: u32 = 88;
pub const LOG_NETINFO: u32 = 96;
pub const LOG_REMOTEAUTH: u32 = 104;
pub const LOG_INSTALL: u32 = 112;
pub const LOG_RAS: u32 = 120;
pub const LOG_LOCAL0: u32 = 128;
pub const LOG_LOCAL1: u32 = 136;
pub const LOG_LOCAL2: u32 = 144;
pub const LOG_LOCAL3: u32 = 152;
pub const LOG_LOCAL4: u32 = 160;
pub const LOG_LOCAL5: u32 = 168;
pub const LOG_LOCAL6: u32 = 176;
pub const LOG_LOCAL7: u32 = 184;
pub const LOG_LAUNCHD: u32 = 192;
pub const LOG_NFACILITIES: u32 = 25;
pub const LOG_FACMASK: u32 = 1016;
pub const LOG_PID: u32 = 1;
pub const LOG_CONS: u32 = 2;
pub const LOG_ODELAY: u32 = 4;
pub const LOG_NDELAY: u32 = 8;
pub const LOG_NOWAIT: u32 = 16;
pub const LOG_PERROR: u32 = 32;
pub const VEOF: u32 = 0;
pub const VEOL: u32 = 1;
pub const VEOL2: u32 = 2;
pub const VERASE: u32 = 3;
pub const VWERASE: u32 = 4;
pub const VKILL: u32 = 5;
pub const VREPRINT: u32 = 6;
pub const VINTR: u32 = 8;
pub const VQUIT: u32 = 9;
pub const VSUSP: u32 = 10;
pub const VDSUSP: u32 = 11;
pub const VSTART: u32 = 12;
pub const VSTOP: u32 = 13;
pub const VLNEXT: u32 = 14;
pub const VDISCARD: u32 = 15;
pub const VMIN: u32 = 16;
pub const VTIME: u32 = 17;
pub const VSTATUS: u32 = 18;
pub const NCCS: u32 = 20;
pub const IGNBRK: u32 = 1;
pub const BRKINT: u32 = 2;
pub const IGNPAR: u32 = 4;
pub const PARMRK: u32 = 8;
pub const INPCK: u32 = 16;
pub const ISTRIP: u32 = 32;
pub const INLCR: u32 = 64;
pub const IGNCR: u32 = 128;
pub const ICRNL: u32 = 256;
pub const IXON: u32 = 512;
pub const IXOFF: u32 = 1024;
pub const IXANY: u32 = 2048;
pub const IMAXBEL: u32 = 8192;
pub const IUTF8: u32 = 16384;
pub const OPOST: u32 = 1;
pub const ONLCR: u32 = 2;
pub const OXTABS: u32 = 4;
pub const ONOEOT: u32 = 8;
pub const OCRNL: u32 = 16;
pub const ONOCR: u32 = 32;
pub const ONLRET: u32 = 64;
pub const OFILL: u32 = 128;
pub const NLDLY: u32 = 768;
pub const TABDLY: u32 = 3076;
pub const CRDLY: u32 = 12288;
pub const FFDLY: u32 = 16384;
pub const BSDLY: u32 = 32768;
pub const VTDLY: u32 = 65536;
pub const OFDEL: u32 = 131072;
pub const NL0: u32 = 0;
pub const NL1: u32 = 256;
pub const NL2: u32 = 512;
pub const NL3: u32 = 768;
pub const TAB0: u32 = 0;
pub const TAB1: u32 = 1024;
pub const TAB2: u32 = 2048;
pub const TAB3: u32 = 4;
pub const CR0: u32 = 0;
pub const CR1: u32 = 4096;
pub const CR2: u32 = 8192;
pub const CR3: u32 = 12288;
pub const FF0: u32 = 0;
pub const FF1: u32 = 16384;
pub const BS0: u32 = 0;
pub const BS1: u32 = 32768;
pub const VT0: u32 = 0;
pub const VT1: u32 = 65536;
pub const CIGNORE: u32 = 1;
pub const CSIZE: u32 = 768;
pub const CS5: u32 = 0;
pub const CS6: u32 = 256;
pub const CS7: u32 = 512;
pub const CS8: u32 = 768;
pub const CSTOPB: u32 = 1024;
pub const CREAD: u32 = 2048;
pub const PARENB: u32 = 4096;
pub const PARODD: u32 = 8192;
pub const HUPCL: u32 = 16384;
pub const CLOCAL: u32 = 32768;
pub const CCTS_OFLOW: u32 = 65536;
pub const CRTS_IFLOW: u32 = 131072;
pub const CDTR_IFLOW: u32 = 262144;
pub const CDSR_OFLOW: u32 = 524288;
pub const CCAR_OFLOW: u32 = 1048576;
pub const MDMBUF: u32 = 1048576;
pub const ECHOKE: u32 = 1;
pub const ECHOE: u32 = 2;
pub const ECHOK: u32 = 4;
pub const ECHO: u32 = 8;
pub const ECHONL: u32 = 16;
pub const ECHOPRT: u32 = 32;
pub const ECHOCTL: u32 = 64;
pub const ISIG: u32 = 128;
pub const ICANON: u32 = 256;
pub const ALTWERASE: u32 = 512;
pub const IEXTEN: u32 = 1024;
pub const EXTPROC: u32 = 2048;
pub const TOSTOP: u32 = 4194304;
pub const FLUSHO: u32 = 8388608;
pub const NOKERNINFO: u32 = 33554432;
pub const PENDIN: u32 = 536870912;
pub const NOFLSH: u32 = 2147483648;
pub const TCSANOW: u32 = 0;
pub const TCSADRAIN: u32 = 1;
pub const TCSAFLUSH: u32 = 2;
pub const TCSASOFT: u32 = 16;
pub const B0: u32 = 0;
pub const B50: u32 = 50;
pub const B75: u32 = 75;
pub const B110: u32 = 110;
pub const B134: u32 = 134;
pub const B150: u32 = 150;
pub const B200: u32 = 200;
pub const B300: u32 = 300;
pub const B600: u32 = 600;
pub const B1200: u32 = 1200;
pub const B1800: u32 = 1800;
pub const B2400: u32 = 2400;
pub const B4800: u32 = 4800;
pub const B9600: u32 = 9600;
pub const B19200: u32 = 19200;
pub const B38400: u32 = 38400;
pub const B7200: u32 = 7200;
pub const B14400: u32 = 14400;
pub const B28800: u32 = 28800;
pub const B57600: u32 = 57600;
pub const B76800: u32 = 76800;
pub const B115200: u32 = 115200;
pub const B230400: u32 = 230400;
pub const EXTA: u32 = 19200;
pub const EXTB: u32 = 38400;
pub const TCIFLUSH: u32 = 1;
pub const TCOFLUSH: u32 = 2;
pub const TCIOFLUSH: u32 = 3;
pub const TCOOFF: u32 = 1;
pub const TCOON: u32 = 2;
pub const TCIOFF: u32 = 3;
pub const TCION: u32 = 4;
pub const IOCPARM_MASK: u32 = 8191;
pub const IOCPARM_MAX: u32 = 8192;
pub const TIOCM_LE: u32 = 1;
pub const TIOCM_DTR: u32 = 2;
pub const TIOCM_RTS: u32 = 4;
pub const TIOCM_ST: u32 = 8;
pub const TIOCM_SR: u32 = 16;
pub const TIOCM_CTS: u32 = 32;
pub const TIOCM_CAR: u32 = 64;
pub const TIOCM_CD: u32 = 64;
pub const TIOCM_RNG: u32 = 128;
pub const TIOCM_RI: u32 = 128;
pub const TIOCM_DSR: u32 = 256;
pub const TIOCPKT_DATA: u32 = 0;
pub const TIOCPKT_FLUSHREAD: u32 = 1;
pub const TIOCPKT_FLUSHWRITE: u32 = 2;
pub const TIOCPKT_STOP: u32 = 4;
pub const TIOCPKT_START: u32 = 8;
pub const TIOCPKT_NOSTOP: u32 = 16;
pub const TIOCPKT_DOSTOP: u32 = 32;
pub const TIOCPKT_IOCTL: u32 = 64;
pub const TTYDISC: u32 = 0;
pub const TABLDISC: u32 = 3;
pub const SLIPDISC: u32 = 4;
pub const PPPDISC: u32 = 5;
pub const TTYDEF_IFLAG: u32 = 11010;
pub const TTYDEF_OFLAG: u32 = 3;
pub const TTYDEF_LFLAG: u32 = 1483;
pub const TTYDEF_CFLAG: u32 = 19200;
pub const TTYDEF_SPEED: u32 = 9600;
pub const CEOL: u32 = 255;
pub const CERASE: u32 = 127;
pub const CMIN: u32 = 1;
pub const CQUIT: u32 = 28;
pub const CTIME: u32 = 0;
pub const CBRK: u32 = 255;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: i32 = -1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: i32 = -1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: i32 = -1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const IF_NAMESIZE: u32 = 16;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const APPLE_IF_FAM_LOOPBACK: u32 = 1;
pub const APPLE_IF_FAM_ETHERNET: u32 = 2;
pub const APPLE_IF_FAM_SLIP: u32 = 3;
pub const APPLE_IF_FAM_TUN: u32 = 4;
pub const APPLE_IF_FAM_VLAN: u32 = 5;
pub const APPLE_IF_FAM_PPP: u32 = 6;
pub const APPLE_IF_FAM_PVC: u32 = 7;
pub const APPLE_IF_FAM_DISC: u32 = 8;
pub const APPLE_IF_FAM_MDECAP: u32 = 9;
pub const APPLE_IF_FAM_GIF: u32 = 10;
pub const APPLE_IF_FAM_FAITH: u32 = 11;
pub const APPLE_IF_FAM_STF: u32 = 12;
pub const APPLE_IF_FAM_FIREWIRE: u32 = 13;
pub const APPLE_IF_FAM_BOND: u32 = 14;
pub const APPLE_IF_FAM_CELLULAR: u32 = 15;
pub const APPLE_IF_FAM_UNUSED_16: u32 = 16;
pub const APPLE_IF_FAM_UTUN: u32 = 17;
pub const APPLE_IF_FAM_IPSEC: u32 = 18;
pub const IF_MINMTU: u32 = 72;
pub const IF_MAXMTU: u32 = 65535;
pub const IFNAMSIZ: u32 = 16;
pub const IFF_UP: u32 = 1;
pub const IFF_BROADCAST: u32 = 2;
pub const IFF_DEBUG: u32 = 4;
pub const IFF_LOOPBACK: u32 = 8;
pub const IFF_POINTOPOINT: u32 = 16;
pub const IFF_NOTRAILERS: u32 = 32;
pub const IFF_RUNNING: u32 = 64;
pub const IFF_NOARP: u32 = 128;
pub const IFF_PROMISC: u32 = 256;
pub const IFF_ALLMULTI: u32 = 512;
pub const IFF_OACTIVE: u32 = 1024;
pub const IFF_SIMPLEX: u32 = 2048;
pub const IFF_LINK0: u32 = 4096;
pub const IFF_LINK1: u32 = 8192;
pub const IFF_LINK2: u32 = 16384;
pub const IFF_ALTPHYS: u32 = 16384;
pub const IFF_MULTICAST: u32 = 32768;
pub const IFCAP_RXCSUM: u32 = 1;
pub const IFCAP_TXCSUM: u32 = 2;
pub const IFCAP_VLAN_MTU: u32 = 4;
pub const IFCAP_VLAN_HWTAGGING: u32 = 8;
pub const IFCAP_JUMBO_MTU: u32 = 16;
pub const IFCAP_TSO4: u32 = 32;
pub const IFCAP_TSO6: u32 = 64;
pub const IFCAP_LRO: u32 = 128;
pub const IFCAP_AV: u32 = 256;
pub const IFCAP_TXSTATUS: u32 = 512;
pub const IFCAP_SKYWALK: u32 = 1024;
pub const IFCAP_HW_TIMESTAMP: u32 = 2048;
pub const IFCAP_SW_TIMESTAMP: u32 = 4096;
pub const IFCAP_CSUM_PARTIAL: u32 = 8192;
pub const IFCAP_CSUM_ZERO_INVERT: u32 = 16384;
pub const IFCAP_HWCSUM: u32 = 3;
pub const IFCAP_TSO: u32 = 96;
pub const IFCAP_VALID: u32 = 32767;
pub const IFQ_MAXLEN: u32 = 128;
pub const IFNET_SLOWHZ: u32 = 1;
pub const IFQ_DEF_C_TARGET_DELAY: u32 = 10000000;
pub const IFQ_DEF_C_UPDATE_INTERVAL: u32 = 100000000;
pub const IFQ_DEF_L4S_TARGET_DELAY: u32 = 10000000;
pub const IFQ_DEF_L4S_UPDATE_INTERVAL: u32 = 100000000;
pub const IFQ_LL_C_TARGET_DELAY: u32 = 10000000;
pub const IFQ_LL_C_UPDATE_INTERVAL: u32 = 100000000;
pub const IFQ_LL_L4S_TARGET_DELAY: u32 = 10000000;
pub const IFQ_LL_L4S_UPDATE_INTERVAL: u32 = 100000000;
pub const IF_WAKE_ON_MAGIC_PACKET: u32 = 1;
pub const IFRTYPE_FUNCTIONAL_UNKNOWN: u32 = 0;
pub const IFRTYPE_FUNCTIONAL_LOOPBACK: u32 = 1;
pub const IFRTYPE_FUNCTIONAL_WIRED: u32 = 2;
pub const IFRTYPE_FUNCTIONAL_WIFI_INFRA: u32 = 3;
pub const IFRTYPE_FUNCTIONAL_WIFI_AWDL: u32 = 4;
pub const IFRTYPE_FUNCTIONAL_CELLULAR: u32 = 5;
pub const IFRTYPE_FUNCTIONAL_INTCOPROC: u32 = 6;
pub const IFRTYPE_FUNCTIONAL_COMPANIONLINK: u32 = 7;
pub const IFRTYPE_FUNCTIONAL_LAST: u32 = 7;
pub const IFSTATMAX: u32 = 800;
pub const TH_FIN: u32 = 1;
pub const TH_SYN: u32 = 2;
pub const TH_RST: u32 = 4;
pub const TH_PUSH: u32 = 8;
pub const TH_ACK: u32 = 16;
pub const TH_URG: u32 = 32;
pub const TH_ECE: u32 = 64;
pub const TH_CWR: u32 = 128;
pub const TH_AE: u32 = 256;
pub const TH_FLAGS: u32 = 247;
pub const TH_FLAGS_ALL: u32 = 255;
pub const TH_ACCEPT: u32 = 23;
pub const TH_ACE: u32 = 448;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_MAXSEG: u32 = 2;
pub const TCPOLEN_MAXSEG: u32 = 4;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERMITTED: u32 = 4;
pub const TCPOLEN_SACK_PERMITTED: u32 = 2;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOLEN_SACK: u32 = 8;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_TSTAMP_APPA: u32 = 12;
pub const TCPOPT_TSTAMP_HDR: u32 = 16844810;
pub const MAX_TCPOPTLEN: u32 = 40;
pub const TCPOPT_CC: u32 = 11;
pub const TCPOPT_CCNEW: u32 = 12;
pub const TCPOPT_CCECHO: u32 = 13;
pub const TCPOLEN_CC: u32 = 6;
pub const TCPOLEN_CC_APPA: u32 = 8;
pub const TCPOPT_SIGNATURE: u32 = 19;
pub const TCPOLEN_SIGNATURE: u32 = 18;
pub const TCPOPT_FASTOPEN: u32 = 34;
pub const TCPOLEN_FASTOPEN_REQ: u32 = 2;
pub const TCPOPT_ACCECN0: u32 = 172;
pub const TCPOPT_ACCECN1: u32 = 174;
pub const TCPOLEN_ACCECN_EMPTY: u32 = 2;
pub const TCPOLEN_ACCECN_COUNTER: u32 = 3;
pub const TCPOPT_SACK_HDR: u32 = 16844032;
pub const MAX_SACK_BLKS: u32 = 6;
pub const TCP_MAX_SACK: u32 = 4;
pub const TCP_MSS: u32 = 512;
pub const TCP_MINMSS: u32 = 216;
pub const TCP6_MSS: u32 = 1024;
pub const TCP_MAXWIN: u32 = 65535;
pub const TTCP_CLIENT_SND_WND: u32 = 4096;
pub const TCP_MAX_WINSHIFT: u32 = 14;
pub const TCP_MAXHLEN: u32 = 60;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_NOPUSH: u32 = 4;
pub const TCP_NOOPT: u32 = 8;
pub const TCP_KEEPALIVE: u32 = 16;
pub const TCP_CONNECTIONTIMEOUT: u32 = 32;
pub const PERSIST_TIMEOUT: u32 = 64;
pub const TCP_RXT_CONNDROPTIME: u32 = 128;
pub const TCP_RXT_FINDROP: u32 = 256;
pub const TCP_KEEPINTVL: u32 = 257;
pub const TCP_KEEPCNT: u32 = 258;
pub const TCP_SENDMOREACKS: u32 = 259;
pub const TCP_ENABLE_ECN: u32 = 260;
pub const TCP_FASTOPEN: u32 = 261;
pub const TCP_CONNECTION_INFO: u32 = 262;
pub const TCP_NOTSENT_LOWAT: u32 = 513;
pub const TCPCI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPCI_OPT_SACK: u32 = 2;
pub const TCPCI_OPT_WSCALE: u32 = 4;
pub const TCPCI_OPT_ECN: u32 = 8;
pub const TCPCI_FLAG_LOSSRECOVERY: u32 = 1;
pub const TCPCI_FLAG_REORDERING_DETECTED: u32 = 2;
pub const PROT_NONE: u32 = 0;
pub const PROT_READ: u32 = 1;
pub const PROT_WRITE: u32 = 2;
pub const PROT_EXEC: u32 = 4;
pub const MAP_SHARED: u32 = 1;
pub const MAP_PRIVATE: u32 = 2;
pub const MAP_COPY: u32 = 2;
pub const MAP_FIXED: u32 = 16;
pub const MAP_RENAME: u32 = 32;
pub const MAP_NORESERVE: u32 = 64;
pub const MAP_RESERVED0080: u32 = 128;
pub const MAP_NOEXTEND: u32 = 256;
pub const MAP_HASSEMAPHORE: u32 = 512;
pub const MAP_NOCACHE: u32 = 1024;
pub const MAP_JIT: u32 = 2048;
pub const MAP_FILE: u32 = 0;
pub const MAP_ANON: u32 = 4096;
pub const MAP_ANONYMOUS: u32 = 4096;
pub const MAP_RESILIENT_CODESIGN: u32 = 8192;
pub const MAP_RESILIENT_MEDIA: u32 = 16384;
pub const MAP_32BIT: u32 = 32768;
pub const MAP_TRANSLATED_ALLOW_EXECUTE: u32 = 131072;
pub const MAP_UNIX03: u32 = 262144;
pub const MCL_CURRENT: u32 = 1;
pub const MCL_FUTURE: u32 = 2;
pub const MS_ASYNC: u32 = 1;
pub const MS_INVALIDATE: u32 = 2;
pub const MS_SYNC: u32 = 16;
pub const MS_KILLPAGES: u32 = 4;
pub const MS_DEACTIVATE: u32 = 8;
pub const POSIX_MADV_NORMAL: u32 = 0;
pub const POSIX_MADV_RANDOM: u32 = 1;
pub const POSIX_MADV_SEQUENTIAL: u32 = 2;
pub const POSIX_MADV_WILLNEED: u32 = 3;
pub const POSIX_MADV_DONTNEED: u32 = 4;
pub const MADV_NORMAL: u32 = 0;
pub const MADV_RANDOM: u32 = 1;
pub const MADV_SEQUENTIAL: u32 = 2;
pub const MADV_WILLNEED: u32 = 3;
pub const MADV_DONTNEED: u32 = 4;
pub const MADV_FREE: u32 = 5;
pub const MADV_ZERO_WIRED_PAGES: u32 = 6;
pub const MADV_FREE_REUSABLE: u32 = 7;
pub const MADV_FREE_REUSE: u32 = 8;
pub const MADV_CAN_REUSE: u32 = 9;
pub const MADV_PAGEOUT: u32 = 10;
pub const MINCORE_INCORE: u32 = 1;
pub const MINCORE_REFERENCED: u32 = 2;
pub const MINCORE_MODIFIED: u32 = 4;
pub const MINCORE_REFERENCED_OTHER: u32 = 8;
pub const MINCORE_MODIFIED_OTHER: u32 = 16;
pub const MINCORE_PAGED_OUT: u32 = 32;
pub const MINCORE_COPIED: u32 = 64;
pub const MINCORE_ANONYMOUS: u32 = 128;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const UF_SETTABLE: u32 = 65535;
pub const UF_NODUMP: u32 = 1;
pub const UF_IMMUTABLE: u32 = 2;
pub const UF_APPEND: u32 = 4;
pub const UF_OPAQUE: u32 = 8;
pub const UF_COMPRESSED: u32 = 32;
pub const UF_TRACKED: u32 = 64;
pub const UF_DATAVAULT: u32 = 128;
pub const UF_HIDDEN: u32 = 32768;
pub const SF_SUPPORTED: u32 = 10420224;
pub const SF_SETTABLE: u32 = 1073676288;
pub const SF_SYNTHETIC: u32 = 3221225472;
pub const SF_ARCHIVED: u32 = 65536;
pub const SF_IMMUTABLE: u32 = 131072;
pub const SF_APPEND: u32 = 262144;
pub const SF_RESTRICTED: u32 = 524288;
pub const SF_NOUNLINK: u32 = 1048576;
pub const SF_FIRMLINK: u32 = 8388608;
pub const SF_DATALESS: u32 = 1073741824;
pub const EF_MAY_SHARE_BLOCKS: u32 = 1;
pub const EF_NO_XATTRS: u32 = 2;
pub const EF_IS_SYNC_ROOT: u32 = 4;
pub const EF_IS_PURGEABLE: u32 = 8;
pub const EF_IS_SPARSE: u32 = 16;
pub const EF_IS_SYNTHETIC: u32 = 32;
pub const UTIME_NOW: i32 = -1;
pub const UTIME_OMIT: i32 = -2;
pub const SOL_LOCAL: u32 = 0;
pub const LOCAL_PEERCRED: u32 = 1;
pub const LOCAL_PEERPID: u32 = 2;
pub const LOCAL_PEEREPID: u32 = 3;
pub const LOCAL_PEERUUID: u32 = 4;
pub const LOCAL_PEEREUUID: u32 = 5;
pub const LOCAL_PEERTOKEN: u32 = 6;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const NeXTBSD: u32 = 1995064;
pub const NeXTBSD4_0: u32 = 0;
pub const MAXCOMLEN: u32 = 16;
pub const MAXINTERP: u32 = 64;
pub const MAXLOGNAME: u32 = 255;
pub const MAXUPRC: u32 = 266;
pub const NCARGS: u32 = 1048576;
pub const NGROUPS: u32 = 16;
pub const NOFILE: u32 = 256;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const MAXDOMNAMELEN: u32 = 256;
pub const NBPG: u32 = 4096;
pub const PGOFSET: u32 = 4095;
pub const PGSHIFT: u32 = 12;
pub const DEV_BSIZE: u32 = 512;
pub const DEV_BSHIFT: u32 = 9;
pub const BLKDEV_IOSIZE: u32 = 2048;
pub const MAXPHYS: u32 = 65536;
pub const CLSIZE: u32 = 1;
pub const CLSIZELOG2: u32 = 0;
pub const MSIZESHIFT: u32 = 8;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MBIGCLSHIFT: u32 = 12;
pub const MBIGCLBYTES: u32 = 4096;
pub const M16KCLSHIFT: u32 = 14;
pub const M16KCLBYTES: u32 = 16384;
pub const MCLOFSET: u32 = 2047;
pub const PSWP: u32 = 0;
pub const PVM: u32 = 4;
pub const PINOD: u32 = 8;
pub const PRIBIO: u32 = 16;
pub const PVFS: u32 = 20;
pub const PZERO: u32 = 22;
pub const PSOCK: u32 = 24;
pub const PWAIT: u32 = 32;
pub const PLOCK: u32 = 36;
pub const PPAUSE: u32 = 40;
pub const PUSER: u32 = 50;
pub const MAXPRI: u32 = 127;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PTTYBLOCK: u32 = 512;
pub const PDROP: u32 = 1024;
pub const PSPIN: u32 = 2048;
pub const CMASK: u32 = 18;
pub const CLBYTES: u32 = 4096;
pub const CLOFSET: u32 = 4095;
pub const CLOFF: u32 = 4095;
pub const CLSHIFT: u32 = 12;
pub const CBLOCK: u32 = 64;
pub const CBQSIZE: u32 = 8;
pub const CROUND: u32 = 63;
pub const MAXBSIZE: u32 = 1048576;
pub const MAXPHYSIO: u32 = 65536;
pub const MAXFRAG: u32 = 8;
pub const MAXPHYSIO_WIRED: u32 = 16777216;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const AUDIT_RECORD_MAGIC: u32 = 2190085915;
pub const MAX_AUDIT_RECORDS: u32 = 20;
pub const MAXAUDITDATA: u32 = 32767;
pub const MAX_AUDIT_RECORD_SIZE: u32 = 32767;
pub const MIN_AUDIT_FILE_SIZE: u32 = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: u32 = 4;
pub const AUDIT_TRIGGER_MIN: u32 = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: u32 = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: u32 = 2;
pub const AUDIT_TRIGGER_READ_FILE: u32 = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: u32 = 4;
pub const AUDIT_TRIGGER_NO_SPACE: u32 = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: u32 = 6;
pub const AUDIT_TRIGGER_INITIALIZE: u32 = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: u32 = 8;
pub const AUDIT_TRIGGER_MAX: u32 = 8;
pub const AUDITDEV_FILENAME: &[u8; 6usize] = b"audit\0";
pub const AUDIT_TRIGGER_FILE: &[u8; 11usize] = b"/dev/audit\0";
pub const AU_DEFAUDITSID: u32 = 0;
pub const AU_ASSIGN_ASID: i32 = -1;
pub const AUC_UNSET: u32 = 0;
pub const AUC_AUDITING: u32 = 1;
pub const AUC_NOAUDIT: u32 = 2;
pub const AUC_DISABLED: i32 = -1;
pub const A_OLDGETPOLICY: u32 = 2;
pub const A_OLDSETPOLICY: u32 = 3;
pub const A_GETKMASK: u32 = 4;
pub const A_SETKMASK: u32 = 5;
pub const A_OLDGETQCTRL: u32 = 6;
pub const A_OLDSETQCTRL: u32 = 7;
pub const A_GETCWD: u32 = 8;
pub const A_GETCAR: u32 = 9;
pub const A_GETSTAT: u32 = 12;
pub const A_SETSTAT: u32 = 13;
pub const A_SETUMASK: u32 = 14;
pub const A_SETSMASK: u32 = 15;
pub const A_OLDGETCOND: u32 = 20;
pub const A_OLDSETCOND: u32 = 21;
pub const A_GETCLASS: u32 = 22;
pub const A_SETCLASS: u32 = 23;
pub const A_GETPINFO: u32 = 24;
pub const A_SETPMASK: u32 = 25;
pub const A_SETFSIZE: u32 = 26;
pub const A_GETFSIZE: u32 = 27;
pub const A_GETPINFO_ADDR: u32 = 28;
pub const A_GETKAUDIT: u32 = 29;
pub const A_SETKAUDIT: u32 = 30;
pub const A_SENDTRIGGER: u32 = 31;
pub const A_GETSINFO_ADDR: u32 = 32;
pub const A_GETPOLICY: u32 = 33;
pub const A_SETPOLICY: u32 = 34;
pub const A_GETQCTRL: u32 = 35;
pub const A_SETQCTRL: u32 = 36;
pub const A_GETCOND: u32 = 37;
pub const A_SETCOND: u32 = 38;
pub const A_GETSFLAGS: u32 = 39;
pub const A_SETSFLAGS: u32 = 40;
pub const A_GETCTLMODE: u32 = 41;
pub const A_SETCTLMODE: u32 = 42;
pub const A_GETEXPAFTER: u32 = 43;
pub const A_SETEXPAFTER: u32 = 44;
pub const AUDIT_CNT: u32 = 1;
pub const AUDIT_AHLT: u32 = 2;
pub const AUDIT_ARGV: u32 = 4;
pub const AUDIT_ARGE: u32 = 8;
pub const AUDIT_SEQ: u32 = 16;
pub const AUDIT_WINDATA: u32 = 32;
pub const AUDIT_USER: u32 = 64;
pub const AUDIT_GROUP: u32 = 128;
pub const AUDIT_TRAIL: u32 = 256;
pub const AUDIT_PATH: u32 = 512;
pub const AUDIT_SCNT: u32 = 1024;
pub const AUDIT_PUBLIC: u32 = 2048;
pub const AUDIT_ZONENAME: u32 = 4096;
pub const AUDIT_PERZONE: u32 = 8192;
pub const AQ_HIWATER: u32 = 100;
pub const AQ_MAXHIGH: u32 = 10000;
pub const AQ_LOWATER: u32 = 10;
pub const AQ_BUFSZ: u32 = 32767;
pub const AQ_MAXBUFSZ: u32 = 1048576;
pub const AU_FS_MINFREE: u32 = 20;
pub const AU_IPv4: u32 = 4;
pub const AU_IPv6: u32 = 16;
pub const AU_CLASS_MASK_RESERVED: u32 = 268435456;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const MACH_PORT_NULL: u32 = 0;
pub const MACH_PORT_TYPE_DNREQUEST: u32 = 2147483648;
pub const MACH_PORT_TYPE_SPREQUEST: u32 = 1073741824;
pub const MACH_PORT_TYPE_SPREQUEST_DELAYED: u32 = 536870912;
pub const MACH_PORT_SRIGHTS_NONE: u32 = 0;
pub const MACH_PORT_SRIGHTS_PRESENT: u32 = 1;
pub const MACH_PORT_QLIMIT_ZERO: u32 = 0;
pub const MACH_PORT_QLIMIT_BASIC: u32 = 5;
pub const MACH_PORT_QLIMIT_SMALL: u32 = 16;
pub const MACH_PORT_QLIMIT_LARGE: u32 = 1024;
pub const MACH_PORT_QLIMIT_KERNEL: u32 = 65534;
pub const MACH_PORT_QLIMIT_MIN: u32 = 0;
pub const MACH_PORT_QLIMIT_DEFAULT: u32 = 5;
pub const MACH_PORT_QLIMIT_MAX: u32 = 1024;
pub const MACH_PORT_STATUS_FLAG_TEMPOWNER: u32 = 1;
pub const MACH_PORT_STATUS_FLAG_GUARDED: u32 = 2;
pub const MACH_PORT_STATUS_FLAG_STRICT_GUARD: u32 = 4;
pub const MACH_PORT_STATUS_FLAG_IMP_DONATION: u32 = 8;
pub const MACH_PORT_STATUS_FLAG_REVIVE: u32 = 16;
pub const MACH_PORT_STATUS_FLAG_TASKPTR: u32 = 32;
pub const MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE: u32 = 64;
pub const MACH_PORT_STATUS_FLAG_NO_GRANT: u32 = 128;
pub const MACH_PORT_LIMITS_INFO: u32 = 1;
pub const MACH_PORT_RECEIVE_STATUS: u32 = 2;
pub const MACH_PORT_DNREQUESTS_SIZE: u32 = 3;
pub const MACH_PORT_TEMPOWNER: u32 = 4;
pub const MACH_PORT_IMPORTANCE_RECEIVER: u32 = 5;
pub const MACH_PORT_DENAP_RECEIVER: u32 = 6;
pub const MACH_PORT_INFO_EXT: u32 = 7;
pub const MACH_PORT_GUARD_INFO: u32 = 8;
pub const MACH_PORT_DNREQUESTS_SIZE_COUNT: u32 = 1;
pub const MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN: u32 = 255;
pub const MPO_CONTEXT_AS_GUARD: u32 = 1;
pub const MPO_QLIMIT: u32 = 2;
pub const MPO_TEMPOWNER: u32 = 4;
pub const MPO_IMPORTANCE_RECEIVER: u32 = 8;
pub const MPO_INSERT_SEND_RIGHT: u32 = 16;
pub const MPO_STRICT: u32 = 32;
pub const MPO_DENAP_RECEIVER: u32 = 64;
pub const MPO_IMMOVABLE_RECEIVE: u32 = 128;
pub const MPO_FILTER_MSG: u32 = 256;
pub const MPO_TG_BLOCK_TRACKING: u32 = 512;
pub const MPO_SERVICE_PORT: u32 = 1024;
pub const MPO_CONNECTION_PORT: u32 = 2048;
pub const MPO_REPLY_PORT: u32 = 4096;
pub const MPO_ENFORCE_REPLY_PORT_SEMANTICS: u32 = 8192;
pub const MPO_PROVISIONAL_REPLY_PORT: u32 = 16384;
pub const GUARD_TYPE_MACH_PORT: u32 = 1;
pub const MAX_FATAL_kGUARD_EXC_CODE: u32 = 128;
pub const MPG_FLAGS_NONE: u32 = 0;
pub const MAX_OPTIONAL_kGUARD_EXC_CODE: u32 = 524288;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP: u64 = 72057594037927936;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT: u64 = 144115188075855872;
pub const MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER: u64 = 288230376151711744;
pub const MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR: u64 = 576460752303423488;
pub const MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA: u64 = 1152921504606846976;
pub const MPG_FLAGS_STRICT_REPLY_MASK: i64 = -72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DEALLOC: u64 = 72057594037927936;
pub const MPG_FLAGS_MOD_REFS_PINNED_DESTROY: u64 = 144115188075855872;
pub const MPG_FLAGS_MOD_REFS_PINNED_COPYIN: u64 = 288230376151711744;
pub const MPG_FLAGS_IMMOVABLE_PINNED: u64 = 72057594037927936;
pub const MPG_STRICT: u32 = 1;
pub const MPG_IMMOVABLE_RECEIVE: u32 = 2;
pub const CRF_NOMEMBERD: u32 = 1;
pub const CRF_MAC_ENFORCE: u32 = 2;
pub const XUCRED_VERSION: u32 = 0;
pub const EVFILT_READ: i32 = -1;
pub const EVFILT_WRITE: i32 = -2;
pub const EVFILT_AIO: i32 = -3;
pub const EVFILT_VNODE: i32 = -4;
pub const EVFILT_PROC: i32 = -5;
pub const EVFILT_SIGNAL: i32 = -6;
pub const EVFILT_TIMER: i32 = -7;
pub const EVFILT_MACHPORT: i32 = -8;
pub const EVFILT_FS: i32 = -9;
pub const EVFILT_USER: i32 = -10;
pub const EVFILT_VM: i32 = -12;
pub const EVFILT_EXCEPT: i32 = -15;
pub const EVFILT_SYSCOUNT: u32 = 17;
pub const EVFILT_THREADMARKER: u32 = 17;
pub const KEVENT_FLAG_NONE: u32 = 0;
pub const KEVENT_FLAG_IMMEDIATE: u32 = 1;
pub const KEVENT_FLAG_ERROR_EVENTS: u32 = 2;
pub const EV_ADD: u32 = 1;
pub const EV_DELETE: u32 = 2;
pub const EV_ENABLE: u32 = 4;
pub const EV_DISABLE: u32 = 8;
pub const EV_ONESHOT: u32 = 16;
pub const EV_CLEAR: u32 = 32;
pub const EV_RECEIPT: u32 = 64;
pub const EV_DISPATCH: u32 = 128;
pub const EV_UDATA_SPECIFIC: u32 = 256;
pub const EV_DISPATCH2: u32 = 384;
pub const EV_VANISHED: u32 = 512;
pub const EV_SYSFLAGS: u32 = 61440;
pub const EV_FLAG0: u32 = 4096;
pub const EV_FLAG1: u32 = 8192;
pub const EV_EOF: u32 = 32768;
pub const EV_ERROR: u32 = 16384;
pub const EV_POLL: u32 = 4096;
pub const EV_OOBAND: u32 = 8192;
pub const NOTE_TRIGGER: u32 = 16777216;
pub const NOTE_FFNOP: u32 = 0;
pub const NOTE_FFAND: u32 = 1073741824;
pub const NOTE_FFOR: u32 = 2147483648;
pub const NOTE_FFCOPY: u32 = 3221225472;
pub const NOTE_FFCTRLMASK: u32 = 3221225472;
pub const NOTE_FFLAGSMASK: u32 = 16777215;
pub const NOTE_LOWAT: u32 = 1;
pub const NOTE_OOB: u32 = 2;
pub const NOTE_DELETE: u32 = 1;
pub const NOTE_WRITE: u32 = 2;
pub const NOTE_EXTEND: u32 = 4;
pub const NOTE_ATTRIB: u32 = 8;
pub const NOTE_LINK: u32 = 16;
pub const NOTE_RENAME: u32 = 32;
pub const NOTE_REVOKE: u32 = 64;
pub const NOTE_NONE: u32 = 128;
pub const NOTE_FUNLOCK: u32 = 256;
pub const NOTE_LEASE_DOWNGRADE: u32 = 512;
pub const NOTE_LEASE_RELEASE: u32 = 1024;
pub const NOTE_EXIT: u32 = 2147483648;
pub const NOTE_FORK: u32 = 1073741824;
pub const NOTE_EXEC: u32 = 536870912;
pub const NOTE_SIGNAL: u32 = 134217728;
pub const NOTE_EXITSTATUS: u32 = 67108864;
pub const NOTE_EXIT_DETAIL: u32 = 33554432;
pub const NOTE_PDATAMASK: u32 = 1048575;
pub const NOTE_PCTRLMASK: i32 = -1048576;
pub const NOTE_EXIT_DETAIL_MASK: u32 = 458752;
pub const NOTE_EXIT_DECRYPTFAIL: u32 = 65536;
pub const NOTE_EXIT_MEMORY: u32 = 131072;
pub const NOTE_EXIT_CSERROR: u32 = 262144;
pub const NOTE_VM_PRESSURE: u32 = 2147483648;
pub const NOTE_VM_PRESSURE_TERMINATE: u32 = 1073741824;
pub const NOTE_VM_PRESSURE_SUDDEN_TERMINATE: u32 = 536870912;
pub const NOTE_VM_ERROR: u32 = 268435456;
pub const NOTE_SECONDS: u32 = 1;
pub const NOTE_USECONDS: u32 = 2;
pub const NOTE_NSECONDS: u32 = 4;
pub const NOTE_ABSOLUTE: u32 = 8;
pub const NOTE_LEEWAY: u32 = 16;
pub const NOTE_CRITICAL: u32 = 32;
pub const NOTE_BACKGROUND: u32 = 64;
pub const NOTE_MACH_CONTINUOUS_TIME: u32 = 128;
pub const NOTE_MACHTIME: u32 = 256;
pub const NOTE_TRACK: u32 = 1;
pub const NOTE_TRACKERR: u32 = 2;
pub const NOTE_CHILD: u32 = 4;
pub const SIDL: u32 = 1;
pub const SRUN: u32 = 2;
pub const SSLEEP: u32 = 3;
pub const SSTOP: u32 = 4;
pub const SZOMB: u32 = 5;
pub const P_ADVLOCK: u32 = 1;
pub const P_CONTROLT: u32 = 2;
pub const P_LP64: u32 = 4;
pub const P_NOCLDSTOP: u32 = 8;
pub const P_PPWAIT: u32 = 16;
pub const P_PROFIL: u32 = 32;
pub const P_SELECT: u32 = 64;
pub const P_CONTINUED: u32 = 128;
pub const P_SUGID: u32 = 256;
pub const P_SYSTEM: u32 = 512;
pub const P_TIMEOUT: u32 = 1024;
pub const P_TRACED: u32 = 2048;
pub const P_DISABLE_ASLR: u32 = 4096;
pub const P_WEXIT: u32 = 8192;
pub const P_EXEC: u32 = 16384;
pub const P_OWEUPC: u32 = 32768;
pub const P_AFFINITY: u32 = 65536;
pub const P_TRANSLATED: u32 = 131072;
pub const P_CLASSIC: u32 = 131072;
pub const P_DELAYIDLESLEEP: u32 = 262144;
pub const P_CHECKOPENEVT: u32 = 524288;
pub const P_DEPENDENCY_CAPABLE: u32 = 1048576;
pub const P_REBOOT: u32 = 2097152;
pub const P_RESV6: u32 = 4194304;
pub const P_RESV7: u32 = 8388608;
pub const P_THCWD: u32 = 16777216;
pub const P_RESV9: u32 = 33554432;
pub const P_ADOPTPERSONA: u32 = 67108864;
pub const P_RESV11: u32 = 134217728;
pub const P_NOSHLIB: u32 = 268435456;
pub const P_FORCEQUOTA: u32 = 536870912;
pub const P_NOCLDWAIT: u32 = 1073741824;
pub const P_NOREMOTEHANG: u32 = 2147483648;
pub const P_INMEM: u32 = 0;
pub const P_NOSWAP: u32 = 0;
pub const P_PHYSIO: u32 = 0;
pub const P_FSTRACE: u32 = 0;
pub const P_SSTEP: u32 = 0;
pub const P_DIRTY_TRACK: u32 = 1;
pub const P_DIRTY_ALLOW_IDLE_EXIT: u32 = 2;
pub const P_DIRTY_DEFER: u32 = 4;
pub const P_DIRTY: u32 = 8;
pub const P_DIRTY_SHUTDOWN: u32 = 16;
pub const P_DIRTY_TERMINATED: u32 = 32;
pub const P_DIRTY_BUSY: u32 = 64;
pub const P_DIRTY_MARKED: u32 = 128;
pub const P_DIRTY_AGING_IN_PROGRESS: u32 = 256;
pub const P_DIRTY_LAUNCH_IN_PROGRESS: u32 = 512;
pub const P_DIRTY_DEFER_ALWAYS: u32 = 1024;
pub const P_DIRTY_IS_DIRTY: u32 = 24;
pub const P_DIRTY_IDLE_EXIT_ENABLED: u32 = 3;
pub const CTL_MAXNAME: u32 = 12;
pub const CTLTYPE: u32 = 15;
pub const CTLTYPE_NODE: u32 = 1;
pub const CTLTYPE_INT: u32 = 2;
pub const CTLTYPE_STRING: u32 = 3;
pub const CTLTYPE_QUAD: u32 = 4;
pub const CTLTYPE_OPAQUE: u32 = 5;
pub const CTLTYPE_STRUCT: u32 = 5;
pub const CTLFLAG_RD: u32 = 2147483648;
pub const CTLFLAG_WR: u32 = 1073741824;
pub const CTLFLAG_RW: u32 = 3221225472;
pub const CTLFLAG_NOLOCK: u32 = 536870912;
pub const CTLFLAG_ANYBODY: u32 = 268435456;
pub const CTLFLAG_SECURE: u32 = 134217728;
pub const CTLFLAG_MASKED: u32 = 67108864;
pub const CTLFLAG_NOAUTO: u32 = 33554432;
pub const CTLFLAG_KERN: u32 = 16777216;
pub const CTLFLAG_LOCKED: u32 = 8388608;
pub const CTLFLAG_OID2: u32 = 4194304;
pub const CTLFLAG_EXPERIMENT: u32 = 1048576;
pub const OID_AUTO: i32 = -1;
pub const OID_AUTO_START: u32 = 100;
pub const CTL_UNSPEC: u32 = 0;
pub const CTL_KERN: u32 = 1;
pub const CTL_VM: u32 = 2;
pub const CTL_VFS: u32 = 3;
pub const CTL_NET: u32 = 4;
pub const CTL_DEBUG: u32 = 5;
pub const CTL_HW: u32 = 6;
pub const CTL_MACHDEP: u32 = 7;
pub const CTL_USER: u32 = 8;
pub const CTL_MAXID: u32 = 9;
pub const KERN_OSTYPE: u32 = 1;
pub const KERN_OSRELEASE: u32 = 2;
pub const KERN_OSREV: u32 = 3;
pub const KERN_VERSION: u32 = 4;
pub const KERN_MAXVNODES: u32 = 5;
pub const KERN_MAXPROC: u32 = 6;
pub const KERN_MAXFILES: u32 = 7;
pub const KERN_ARGMAX: u32 = 8;
pub const KERN_SECURELVL: u32 = 9;
pub const KERN_HOSTNAME: u32 = 10;
pub const KERN_HOSTID: u32 = 11;
pub const KERN_CLOCKRATE: u32 = 12;
pub const KERN_VNODE: u32 = 13;
pub const KERN_PROC: u32 = 14;
pub const KERN_FILE: u32 = 15;
pub const KERN_PROF: u32 = 16;
pub const KERN_POSIX1: u32 = 17;
pub const KERN_NGROUPS: u32 = 18;
pub const KERN_JOB_CONTROL: u32 = 19;
pub const KERN_SAVED_IDS: u32 = 20;
pub const KERN_BOOTTIME: u32 = 21;
pub const KERN_NISDOMAINNAME: u32 = 22;
pub const KERN_DOMAINNAME: u32 = 22;
pub const KERN_MAXPARTITIONS: u32 = 23;
pub const KERN_KDEBUG: u32 = 24;
pub const KERN_UPDATEINTERVAL: u32 = 25;
pub const KERN_OSRELDATE: u32 = 26;
pub const KERN_NTP_PLL: u32 = 27;
pub const KERN_BOOTFILE: u32 = 28;
pub const KERN_MAXFILESPERPROC: u32 = 29;
pub const KERN_MAXPROCPERUID: u32 = 30;
pub const KERN_DUMPDEV: u32 = 31;
pub const KERN_IPC: u32 = 32;
pub const KERN_DUMMY: u32 = 33;
pub const KERN_PS_STRINGS: u32 = 34;
pub const KERN_USRSTACK32: u32 = 35;
pub const KERN_LOGSIGEXIT: u32 = 36;
pub const KERN_SYMFILE: u32 = 37;
pub const KERN_PROCARGS: u32 = 38;
pub const KERN_NETBOOT: u32 = 40;
pub const KERN_SYSV: u32 = 42;
pub const KERN_AFFINITY: u32 = 43;
pub const KERN_TRANSLATE: u32 = 44;
pub const KERN_CLASSIC: u32 = 44;
pub const KERN_EXEC: u32 = 45;
pub const KERN_CLASSICHANDLER: u32 = 45;
pub const KERN_AIOMAX: u32 = 46;
pub const KERN_AIOPROCMAX: u32 = 47;
pub const KERN_AIOTHREADS: u32 = 48;
pub const KERN_PROCARGS2: u32 = 49;
pub const KERN_COREFILE: u32 = 50;
pub const KERN_COREDUMP: u32 = 51;
pub const KERN_SUGID_COREDUMP: u32 = 52;
pub const KERN_PROCDELAYTERM: u32 = 53;
pub const KERN_SHREG_PRIVATIZABLE: u32 = 54;
pub const KERN_LOW_PRI_WINDOW: u32 = 56;
pub const KERN_LOW_PRI_DELAY: u32 = 57;
pub const KERN_POSIX: u32 = 58;
pub const KERN_USRSTACK64: u32 = 59;
pub const KERN_NX_PROTECTION: u32 = 60;
pub const KERN_TFP: u32 = 61;
pub const KERN_PROCNAME: u32 = 62;
pub const KERN_THALTSTACK: u32 = 63;
pub const KERN_SPECULATIVE_READS: u32 = 64;
pub const KERN_OSVERSION: u32 = 65;
pub const KERN_SAFEBOOT: u32 = 66;
pub const KERN_RAGEVNODE: u32 = 68;
pub const KERN_TTY: u32 = 69;
pub const KERN_CHECKOPENEVT: u32 = 70;
pub const KERN_THREADNAME: u32 = 71;
pub const KERN_MAXID: u32 = 72;
pub const KERN_USRSTACK: u32 = 59;
pub const KERN_RAGE_PROC: u32 = 1;
pub const KERN_RAGE_THREAD: u32 = 2;
pub const KERN_UNRAGE_PROC: u32 = 3;
pub const KERN_UNRAGE_THREAD: u32 = 4;
pub const KERN_OPENEVT_PROC: u32 = 1;
pub const KERN_UNOPENEVT_PROC: u32 = 2;
pub const KERN_TFP_POLICY: u32 = 1;
pub const KERN_TFP_POLICY_DENY: u32 = 0;
pub const KERN_TFP_POLICY_DEFAULT: u32 = 2;
pub const KERN_KDEFLAGS: u32 = 1;
pub const KERN_KDDFLAGS: u32 = 2;
pub const KERN_KDENABLE: u32 = 3;
pub const KERN_KDSETBUF: u32 = 4;
pub const KERN_KDGETBUF: u32 = 5;
pub const KERN_KDSETUP: u32 = 6;
pub const KERN_KDREMOVE: u32 = 7;
pub const KERN_KDSETREG: u32 = 8;
pub const KERN_KDGETREG: u32 = 9;
pub const KERN_KDREADTR: u32 = 10;
pub const KERN_KDPIDTR: u32 = 11;
pub const KERN_KDTHRMAP: u32 = 12;
pub const KERN_KDPIDEX: u32 = 14;
pub const KERN_KDSETRTCDEC: u32 = 15;
pub const KERN_KDGETENTROPY: u32 = 16;
pub const KERN_KDWRITETR: u32 = 17;
pub const KERN_KDWRITEMAP: u32 = 18;
pub const KERN_KDTEST: u32 = 19;
pub const KERN_KDREADCURTHRMAP: u32 = 21;
pub const KERN_KDSET_TYPEFILTER: u32 = 22;
pub const KERN_KDBUFWAIT: u32 = 23;
pub const KERN_KDCPUMAP: u32 = 24;
pub const KERN_KDCPUMAP_EXT: u32 = 25;
pub const KERN_KDSET_EDM: u32 = 26;
pub const KERN_KDGET_EDM: u32 = 27;
pub const KERN_KDWRITETR_V3: u32 = 28;
pub const KERN_PROC_ALL: u32 = 0;
pub const KERN_PROC_PID: u32 = 1;
pub const KERN_PROC_PGRP: u32 = 2;
pub const KERN_PROC_SESSION: u32 = 3;
pub const KERN_PROC_TTY: u32 = 4;
pub const KERN_PROC_UID: u32 = 5;
pub const KERN_PROC_RUID: u32 = 6;
pub const KERN_PROC_LCID: u32 = 7;
pub const KERN_VFSNSPACE_HANDLE_PROC: u32 = 1;
pub const KERN_VFSNSPACE_UNHANDLE_PROC: u32 = 2;
pub const WMESGLEN: u32 = 7;
pub const EPROC_CTTY: u32 = 1;
pub const EPROC_SLEADER: u32 = 2;
pub const COMAPT_MAXLOGNAME: u32 = 12;
pub const KIPC_MAXSOCKBUF: u32 = 1;
pub const KIPC_SOCKBUF_WASTE: u32 = 2;
pub const KIPC_SOMAXCONN: u32 = 3;
pub const KIPC_MAX_LINKHDR: u32 = 4;
pub const KIPC_MAX_PROTOHDR: u32 = 5;
pub const KIPC_MAX_HDR: u32 = 6;
pub const KIPC_MAX_DATALEN: u32 = 7;
pub const KIPC_MBSTAT: u32 = 8;
pub const KIPC_NMBCLUSTERS: u32 = 9;
pub const KIPC_SOQLIMITCOMPAT: u32 = 10;
pub const VM_METER: u32 = 1;
pub const VM_LOADAVG: u32 = 2;
pub const VM_MACHFACTOR: u32 = 4;
pub const VM_SWAPUSAGE: u32 = 5;
pub const VM_MAXID: u32 = 6;
pub const LSCALE: u32 = 1000;
pub const HW_MACHINE: u32 = 1;
pub const HW_MODEL: u32 = 2;
pub const HW_NCPU: u32 = 3;
pub const HW_BYTEORDER: u32 = 4;
pub const HW_PHYSMEM: u32 = 5;
pub const HW_USERMEM: u32 = 6;
pub const HW_PAGESIZE: u32 = 7;
pub const HW_DISKNAMES: u32 = 8;
pub const HW_DISKSTATS: u32 = 9;
pub const HW_EPOCH: u32 = 10;
pub const HW_FLOATINGPT: u32 = 11;
pub const HW_MACHINE_ARCH: u32 = 12;
pub const HW_VECTORUNIT: u32 = 13;
pub const HW_BUS_FREQ: u32 = 14;
pub const HW_CPU_FREQ: u32 = 15;
pub const HW_CACHELINE: u32 = 16;
pub const HW_L1ICACHESIZE: u32 = 17;
pub const HW_L1DCACHESIZE: u32 = 18;
pub const HW_L2SETTINGS: u32 = 19;
pub const HW_L2CACHESIZE: u32 = 20;
pub const HW_L3SETTINGS: u32 = 21;
pub const HW_L3CACHESIZE: u32 = 22;
pub const HW_TB_FREQ: u32 = 23;
pub const HW_MEMSIZE: u32 = 24;
pub const HW_AVAILCPU: u32 = 25;
pub const HW_TARGET: u32 = 26;
pub const HW_PRODUCT: u32 = 27;
pub const HW_MAXID: u32 = 28;
pub const USER_CS_PATH: u32 = 1;
pub const USER_BC_BASE_MAX: u32 = 2;
pub const USER_BC_DIM_MAX: u32 = 3;
pub const USER_BC_SCALE_MAX: u32 = 4;
pub const USER_BC_STRING_MAX: u32 = 5;
pub const USER_COLL_WEIGHTS_MAX: u32 = 6;
pub const USER_EXPR_NEST_MAX: u32 = 7;
pub const USER_LINE_MAX: u32 = 8;
pub const USER_RE_DUP_MAX: u32 = 9;
pub const USER_POSIX2_VERSION: u32 = 10;
pub const USER_POSIX2_C_BIND: u32 = 11;
pub const USER_POSIX2_C_DEV: u32 = 12;
pub const USER_POSIX2_CHAR_TERM: u32 = 13;
pub const USER_POSIX2_FORT_DEV: u32 = 14;
pub const USER_POSIX2_FORT_RUN: u32 = 15;
pub const USER_POSIX2_LOCALEDEF: u32 = 16;
pub const USER_POSIX2_SW_DEV: u32 = 17;
pub const USER_POSIX2_UPE: u32 = 18;
pub const USER_STREAM_MAX: u32 = 19;
pub const USER_TZNAME_MAX: u32 = 20;
pub const USER_MAXID: u32 = 21;
pub const CTL_DEBUG_NAME: u32 = 0;
pub const CTL_DEBUG_VALUE: u32 = 1;
pub const CTL_DEBUG_MAXID: u32 = 20;
pub const REG_BASIC: u32 = 0;
pub const REG_EXTENDED: u32 = 1;
pub const REG_ICASE: u32 = 2;
pub const REG_NOSUB: u32 = 4;
pub const REG_NEWLINE: u32 = 8;
pub const REG_NOSPEC: u32 = 16;
pub const REG_LITERAL: u32 = 16;
pub const REG_PEND: u32 = 32;
pub const REG_MINIMAL: u32 = 64;
pub const REG_UNGREEDY: u32 = 64;
pub const REG_DUMP: u32 = 128;
pub const REG_ENHANCED: u32 = 256;
pub const REG_ENOSYS: i32 = -1;
pub const REG_NOMATCH: u32 = 1;
pub const REG_BADPAT: u32 = 2;
pub const REG_ECOLLATE: u32 = 3;
pub const REG_ECTYPE: u32 = 4;
pub const REG_EESCAPE: u32 = 5;
pub const REG_ESUBREG: u32 = 6;
pub const REG_EBRACK: u32 = 7;
pub const REG_EPAREN: u32 = 8;
pub const REG_EBRACE: u32 = 9;
pub const REG_BADBR: u32 = 10;
pub const REG_ERANGE: u32 = 11;
pub const REG_ESPACE: u32 = 12;
pub const REG_BADRPT: u32 = 13;
pub const REG_EMPTY: u32 = 14;
pub const REG_ASSERT: u32 = 15;
pub const REG_INVARG: u32 = 16;
pub const REG_ILLSEQ: u32 = 17;
pub const REG_ATOI: u32 = 255;
pub const REG_ITOA: u32 = 256;
pub const REG_NOTBOL: u32 = 1;
pub const REG_NOTEOL: u32 = 2;
pub const REG_STARTEND: u32 = 4;
pub const REG_TRACE: u32 = 256;
pub const REG_LARGE: u32 = 512;
pub const REG_BACKR: u32 = 1024;
pub const REG_BACKTRACKING_MATCHER: u32 = 1024;
pub const no_argument: u32 = 0;
pub const required_argument: u32 = 1;
pub const optional_argument: u32 = 2;
pub const SPDK_CPUSET_SIZE: u32 = 1024;
pub const SPDK_DEFAULT_RPC_ADDR: &[u8; 19usize] = b"/var/tmp/spdk.sock\0";
pub const SPDK_APP_GETOPT_STRING: &[u8; 31usize] = b"c:de:ghi:m:n:p:r:s:uvA:B:L:RW:\0";
pub const SPDK_PCI_ANY_ID: u32 = 65535;
pub const SPDK_PCI_VID_INTEL: u32 = 32902;
pub const SPDK_PCI_VID_MEMBLAZE: u32 = 7263;
pub const SPDK_PCI_VID_SAMSUNG: u32 = 5197;
pub const SPDK_PCI_VID_VIRTUALBOX: u32 = 33006;
pub const SPDK_PCI_VID_VIRTIO: u32 = 6900;
pub const SPDK_PCI_VID_CNEXLABS: u32 = 7453;
pub const SPDK_PCI_VID_VMWARE: u32 = 5549;
pub const SPDK_PCI_CLASS_ANY_ID: u32 = 16777215;
pub const SPDK_PCI_CLASS_NVME: u32 = 67586;
pub const PCI_DEVICE_ID_INTEL_IDXD: u32 = 2853;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB0: u32 = 15392;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB1: u32 = 15393;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB2: u32 = 15394;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB3: u32 = 15395;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB4: u32 = 15396;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB5: u32 = 15397;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB6: u32 = 15398;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB7: u32 = 15399;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB8: u32 = 15406;
pub const PCI_DEVICE_ID_INTEL_IOAT_SNB9: u32 = 15407;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB0: u32 = 3616;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB1: u32 = 3617;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB2: u32 = 3618;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB3: u32 = 3619;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB4: u32 = 3620;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB5: u32 = 3621;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB6: u32 = 3622;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB7: u32 = 3623;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB8: u32 = 3630;
pub const PCI_DEVICE_ID_INTEL_IOAT_IVB9: u32 = 3631;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW0: u32 = 12064;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW1: u32 = 12065;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW2: u32 = 12066;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW3: u32 = 12067;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW4: u32 = 12068;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW5: u32 = 12069;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW6: u32 = 12070;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW7: u32 = 12071;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW8: u32 = 12078;
pub const PCI_DEVICE_ID_INTEL_IOAT_HSW9: u32 = 12079;
pub const PCI_DEVICE_ID_INTEL_IOAT_BWD0: u32 = 3152;
pub const PCI_DEVICE_ID_INTEL_IOAT_BWD1: u32 = 3153;
pub const PCI_DEVICE_ID_INTEL_IOAT_BWD2: u32 = 3154;
pub const PCI_DEVICE_ID_INTEL_IOAT_BWD3: u32 = 3155;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDXDE0: u32 = 28496;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDXDE1: u32 = 28497;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDXDE2: u32 = 28498;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDXDE3: u32 = 28499;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX0: u32 = 28448;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX1: u32 = 28449;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX2: u32 = 28450;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX3: u32 = 28451;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX4: u32 = 28452;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX5: u32 = 28453;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX6: u32 = 28454;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX7: u32 = 28455;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX8: u32 = 28462;
pub const PCI_DEVICE_ID_INTEL_IOAT_BDX9: u32 = 28463;
pub const PCI_DEVICE_ID_INTEL_IOAT_SKX: u32 = 8225;
pub const PCI_DEVICE_ID_INTEL_IOAT_ICX: u32 = 2816;
pub const PCI_DEVICE_ID_VIRTIO_BLK_LEGACY: u32 = 4097;
pub const PCI_DEVICE_ID_VIRTIO_SCSI_LEGACY: u32 = 4100;
pub const PCI_DEVICE_ID_VIRTIO_BLK_MODERN: u32 = 4162;
pub const PCI_DEVICE_ID_VIRTIO_SCSI_MODERN: u32 = 4168;
pub const PCI_DEVICE_ID_VIRTIO_VHOST_USER: u32 = 4119;
pub const PCI_DEVICE_ID_INTEL_VMD: u32 = 8221;
pub const SPDK_ENV_SOCKET_ID_ANY: i32 = -1;
pub const SPDK_ENV_LCORE_ID_ANY: u32 = 4294967295;
pub const SPDK_MALLOC_DMA: u32 = 1;
pub const SPDK_MALLOC_SHARE: u32 = 2;
pub const SPDK_MAX_MEMZONE_NAME_LEN: u32 = 32;
pub const SPDK_MAX_MEMPOOL_NAME_LEN: u32 = 29;
pub const SPDK_MEMZONE_NO_IOVA_CONTIG: u32 = 1048576;
pub const SPDK_MEMPOOL_DEFAULT_CACHE_SIZE: i32 = -1;
pub const SPDK_VTOPHYS_ERROR: i32 = -1;
pub const SPDK_PCI_DRIVER_NEED_MAPPING: u32 = 1;
pub const SPDK_PCI_DRIVER_WC_ACTIVATE: u32 = 2;
pub const SPDK_NVME_MAX_IO_QUEUES: u32 = 65535;
pub const SPDK_NVME_ADMIN_QUEUE_MIN_ENTRIES: u32 = 2;
pub const SPDK_NVME_ADMIN_QUEUE_MAX_ENTRIES: u32 = 4096;
pub const SPDK_NVME_IO_QUEUE_MIN_ENTRIES: u32 = 2;
pub const SPDK_NVME_IO_QUEUE_MAX_ENTRIES: u32 = 65536;
pub const SPDK_NVME_DATASET_MANAGEMENT_MAX_RANGES: u32 = 256;
pub const SPDK_NVME_DATASET_MANAGEMENT_RANGE_MAX_BLOCKS: u32 = 4294967295;
pub const SPDK_NVME_NSSR_VALUE: u32 = 1314278757;
pub const SPDK_NVME_CREATE_IO_SQ_QPRIO_MASK: u32 = 3;
pub const SPDK_NVME_ARBITRATION_BURST_UNLIMITED: u32 = 7;
pub const SPDK_NVME_MAX_OPC: u32 = 255;
pub const SPDK_NVME_CTRLR_SN_LEN: u32 = 20;
pub const SPDK_NVME_CTRLR_MN_LEN: u32 = 40;
pub const SPDK_NVME_CTRLR_FR_LEN: u32 = 8;
pub const SPDK_NVME_NQN_FIELD_SIZE: u32 = 256;
pub const SPDK_NVME_REGISTRATION_PREEMPTED_MASK: u32 = 2;
pub const SPDK_NVME_RESERVATION_RELEASED_MASK: u32 = 4;
pub const SPDK_NVME_RESERVATION_PREEMPTED_MASK: u32 = 8;
pub const SPDK_NVME_IO_FLAGS_STREAMS_DIRECTIVE: u32 = 1048576;
pub const SPDK_NVME_IO_FLAGS_ZONE_APPEND_PIREMAP: u32 = 33554432;
pub const SPDK_NVME_IO_FLAGS_PRCHK_REFTAG: u32 = 67108864;
pub const SPDK_NVME_IO_FLAGS_PRCHK_APPTAG: u32 = 134217728;
pub const SPDK_NVME_IO_FLAGS_PRCHK_GUARD: u32 = 268435456;
pub const SPDK_NVME_IO_FLAGS_PRACT: u32 = 536870912;
pub const SPDK_NVME_IO_FLAGS_FORCE_UNIT_ACCESS: u32 = 1073741824;
pub const SPDK_NVME_IO_FLAGS_LIMITED_RETRY: u32 = 2147483648;
pub const SPDK_NVME_IO_FLAGS_VALID_MASK: u32 = 4294901763;
pub const SPDK_NVME_IO_FLAGS_CDW12_MASK: u32 = 4294901760;
pub const SPDK_NVME_OPC_FABRIC: u32 = 127;
pub const SPDK_NVMF_PROP_SIZE_4: u32 = 0;
pub const SPDK_NVMF_PROP_SIZE_8: u32 = 1;
pub const SPDK_NVMF_NQN_MIN_LEN: u32 = 11;
pub const SPDK_NVMF_NQN_MAX_LEN: u32 = 223;
pub const SPDK_NVMF_NQN_UUID_PRE_LEN: u32 = 32;
pub const SPDK_NVMF_UUID_STRING_LEN: u32 = 36;
pub const SPDK_NVMF_NQN_UUID_PRE: &[u8; 33usize] = b"nqn.2014-08.org.nvmexpress:uuid:\0";
pub const SPDK_NVMF_DISCOVERY_NQN: &[u8; 37usize] = b"nqn.2014-08.org.nvmexpress.discovery\0";
pub const SPDK_DOMAIN_LABEL_MAX_LEN: u32 = 63;
pub const SPDK_NVMF_TRSTRING_MAX_LEN: u32 = 32;
pub const SPDK_NVMF_TRADDR_MAX_LEN: u32 = 256;
pub const SPDK_NVMF_TRSVCID_MAX_LEN: u32 = 32;
pub const SPDK_NVMF_MIN_ADMIN_MAX_SQ_SIZE: u32 = 32;
pub const SPDK_NVME_SGL_SUBTYPE_INVALIDATE_KEY: u32 = 15;
pub const SPDK_NVME_TCP_CH_FLAGS_HDGSTF: u32 = 1;
pub const SPDK_NVME_TCP_CH_FLAGS_DDGSTF: u32 = 2;
pub const SPDK_NVME_TCP_CPDA_MAX: u32 = 31;
pub const SPDK_NVME_TCP_PDU_PDO_MAX_OFFSET: u32 = 128;
pub const SPDK_NVME_TCP_TERM_REQ_ERROR_DATA_MAX_SIZE: u32 = 128;
pub const SPDK_NVME_TCP_H2C_DATA_FLAGS_LAST_PDU: u32 = 4;
pub const SPDK_NVME_TCP_H2C_DATA_FLAGS_SUCCESS: u32 = 8;
pub const SPDK_NVME_TCP_H2C_DATA_PDO_MULT: u32 = 8;
pub const SPDK_NVME_TCP_C2H_DATA_FLAGS_SUCCESS: u32 = 8;
pub const SPDK_NVME_TCP_C2H_DATA_FLAGS_LAST_PDU: u32 = 4;
pub const SPDK_NVME_TCP_C2H_DATA_PDO_MULT: u32 = 8;
pub const NR_MAX_NAMESPACE: u32 = 128;
pub const NR_MAX_TRANSPORT: u32 = 4;
pub const KB: u32 = 1024;
pub const MB: u32 = 1048576;
pub const GB: u32 = 1073741824;
pub const SPDK_UUID_STRING_LEN: u32 = 37;
pub const POS_IO_STATUS_SUCCESS: u32 = 0;
pub const POS_IO_STATUS_FAIL: i32 = -1;
pub const VOLUME_NAME_MAX_LEN: u32 = 255;
pub const NR_MAX_VOLUME: u32 = 256;
pub const ARRAY_NAME_MAX_LEN: u32 = 63;
extern "C" {
    pub fn __assert_rtn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___mbstate8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__mbstate8)
            )
        );
    }
    test_field___mbstate8();
    fn test_field__mbstateL() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(_mbstateL)
            )
        );
    }
    test_field__mbstateL();
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    fn test_field___routine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__routine)
            )
        );
    }
    test_field___routine();
    fn test_field___arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__arg)
            )
        );
    }
    test_field___arg();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_pthread_handler_rec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_pthread_handler_rec),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_attr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_attr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_cond_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_condattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_condattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutex_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_mutexattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_mutexattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_once_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_once_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlock_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlock_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_rwlockattr_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_rwlockattr_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    fn test_field___sig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__sig)
            )
        );
    }
    test_field___sig();
    fn test_field___cleanup_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__cleanup_stack)
            )
        );
    }
    test_field___cleanup_stack();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_opaque_pthread_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_opaque_pthread_t),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type size_t = __darwin_size_t;
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
pub type wint_t = __darwin_wint_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneEntry {
    pub __min: __darwin_rune_t,
    pub __max: __darwin_rune_t,
    pub __map: __darwin_rune_t,
    pub __types: *mut __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneEntry() {
    assert_eq!(
        ::std::mem::size_of::<_RuneEntry>(),
        24usize,
        concat!("Size of: ", stringify!(_RuneEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneEntry))
    );
    fn test_field___min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__min) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__min)
            )
        );
    }
    test_field___min();
    fn test_field___max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__max) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__max)
            )
        );
    }
    test_field___max();
    fn test_field___map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__map) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__map)
            )
        );
    }
    test_field___map();
    fn test_field___types() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneEntry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__types) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneEntry),
                "::",
                stringify!(__types)
            )
        );
    }
    test_field___types();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneRange {
    pub __nranges: ::std::os::raw::c_int,
    pub __ranges: *mut _RuneEntry,
}
#[test]
fn bindgen_test_layout__RuneRange() {
    assert_eq!(
        ::std::mem::size_of::<_RuneRange>(),
        16usize,
        concat!("Size of: ", stringify!(_RuneRange))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneRange>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneRange))
    );
    fn test_field___nranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nranges) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__nranges)
            )
        );
    }
    test_field___nranges();
    fn test_field___ranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneRange>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ranges) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneRange),
                "::",
                stringify!(__ranges)
            )
        );
    }
    test_field___ranges();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneCharClass {
    pub __name: [::std::os::raw::c_char; 14usize],
    pub __mask: __uint32_t,
}
#[test]
fn bindgen_test_layout__RuneCharClass() {
    assert_eq!(
        ::std::mem::size_of::<_RuneCharClass>(),
        20usize,
        concat!("Size of: ", stringify!(_RuneCharClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneCharClass>(),
        4usize,
        concat!("Alignment of ", stringify!(_RuneCharClass))
    );
    fn test_field___name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__name)
            )
        );
    }
    test_field___name();
    fn test_field___mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneCharClass>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneCharClass),
                "::",
                stringify!(__mask)
            )
        );
    }
    test_field___mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RuneLocale {
    pub __magic: [::std::os::raw::c_char; 8usize],
    pub __encoding: [::std::os::raw::c_char; 32usize],
    pub __sgetrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: __darwin_size_t,
            arg3: *mut *const ::std::os::raw::c_char,
        ) -> __darwin_rune_t,
    >,
    pub __sputrune: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: __darwin_rune_t,
            arg2: *mut ::std::os::raw::c_char,
            arg3: __darwin_size_t,
            arg4: *mut *mut ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub __invalid_rune: __darwin_rune_t,
    pub __runetype: [__uint32_t; 256usize],
    pub __maplower: [__darwin_rune_t; 256usize],
    pub __mapupper: [__darwin_rune_t; 256usize],
    pub __runetype_ext: _RuneRange,
    pub __maplower_ext: _RuneRange,
    pub __mapupper_ext: _RuneRange,
    pub __variable: *mut ::std::os::raw::c_void,
    pub __variable_len: ::std::os::raw::c_int,
    pub __ncharclasses: ::std::os::raw::c_int,
    pub __charclasses: *mut _RuneCharClass,
}
#[test]
fn bindgen_test_layout__RuneLocale() {
    assert_eq!(
        ::std::mem::size_of::<_RuneLocale>(),
        3208usize,
        concat!("Size of: ", stringify!(_RuneLocale))
    );
    assert_eq!(
        ::std::mem::align_of::<_RuneLocale>(),
        8usize,
        concat!("Alignment of ", stringify!(_RuneLocale))
    );
    fn test_field___magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__magic)
            )
        );
    }
    test_field___magic();
    fn test_field___encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__encoding) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__encoding)
            )
        );
    }
    test_field___encoding();
    fn test_field___sgetrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sgetrune) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sgetrune)
            )
        );
    }
    test_field___sgetrune();
    fn test_field___sputrune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sputrune) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__sputrune)
            )
        );
    }
    test_field___sputrune();
    fn test_field___invalid_rune() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__invalid_rune) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__invalid_rune)
            )
        );
    }
    test_field___invalid_rune();
    fn test_field___runetype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype)
            )
        );
    }
    test_field___runetype();
    fn test_field___maplower() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower) as usize - ptr as usize
            },
            1084usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower)
            )
        );
    }
    test_field___maplower();
    fn test_field___mapupper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper) as usize - ptr as usize
            },
            2108usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper)
            )
        );
    }
    test_field___mapupper();
    fn test_field___runetype_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__runetype_ext) as usize - ptr as usize
            },
            3136usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__runetype_ext)
            )
        );
    }
    test_field___runetype_ext();
    fn test_field___maplower_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__maplower_ext) as usize - ptr as usize
            },
            3152usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__maplower_ext)
            )
        );
    }
    test_field___maplower_ext();
    fn test_field___mapupper_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mapupper_ext) as usize - ptr as usize
            },
            3168usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__mapupper_ext)
            )
        );
    }
    test_field___mapupper_ext();
    fn test_field___variable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable) as usize - ptr as usize
            },
            3184usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable)
            )
        );
    }
    test_field___variable();
    fn test_field___variable_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__variable_len) as usize - ptr as usize
            },
            3192usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__variable_len)
            )
        );
    }
    test_field___variable_len();
    fn test_field___ncharclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ncharclasses) as usize - ptr as usize
            },
            3196usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__ncharclasses)
            )
        );
    }
    test_field___ncharclasses();
    fn test_field___charclasses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RuneLocale>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__charclasses) as usize - ptr as usize
            },
            3200usize,
            concat!(
                "Offset of field: ",
                stringify!(_RuneLocale),
                "::",
                stringify!(__charclasses)
            )
        );
    }
    test_field___charclasses();
}
extern "C" {
    pub static mut _DefaultRuneLocale: _RuneLocale;
}
extern "C" {
    pub static mut _CurrentRuneLocale: *mut _RuneLocale;
}
extern "C" {
    pub fn ___runetype(arg1: __darwin_ct_rune_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn ___tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn ___toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __maskrune(
        arg1: __darwin_ct_rune_t,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
extern "C" {
    pub fn __tolower(arg1: __darwin_ct_rune_t) -> __darwin_ct_rune_t;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<imaxdiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(imaxdiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    fn test_field__base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_base)
            )
        );
    }
    test_field__base();
    fn test_field__size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sbuf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sbuf),
                "::",
                stringify!(_size)
            )
        );
    }
    test_field__size();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    fn test_field__p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_p)
            )
        );
    }
    test_field__p();
    fn test_field__r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_r)
            )
        );
    }
    test_field__r();
    fn test_field__w() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_w)
            )
        );
    }
    test_field__w();
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_file)
            )
        );
    }
    test_field__file();
    fn test_field__bf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_bf)
            )
        );
    }
    test_field__bf();
    fn test_field__lbfsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lbfsize)
            )
        );
    }
    test_field__lbfsize();
    fn test_field__cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_cookie)
            )
        );
    }
    test_field__cookie();
    fn test_field__close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_close)
            )
        );
    }
    test_field__close();
    fn test_field__read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_read)
            )
        );
    }
    test_field__read();
    fn test_field__seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_seek)
            )
        );
    }
    test_field__seek();
    fn test_field__write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_write)
            )
        );
    }
    test_field__write();
    fn test_field__ub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ub)
            )
        );
    }
    test_field__ub();
    fn test_field__extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_extra)
            )
        );
    }
    test_field__extra();
    fn test_field__ur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ur)
            )
        );
    }
    test_field__ur();
    fn test_field__ubuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_ubuf)
            )
        );
    }
    test_field__ubuf();
    fn test_field__nbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize
            },
            119usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_nbuf)
            )
        );
    }
    test_field__nbuf();
    fn test_field__lb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_lb)
            )
        );
    }
    test_field__lb();
    fn test_field__blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_blksize)
            )
        );
    }
    test_field__blksize();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sFILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__sFILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
    fn test_field___fsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__fsr)
            )
        );
    }
    test_field___fsr();
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    fn test_field___far() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__far)
            )
        );
    }
    test_field___far();
    fn test_field___esr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__esr)
            )
        );
    }
    test_field___esr();
    fn test_field___exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_exception_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_exception_state64),
                "::",
                stringify!(__exception)
            )
        );
    }
    test_field___exception();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    fn test_field___x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__x)
            )
        );
    }
    test_field___x();
    fn test_field___fp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__fp)
            )
        );
    }
    test_field___fp();
    fn test_field___lr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__lr)
            )
        );
    }
    test_field___lr();
    fn test_field___sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__sp)
            )
        );
    }
    test_field___sp();
    fn test_field___pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pc)
            )
        );
    }
    test_field___pc();
    fn test_field___cpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__cpsr)
            )
        );
    }
    test_field___cpsr();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_thread_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_thread_state64),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    fn test_field___r() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__r)
            )
        );
    }
    test_field___r();
    fn test_field___fpscr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_vfp_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_vfp_state),
                "::",
                stringify!(__fpscr)
            )
        );
    }
    test_field___fpscr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            516usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state64),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    fn test_field___v() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__v)
            )
        );
    }
    test_field___v();
    fn test_field___fpsr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpsr)
            )
        );
    }
    test_field___fpsr();
    fn test_field___fpcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_neon_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize
            },
            260usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_neon_state),
                "::",
                stringify!(__fpcr)
            )
        );
    }
    test_field___fpcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    fn test_field___pagein_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_pagein_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_pagein_state),
                "::",
                stringify!(__pagein_error)
            )
        );
    }
    test_field___pagein_error();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__arm_legacy_debug_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__arm_legacy_debug_state),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state32),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    fn test_field___bvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bvr)
            )
        );
    }
    test_field___bvr();
    fn test_field___bcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__bcr)
            )
        );
    }
    test_field___bcr();
    fn test_field___wvr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wvr)
            )
        );
    }
    test_field___wvr();
    fn test_field___wcr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__wcr)
            )
        );
    }
    test_field___wcr();
    fn test_field___mdscr_el1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_debug_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_debug_state64),
                "::",
                stringify!(__mdscr_el1)
            )
        );
    }
    test_field___mdscr_el1();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    fn test_field___ctrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_arm_cpmu_state64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_arm_cpmu_state64),
                "::",
                stringify!(__ctrs)
            )
        );
    }
    test_field___ctrs();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___fs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext32),
                "::",
                stringify!(__fs)
            )
        );
    }
    test_field___fs();
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    fn test_field___es() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__es)
            )
        );
    }
    test_field___es();
    fn test_field___ss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ss)
            )
        );
    }
    test_field___ss();
    fn test_field___ns() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_mcontext64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_mcontext64),
                "::",
                stringify!(__ns)
            )
        );
    }
    test_field___ns();
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_size)
            )
        );
    }
    test_field_ss_size();
    fn test_field_ss_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_sigaltstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_sigaltstack),
                "::",
                stringify!(ss_flags)
            )
        );
    }
    test_field_ss_flags();
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    fn test_field_uc_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_onstack)
            )
        );
    }
    test_field_uc_onstack();
    fn test_field_uc_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_sigmask)
            )
        );
    }
    test_field_uc_sigmask();
    fn test_field_uc_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_stack)
            )
        );
    }
    test_field_uc_stack();
    fn test_field_uc_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_link)
            )
        );
    }
    test_field_uc_link();
    fn test_field_uc_mcsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcsize)
            )
        );
    }
    test_field_uc_mcsize();
    fn test_field_uc_mcontext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__darwin_ucontext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__darwin_ucontext),
                "::",
                stringify!(uc_mcontext)
            )
        );
    }
    test_field_uc_mcontext();
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    fn test_field_sival_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_int)
            )
        );
    }
    test_field_sival_int();
    fn test_field_sival_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigval),
                "::",
                stringify!(sival_ptr)
            )
        );
    }
    test_field_sival_ptr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    fn test_field_sigev_notify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify)
            )
        );
    }
    test_field_sigev_notify();
    fn test_field_sigev_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_signo)
            )
        );
    }
    test_field_sigev_signo();
    fn test_field_sigev_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_value)
            )
        );
    }
    test_field_sigev_value();
    fn test_field_sigev_notify_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_function)
            )
        );
    }
    test_field_sigev_notify_function();
    fn test_field_sigev_notify_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sigevent),
                "::",
                stringify!(sigev_notify_attributes)
            )
        );
    }
    test_field_sigev_notify_attributes();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    fn test_field_si_signo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_signo)
            )
        );
    }
    test_field_si_signo();
    fn test_field_si_errno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_errno)
            )
        );
    }
    test_field_si_errno();
    fn test_field_si_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_code)
            )
        );
    }
    test_field_si_code();
    fn test_field_si_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_pid)
            )
        );
    }
    test_field_si_pid();
    fn test_field_si_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_uid)
            )
        );
    }
    test_field_si_uid();
    fn test_field_si_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_status)
            )
        );
    }
    test_field_si_status();
    fn test_field_si_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_addr)
            )
        );
    }
    test_field_si_addr();
    fn test_field_si_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_value)
            )
        );
    }
    test_field_si_value();
    fn test_field_si_band() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(si_band)
            )
        );
    }
    test_field_si_band();
    fn test_field___pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__siginfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(__siginfo),
                "::",
                stringify!(__pad)
            )
        );
    }
    test_field___pad();
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    fn test_field___sa_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_handler)
            )
        );
    }
    test_field___sa_handler();
    fn test_field___sa_sigaction() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction_u>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction_u),
                "::",
                stringify!(__sa_sigaction)
            )
        );
    }
    test_field___sa_sigaction();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_tramp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_tramp)
            )
        );
    }
    test_field_sa_tramp();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    fn test_field___sigaction_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(__sigaction_u)
            )
        );
    }
    test_field___sigaction_u();
    fn test_field_sa_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_mask)
            )
        );
    }
    test_field_sa_mask();
    fn test_field_sa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigaction>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigaction),
                "::",
                stringify!(sa_flags)
            )
        );
    }
    test_field_sa_flags();
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    fn test_field_sv_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_handler)
            )
        );
    }
    test_field_sv_handler();
    fn test_field_sv_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_mask)
            )
        );
    }
    test_field_sv_mask();
    fn test_field_sv_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigvec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(sigvec),
                "::",
                stringify!(sv_flags)
            )
        );
    }
    test_field_sv_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    fn test_field_ss_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_sp)
            )
        );
    }
    test_field_ss_sp();
    fn test_field_ss_onstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sigstack>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sigstack),
                "::",
                stringify!(ss_onstack)
            )
        );
    }
    test_field_ss_onstack();
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    fn test_field_ru_utime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_utime)
            )
        );
    }
    test_field_ru_utime();
    fn test_field_ru_stime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_stime)
            )
        );
    }
    test_field_ru_stime();
    fn test_field_ru_maxrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_maxrss)
            )
        );
    }
    test_field_ru_maxrss();
    fn test_field_ru_ixrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_ixrss)
            )
        );
    }
    test_field_ru_ixrss();
    fn test_field_ru_idrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_idrss)
            )
        );
    }
    test_field_ru_idrss();
    fn test_field_ru_isrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_isrss)
            )
        );
    }
    test_field_ru_isrss();
    fn test_field_ru_minflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_minflt)
            )
        );
    }
    test_field_ru_minflt();
    fn test_field_ru_majflt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_majflt)
            )
        );
    }
    test_field_ru_majflt();
    fn test_field_ru_nswap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nswap)
            )
        );
    }
    test_field_ru_nswap();
    fn test_field_ru_inblock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_inblock)
            )
        );
    }
    test_field_ru_inblock();
    fn test_field_ru_oublock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_oublock)
            )
        );
    }
    test_field_ru_oublock();
    fn test_field_ru_msgsnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgsnd)
            )
        );
    }
    test_field_ru_msgsnd();
    fn test_field_ru_msgrcv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_msgrcv)
            )
        );
    }
    test_field_ru_msgrcv();
    fn test_field_ru_nsignals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nsignals)
            )
        );
    }
    test_field_ru_nsignals();
    fn test_field_ru_nvcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nvcsw)
            )
        );
    }
    test_field_ru_nvcsw();
    fn test_field_ru_nivcsw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage),
                "::",
                stringify!(ru_nivcsw)
            )
        );
    }
    test_field_ru_nivcsw();
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v0),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v1),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v2),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v3),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v4>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v4),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
    fn test_field_ri_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v5>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v5),
                "::",
                stringify!(ri_flags)
            )
        );
    }
    test_field_ri_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    fn test_field_ri_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_uuid)
            )
        );
    }
    test_field_ri_uuid();
    fn test_field_ri_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_user_time)
            )
        );
    }
    test_field_ri_user_time();
    fn test_field_ri_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_system_time)
            )
        );
    }
    test_field_ri_system_time();
    fn test_field_ri_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_pkg_idle_wkups();
    fn test_field_ri_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_interrupt_wkups)
            )
        );
    }
    test_field_ri_interrupt_wkups();
    fn test_field_ri_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_pageins)
            )
        );
    }
    test_field_ri_pageins();
    fn test_field_ri_wired_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_wired_size)
            )
        );
    }
    test_field_ri_wired_size();
    fn test_field_ri_resident_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_resident_size)
            )
        );
    }
    test_field_ri_resident_size();
    fn test_field_ri_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_phys_footprint)
            )
        );
    }
    test_field_ri_phys_footprint();
    fn test_field_ri_proc_start_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_proc_start_abstime)
            )
        );
    }
    test_field_ri_proc_start_abstime();
    fn test_field_ri_proc_exit_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_proc_exit_abstime)
            )
        );
    }
    test_field_ri_proc_exit_abstime();
    fn test_field_ri_child_user_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_user_time)
            )
        );
    }
    test_field_ri_child_user_time();
    fn test_field_ri_child_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_system_time)
            )
        );
    }
    test_field_ri_child_system_time();
    fn test_field_ri_child_pkg_idle_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_pkg_idle_wkups)
            )
        );
    }
    test_field_ri_child_pkg_idle_wkups();
    fn test_field_ri_child_interrupt_wkups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_interrupt_wkups)
            )
        );
    }
    test_field_ri_child_interrupt_wkups();
    fn test_field_ri_child_pageins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_pageins)
            )
        );
    }
    test_field_ri_child_pageins();
    fn test_field_ri_child_elapsed_abstime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_child_elapsed_abstime)
            )
        );
    }
    test_field_ri_child_elapsed_abstime();
    fn test_field_ri_diskio_bytesread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_diskio_bytesread)
            )
        );
    }
    test_field_ri_diskio_bytesread();
    fn test_field_ri_diskio_byteswritten() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_diskio_byteswritten)
            )
        );
    }
    test_field_ri_diskio_byteswritten();
    fn test_field_ri_cpu_time_qos_default() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_default)
            )
        );
    }
    test_field_ri_cpu_time_qos_default();
    fn test_field_ri_cpu_time_qos_maintenance() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_maintenance)
            )
        );
    }
    test_field_ri_cpu_time_qos_maintenance();
    fn test_field_ri_cpu_time_qos_background() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_background)
            )
        );
    }
    test_field_ri_cpu_time_qos_background();
    fn test_field_ri_cpu_time_qos_utility() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_utility)
            )
        );
    }
    test_field_ri_cpu_time_qos_utility();
    fn test_field_ri_cpu_time_qos_legacy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_legacy)
            )
        );
    }
    test_field_ri_cpu_time_qos_legacy();
    fn test_field_ri_cpu_time_qos_user_initiated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_user_initiated)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_initiated();
    fn test_field_ri_cpu_time_qos_user_interactive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize
                    - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cpu_time_qos_user_interactive)
            )
        );
    }
    test_field_ri_cpu_time_qos_user_interactive();
    fn test_field_ri_billed_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_billed_system_time)
            )
        );
    }
    test_field_ri_billed_system_time();
    fn test_field_ri_serviced_system_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_serviced_system_time)
            )
        );
    }
    test_field_ri_serviced_system_time();
    fn test_field_ri_logical_writes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_logical_writes)
            )
        );
    }
    test_field_ri_logical_writes();
    fn test_field_ri_lifetime_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_lifetime_max_phys_footprint)
            )
        );
    }
    test_field_ri_lifetime_max_phys_footprint();
    fn test_field_ri_instructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_instructions)
            )
        );
    }
    test_field_ri_instructions();
    fn test_field_ri_cycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_cycles)
            )
        );
    }
    test_field_ri_cycles();
    fn test_field_ri_billed_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_billed_energy)
            )
        );
    }
    test_field_ri_billed_energy();
    fn test_field_ri_serviced_energy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_serviced_energy)
            )
        );
    }
    test_field_ri_serviced_energy();
    fn test_field_ri_interval_max_phys_footprint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_interval_max_phys_footprint)
            )
        );
    }
    test_field_ri_interval_max_phys_footprint();
    fn test_field_ri_runnable_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_runnable_time)
            )
        );
    }
    test_field_ri_runnable_time();
    fn test_field_ri_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_flags)
            )
        );
    }
    test_field_ri_flags();
    fn test_field_ri_user_ptime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_user_ptime)
            )
        );
    }
    test_field_ri_user_ptime();
    fn test_field_ri_system_ptime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_system_ptime)
            )
        );
    }
    test_field_ri_system_ptime();
    fn test_field_ri_pinstructions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_pinstructions)
            )
        );
    }
    test_field_ri_pinstructions();
    fn test_field_ri_pcycles() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_pcycles)
            )
        );
    }
    test_field_ri_pcycles();
    fn test_field_ri_energy_nj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_energy_nj)
            )
        );
    }
    test_field_ri_energy_nj();
    fn test_field_ri_penergy_nj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_penergy_nj)
            )
        );
    }
    test_field_ri_penergy_nj();
    fn test_field_ri_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rusage_info_v6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(rusage_info_v6),
                "::",
                stringify!(ri_reserved)
            )
        );
    }
    test_field_ri_reserved();
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    fn test_field_rlim_cur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_cur)
            )
        );
    }
    test_field_rlim_cur();
    fn test_field_rlim_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rlimit>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rlimit),
                "::",
                stringify!(rlim_max)
            )
        );
    }
    test_field_rlim_max();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    fn test_field_wm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_flags)
            )
        );
    }
    test_field_wm_flags();
    fn test_field_wm_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<proc_rlimit_control_wakeupmon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(proc_rlimit_control_wakeupmon),
                "::",
                stringify!(wm_rate)
            )
        );
    }
    test_field_wm_rate();
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU16>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU16),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU32),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_OSUnalignedU64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_OSUnalignedU64),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    fn test_field_w_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(wait),
                "::",
                stringify!(w_status)
            )
        );
    }
    test_field_w_status();
    fn test_field_w_T() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
        );
    }
    test_field_w_T();
    fn test_field_w_S() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<wait>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize
            },
            0usize,
            concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
        );
    }
    test_field_w_S();
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<div_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(div_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    fn test_field_quot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(quot)
            )
        );
    }
    test_field_quot();
    fn test_field_rem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<lldiv_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(lldiv_t),
                "::",
                stringify!(rem)
            )
        );
    }
    test_field_rem();
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: size_t,
        __little: *const ::std::os::raw::c_void,
        __little_len: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: size_t,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ssize_t,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_nsec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timespec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timespec),
                "::",
                stringify!(tv_nsec)
            )
        );
    }
    test_field_tv_nsec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
    fn test_field_tm_gmtoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_gmtoff)
            )
        );
    }
    test_field_tm_gmtoff();
    fn test_field_tm_zone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tm>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tm),
                "::",
                stringify!(tm_zone)
            )
        );
    }
    test_field_tm_zone();
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    fn test_field_fds_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fd_set>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fd_set),
                "::",
                stringify!(fds_bits)
            )
        );
    }
    test_field_fds_bits();
}
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    fn test_field_iov_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_base)
            )
        );
    }
    test_field_iov_base();
    fn test_field_iov_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iovec>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iovec),
                "::",
                stringify!(iov_len)
            )
        );
    }
    test_field_iov_len();
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    fn test_field_sae_srcif() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcif) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcif)
            )
        );
    }
    test_field_sae_srcif();
    fn test_field_sae_srcaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcaddr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcaddr)
            )
        );
    }
    test_field_sae_srcaddr();
    fn test_field_sae_srcaddrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_srcaddrlen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_srcaddrlen)
            )
        );
    }
    test_field_sae_srcaddrlen();
    fn test_field_sae_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_dstaddr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_dstaddr)
            )
        );
    }
    test_field_sae_dstaddr();
    fn test_field_sae_dstaddrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sa_endpoints>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sae_dstaddrlen) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(sa_endpoints),
                "::",
                stringify!(sae_dstaddrlen)
            )
        );
    }
    test_field_sae_dstaddrlen();
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    fn test_field_l_onoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_onoff) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_onoff)
            )
        );
    }
    test_field_l_onoff();
    fn test_field_l_linger() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<linger>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_linger) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(linger),
                "::",
                stringify!(l_linger)
            )
        );
    }
    test_field_l_linger();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    fn test_field_npx_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<so_np_extensions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npx_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(so_np_extensions),
                "::",
                stringify!(npx_flags)
            )
        );
    }
    test_field_npx_flags();
    fn test_field_npx_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<so_np_extensions>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npx_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(so_np_extensions),
                "::",
                stringify!(npx_mask)
            )
        );
    }
    test_field_npx_mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    fn test_field_sa_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_len)
            )
        );
    }
    test_field_sa_len();
    fn test_field_sa_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_family)
            )
        );
    }
    test_field_sa_family();
    fn test_field_sa_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_data) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr),
                "::",
                stringify!(sa_data)
            )
        );
    }
    test_field_sa_data();
}
pub type sockaddr_ref_t = *mut sockaddr;
pub type sockaddr_ref_ref_t = *mut *mut sockaddr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sockaddr_header {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
}
#[test]
fn bindgen_test_layout___sockaddr_header() {
    assert_eq!(
        ::std::mem::size_of::<__sockaddr_header>(),
        2usize,
        concat!("Size of: ", stringify!(__sockaddr_header))
    );
    assert_eq!(
        ::std::mem::align_of::<__sockaddr_header>(),
        1usize,
        concat!("Alignment of ", stringify!(__sockaddr_header))
    );
    fn test_field_sa_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sockaddr_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sockaddr_header),
                "::",
                stringify!(sa_len)
            )
        );
    }
    test_field_sa_len();
    fn test_field_sa_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sockaddr_header>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(__sockaddr_header),
                "::",
                stringify!(sa_family)
            )
        );
    }
    test_field_sa_family();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    fn test_field_sp_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockproto>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp_family) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockproto),
                "::",
                stringify!(sp_family)
            )
        );
    }
    test_field_sp_family();
    fn test_field_sp_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockproto>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp_protocol) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockproto),
                "::",
                stringify!(sp_protocol)
            )
        );
    }
    test_field_sp_protocol();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    fn test_field_ss_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_len)
            )
        );
    }
    test_field_ss_len();
    fn test_field_ss_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ss_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(ss_family)
            )
        );
    }
    test_field_ss_family();
    fn test_field___ss_pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_pad1) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_pad1)
            )
        );
    }
    test_field___ss_pad1();
    fn test_field___ss_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_align) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_align)
            )
        );
    }
    test_field___ss_align();
    fn test_field___ss_pad2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__ss_pad2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_storage),
                "::",
                stringify!(__ss_pad2)
            )
        );
    }
    test_field___ss_pad2();
}
pub type sockaddr_storage_ref_t = *mut sockaddr_storage;
pub type sockaddr_storage_ref_ref_t = *mut *mut sockaddr_storage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    fn test_field_msg_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_name)
            )
        );
    }
    test_field_msg_name();
    fn test_field_msg_namelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_namelen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_namelen)
            )
        );
    }
    test_field_msg_namelen();
    fn test_field_msg_iov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_iov) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iov)
            )
        );
    }
    test_field_msg_iov();
    fn test_field_msg_iovlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_iovlen) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_iovlen)
            )
        );
    }
    test_field_msg_iovlen();
    fn test_field_msg_control() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_control) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_control)
            )
        );
    }
    test_field_msg_control();
    fn test_field_msg_controllen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_controllen) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_controllen)
            )
        );
    }
    test_field_msg_controllen();
    fn test_field_msg_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msg_flags) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(msghdr),
                "::",
                stringify!(msg_flags)
            )
        );
    }
    test_field_msg_flags();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    fn test_field_cmsg_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_len)
            )
        );
    }
    test_field_cmsg_len();
    fn test_field_cmsg_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_level) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_level)
            )
        );
    }
    test_field_cmsg_level();
    fn test_field_cmsg_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<cmsghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmsg_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(cmsghdr),
                "::",
                stringify!(cmsg_type)
            )
        );
    }
    test_field_cmsg_type();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    fn test_field_headers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).headers) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(headers)
            )
        );
    }
    test_field_headers();
    fn test_field_hdr_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hdr_cnt) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(hdr_cnt)
            )
        );
    }
    test_field_hdr_cnt();
    fn test_field_trailers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trailers) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(trailers)
            )
        );
    }
    test_field_trailers();
    fn test_field_trl_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sf_hdtr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trl_cnt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sf_hdtr),
                "::",
                stringify!(trl_cnt)
            )
        );
    }
    test_field_trl_cnt();
}
extern "C" {
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut size_t,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    fn test_field_s_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_addr),
                "::",
                stringify!(s_addr)
            )
        );
    }
    test_field_s_addr();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    fn test_field_sin_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_len)
            )
        );
    }
    test_field_sin_len();
    fn test_field_sin_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_family)
            )
        );
    }
    test_field_sin_family();
    fn test_field_sin_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_port)
            )
        );
    }
    test_field_sin_port();
    fn test_field_sin_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_addr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_addr)
            )
        );
    }
    test_field_sin_addr();
    fn test_field_sin_zero() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin_zero) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in),
                "::",
                stringify!(sin_zero)
            )
        );
    }
    test_field_sin_zero();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    fn test_field_ip_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_dst) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_opts),
                "::",
                stringify!(ip_dst)
            )
        );
    }
    test_field_ip_dst();
    fn test_field_ip_opts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_opts) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_opts),
                "::",
                stringify!(ip_opts)
            )
        );
    }
    test_field_ip_opts();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq),
                "::",
                stringify!(imr_interface)
            )
        );
    }
    test_field_imr_interface();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_address) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_address)
            )
        );
    }
    test_field_imr_address();
    fn test_field_imr_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreqn>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_ifindex) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreqn),
                "::",
                stringify!(imr_ifindex)
            )
        );
    }
    test_field_imr_ifindex();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    fn test_field_imr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_multiaddr)
            )
        );
    }
    test_field_imr_multiaddr();
    fn test_field_imr_sourceaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_sourceaddr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_sourceaddr)
            )
        );
    }
    test_field_imr_sourceaddr();
    fn test_field_imr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip_mreq_source>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).imr_interface) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ip_mreq_source),
                "::",
                stringify!(imr_interface)
            )
        );
    }
    test_field_imr_interface();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
    fn test_field_gr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gr_interface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(group_req),
                "::",
                stringify!(gr_interface)
            )
        );
    }
    test_field_gr_interface();
    fn test_field_gr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gr_group) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(group_req),
                "::",
                stringify!(gr_group)
            )
        );
    }
    test_field_gr_group();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
    fn test_field_gsr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_interface) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_interface)
            )
        );
    }
    test_field_gsr_interface();
    fn test_field_gsr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_group) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_group)
            )
        );
    }
    test_field_gsr_group();
    fn test_field_gsr_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<group_source_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gsr_source) as usize - ptr as usize
            },
            132usize,
            concat!(
                "Offset of field: ",
                stringify!(group_source_req),
                "::",
                stringify!(gsr_source)
            )
        );
    }
    test_field_gsr_source();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub __msfr_align: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
    fn test_field_msfr_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_ifindex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_ifindex)
            )
        );
    }
    test_field_msfr_ifindex();
    fn test_field_msfr_fmode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_fmode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_fmode)
            )
        );
    }
    test_field_msfr_fmode();
    fn test_field_msfr_nsrcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_nsrcs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_nsrcs)
            )
        );
    }
    test_field_msfr_nsrcs();
    fn test_field___msfr_align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__msfr_align) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(__msfr_align)
            )
        );
    }
    test_field___msfr_align();
    fn test_field_msfr_group() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_group) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_group)
            )
        );
    }
    test_field_msfr_group();
    fn test_field_msfr_srcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__msfilterreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msfr_srcs) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(__msfilterreq),
                "::",
                stringify!(msfr_srcs)
            )
        );
    }
    test_field_msfr_srcs();
}
extern "C" {
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    fn test_field_ipi_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_ifindex) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_ifindex)
            )
        );
    }
    test_field_ipi_ifindex();
    fn test_field_ipi_spec_dst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_spec_dst) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_spec_dst)
            )
        );
    }
    test_field_ipi_spec_dst();
    fn test_field_ipi_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(in_pktinfo),
                "::",
                stringify!(ipi_addr)
            )
        );
    }
    test_field_ipi_addr();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    fn test_field___u6_addr8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr8) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr8)
            )
        );
    }
    test_field___u6_addr8();
    fn test_field___u6_addr16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr16) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr16)
            )
        );
    }
    test_field___u6_addr16();
    fn test_field___u6_addr32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr__bindgen_ty_1),
                "::",
                stringify!(__u6_addr32)
            )
        );
    }
    test_field___u6_addr32();
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    fn test_field___u6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__u6_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_addr),
                "::",
                stringify!(__u6_addr)
            )
        );
    }
    test_field___u6_addr();
}
pub type in6_addr_t = in6_addr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    fn test_field_sin6_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_len)
            )
        );
    }
    test_field_sin6_len();
    fn test_field_sin6_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_family)
            )
        );
    }
    test_field_sin6_family();
    fn test_field_sin6_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_port) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_port)
            )
        );
    }
    test_field_sin6_port();
    fn test_field_sin6_flowinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_flowinfo) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_flowinfo)
            )
        );
    }
    test_field_sin6_flowinfo();
    fn test_field_sin6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_addr)
            )
        );
    }
    test_field_sin6_addr();
    fn test_field_sin6_scope_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_in6>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sin6_scope_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_in6),
                "::",
                stringify!(sin6_scope_id)
            )
        );
    }
    test_field_sin6_scope_id();
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    fn test_field_ipv6mr_multiaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipv6mr_multiaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_multiaddr)
            )
        );
    }
    test_field_ipv6mr_multiaddr();
    fn test_field_ipv6mr_interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ipv6_mreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipv6mr_interface) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ipv6_mreq),
                "::",
                stringify!(ipv6mr_interface)
            )
        );
    }
    test_field_ipv6mr_interface();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    fn test_field_ipi6_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi6_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_addr)
            )
        );
    }
    test_field_ipi6_addr();
    fn test_field_ipi6_ifindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<in6_pktinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipi6_ifindex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(in6_pktinfo),
                "::",
                stringify!(ipi6_ifindex)
            )
        );
    }
    test_field_ipi6_ifindex();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    fn test_field_ip6m_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip6_mtuinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip6m_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ip6_mtuinfo),
                "::",
                stringify!(ip6m_addr)
            )
        );
    }
    test_field_ip6m_addr();
    fn test_field_ip6m_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ip6_mtuinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip6m_mtu) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ip6_mtuinfo),
                "::",
                stringify!(ip6m_mtu)
            )
        );
    }
    test_field_ip6m_mtu();
}
extern "C" {
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> size_t;
}
extern "C" {
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_addr(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_ntoa(arg1: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ascii2addr(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn addr2ascii(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_aton(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_lnaof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_makeaddr(arg1: in_addr_t, arg2: in_addr_t) -> in_addr;
}
extern "C" {
    pub fn inet_netof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    pub fn inet_network(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    pub fn inet_net_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: __darwin_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_neta(
        arg1: in_addr_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_nsap_addr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn inet_nsap_ntoa(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    fn test_field_d_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_ino)
            )
        );
    }
    test_field_d_ino();
    fn test_field_d_seekoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_seekoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_seekoff)
            )
        );
    }
    test_field_d_seekoff();
    fn test_field_d_reclen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_reclen)
            )
        );
    }
    test_field_d_reclen();
    fn test_field_d_namlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_namlen) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_namlen)
            )
        );
    }
    test_field_d_namlen();
    fn test_field_d_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_type)
            )
        );
    }
    test_field_d_type();
    fn test_field_d_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(dirent),
                "::",
                stringify!(d_name)
            )
        );
    }
    test_field_d_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __padding: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    fn test_field___dd_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_fd)
            )
        );
    }
    test_field___dd_fd();
    fn test_field___dd_loc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_loc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_loc)
            )
        );
    }
    test_field___dd_loc();
    fn test_field___dd_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_size)
            )
        );
    }
    test_field___dd_size();
    fn test_field___dd_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_buf) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_buf)
            )
        );
    }
    test_field___dd_buf();
    fn test_field___dd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_len) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_len)
            )
        );
    }
    test_field___dd_len();
    fn test_field___dd_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_seek) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_seek)
            )
        );
    }
    test_field___dd_seek();
    fn test_field___padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__padding) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__padding)
            )
        );
    }
    test_field___padding();
    fn test_field___dd_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_flags)
            )
        );
    }
    test_field___dd_flags();
    fn test_field___dd_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_lock) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_lock)
            )
        );
    }
    test_field___dd_lock();
    fn test_field___dd_td() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<DIR>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__dd_td) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(DIR),
                "::",
                stringify!(__dd_td)
            )
        );
    }
    test_field___dd_td();
}
extern "C" {
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dirfd(dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flock {
    pub l_start: off_t,
    pub l_len: off_t,
    pub l_pid: pid_t,
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(
        ::std::mem::size_of::<flock>(),
        24usize,
        concat!("Size of: ", stringify!(flock))
    );
    assert_eq!(
        ::std::mem::align_of::<flock>(),
        8usize,
        concat!("Alignment of ", stringify!(flock))
    );
    fn test_field_l_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_start)
            )
        );
    }
    test_field_l_start();
    fn test_field_l_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_len) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_len)
            )
        );
    }
    test_field_l_len();
    fn test_field_l_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_pid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_pid)
            )
        );
    }
    test_field_l_pid();
    fn test_field_l_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_type) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_type)
            )
        );
    }
    test_field_l_type();
    fn test_field_l_whence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flock>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l_whence) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(flock),
                "::",
                stringify!(l_whence)
            )
        );
    }
    test_field_l_whence();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct flocktimeout {
    pub fl: flock,
    pub timeout: timespec,
}
#[test]
fn bindgen_test_layout_flocktimeout() {
    assert_eq!(
        ::std::mem::size_of::<flocktimeout>(),
        40usize,
        concat!("Size of: ", stringify!(flocktimeout))
    );
    assert_eq!(
        ::std::mem::align_of::<flocktimeout>(),
        8usize,
        concat!("Alignment of ", stringify!(flocktimeout))
    );
    fn test_field_fl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flocktimeout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(flocktimeout),
                "::",
                stringify!(fl)
            )
        );
    }
    test_field_fl();
    fn test_field_timeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<flocktimeout>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(flocktimeout),
                "::",
                stringify!(timeout)
            )
        );
    }
    test_field_timeout();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct radvisory {
    pub ra_offset: off_t,
    pub ra_count: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_radvisory() {
    assert_eq!(
        ::std::mem::size_of::<radvisory>(),
        16usize,
        concat!("Size of: ", stringify!(radvisory))
    );
    assert_eq!(
        ::std::mem::align_of::<radvisory>(),
        8usize,
        concat!("Alignment of ", stringify!(radvisory))
    );
    fn test_field_ra_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<radvisory>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ra_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(radvisory),
                "::",
                stringify!(ra_offset)
            )
        );
    }
    test_field_ra_offset();
    fn test_field_ra_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<radvisory>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ra_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(radvisory),
                "::",
                stringify!(ra_count)
            )
        );
    }
    test_field_ra_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsignatures {
    pub fs_file_start: off_t,
    pub fs_blob_start: *mut ::std::os::raw::c_void,
    pub fs_blob_size: size_t,
    pub fs_fsignatures_size: size_t,
    pub fs_cdhash: [::std::os::raw::c_char; 20usize],
    pub fs_hash_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsignatures() {
    assert_eq!(
        ::std::mem::size_of::<fsignatures>(),
        56usize,
        concat!("Size of: ", stringify!(fsignatures))
    );
    assert_eq!(
        ::std::mem::align_of::<fsignatures>(),
        8usize,
        concat!("Alignment of ", stringify!(fsignatures))
    );
    fn test_field_fs_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_file_start)
            )
        );
    }
    test_field_fs_file_start();
    fn test_field_fs_blob_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_blob_start)
            )
        );
    }
    test_field_fs_blob_start();
    fn test_field_fs_blob_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_blob_size)
            )
        );
    }
    test_field_fs_blob_size();
    fn test_field_fs_fsignatures_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_fsignatures_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_fsignatures_size)
            )
        );
    }
    test_field_fs_fsignatures_size();
    fn test_field_fs_cdhash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_cdhash) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_cdhash)
            )
        );
    }
    test_field_fs_cdhash();
    fn test_field_fs_hash_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsignatures>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_hash_type) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(fsignatures),
                "::",
                stringify!(fs_hash_type)
            )
        );
    }
    test_field_fs_hash_type();
}
pub type fsignatures_t = fsignatures;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fsupplement {
    pub fs_file_start: off_t,
    pub fs_blob_start: off_t,
    pub fs_blob_size: size_t,
    pub fs_orig_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fsupplement() {
    assert_eq!(
        ::std::mem::size_of::<fsupplement>(),
        32usize,
        concat!("Size of: ", stringify!(fsupplement))
    );
    assert_eq!(
        ::std::mem::align_of::<fsupplement>(),
        8usize,
        concat!("Alignment of ", stringify!(fsupplement))
    );
    fn test_field_fs_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_file_start)
            )
        );
    }
    test_field_fs_file_start();
    fn test_field_fs_blob_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_blob_start)
            )
        );
    }
    test_field_fs_blob_start();
    fn test_field_fs_blob_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_blob_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_blob_size)
            )
        );
    }
    test_field_fs_blob_size();
    fn test_field_fs_orig_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fsupplement>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fs_orig_fd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fsupplement),
                "::",
                stringify!(fs_orig_fd)
            )
        );
    }
    test_field_fs_orig_fd();
}
pub type fsupplement_t = fsupplement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fchecklv {
    pub lv_file_start: off_t,
    pub lv_error_message_size: size_t,
    pub lv_error_message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_fchecklv() {
    assert_eq!(
        ::std::mem::size_of::<fchecklv>(),
        24usize,
        concat!("Size of: ", stringify!(fchecklv))
    );
    assert_eq!(
        ::std::mem::align_of::<fchecklv>(),
        8usize,
        concat!("Alignment of ", stringify!(fchecklv))
    );
    fn test_field_lv_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_file_start)
            )
        );
    }
    test_field_lv_file_start();
    fn test_field_lv_error_message_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_error_message_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_error_message_size)
            )
        );
    }
    test_field_lv_error_message_size();
    fn test_field_lv_error_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fchecklv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lv_error_message) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fchecklv),
                "::",
                stringify!(lv_error_message)
            )
        );
    }
    test_field_lv_error_message();
}
pub type fchecklv_t = fchecklv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fgetsigsinfo {
    pub fg_file_start: off_t,
    pub fg_info_request: ::std::os::raw::c_int,
    pub fg_sig_is_platform: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_fgetsigsinfo() {
    assert_eq!(
        ::std::mem::size_of::<fgetsigsinfo>(),
        16usize,
        concat!("Size of: ", stringify!(fgetsigsinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<fgetsigsinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(fgetsigsinfo))
    );
    fn test_field_fg_file_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_file_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_file_start)
            )
        );
    }
    test_field_fg_file_start();
    fn test_field_fg_info_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_info_request) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_info_request)
            )
        );
    }
    test_field_fg_info_request();
    fn test_field_fg_sig_is_platform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fgetsigsinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fg_sig_is_platform) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(fgetsigsinfo),
                "::",
                stringify!(fg_sig_is_platform)
            )
        );
    }
    test_field_fg_sig_is_platform();
}
pub type fgetsigsinfo_t = fgetsigsinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fstore {
    pub fst_flags: ::std::os::raw::c_uint,
    pub fst_posmode: ::std::os::raw::c_int,
    pub fst_offset: off_t,
    pub fst_length: off_t,
    pub fst_bytesalloc: off_t,
}
#[test]
fn bindgen_test_layout_fstore() {
    assert_eq!(
        ::std::mem::size_of::<fstore>(),
        32usize,
        concat!("Size of: ", stringify!(fstore))
    );
    assert_eq!(
        ::std::mem::align_of::<fstore>(),
        8usize,
        concat!("Alignment of ", stringify!(fstore))
    );
    fn test_field_fst_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_flags)
            )
        );
    }
    test_field_fst_flags();
    fn test_field_fst_posmode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_posmode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_posmode)
            )
        );
    }
    test_field_fst_posmode();
    fn test_field_fst_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_offset)
            )
        );
    }
    test_field_fst_offset();
    fn test_field_fst_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_length)
            )
        );
    }
    test_field_fst_length();
    fn test_field_fst_bytesalloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fstore>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fst_bytesalloc) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(fstore),
                "::",
                stringify!(fst_bytesalloc)
            )
        );
    }
    test_field_fst_bytesalloc();
}
pub type fstore_t = fstore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fpunchhole {
    pub fp_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fp_offset: off_t,
    pub fp_length: off_t,
}
#[test]
fn bindgen_test_layout_fpunchhole() {
    assert_eq!(
        ::std::mem::size_of::<fpunchhole>(),
        24usize,
        concat!("Size of: ", stringify!(fpunchhole))
    );
    assert_eq!(
        ::std::mem::align_of::<fpunchhole>(),
        8usize,
        concat!("Alignment of ", stringify!(fpunchhole))
    );
    fn test_field_fp_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_flags)
            )
        );
    }
    test_field_fp_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_fp_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fpunchhole>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fpunchhole),
                "::",
                stringify!(fp_length)
            )
        );
    }
    test_field_fp_length();
}
pub type fpunchhole_t = fpunchhole;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ftrimactivefile {
    pub fta_offset: off_t,
    pub fta_length: off_t,
}
#[test]
fn bindgen_test_layout_ftrimactivefile() {
    assert_eq!(
        ::std::mem::size_of::<ftrimactivefile>(),
        16usize,
        concat!("Size of: ", stringify!(ftrimactivefile))
    );
    assert_eq!(
        ::std::mem::align_of::<ftrimactivefile>(),
        8usize,
        concat!("Alignment of ", stringify!(ftrimactivefile))
    );
    fn test_field_fta_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ftrimactivefile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fta_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ftrimactivefile),
                "::",
                stringify!(fta_offset)
            )
        );
    }
    test_field_fta_offset();
    fn test_field_fta_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ftrimactivefile>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fta_length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ftrimactivefile),
                "::",
                stringify!(fta_length)
            )
        );
    }
    test_field_fta_length();
}
pub type ftrimactivefile_t = ftrimactivefile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fspecread {
    pub fsr_flags: ::std::os::raw::c_uint,
    pub reserved: ::std::os::raw::c_uint,
    pub fsr_offset: off_t,
    pub fsr_length: off_t,
}
#[test]
fn bindgen_test_layout_fspecread() {
    assert_eq!(
        ::std::mem::size_of::<fspecread>(),
        24usize,
        concat!("Size of: ", stringify!(fspecread))
    );
    assert_eq!(
        ::std::mem::align_of::<fspecread>(),
        8usize,
        concat!("Alignment of ", stringify!(fspecread))
    );
    fn test_field_fsr_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_flags)
            )
        );
    }
    test_field_fsr_flags();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_fsr_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_offset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_offset)
            )
        );
    }
    test_field_fsr_offset();
    fn test_field_fsr_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<fspecread>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fsr_length) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(fspecread),
                "::",
                stringify!(fsr_length)
            )
        );
    }
    test_field_fsr_length();
}
pub type fspecread_t = fspecread;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct log2phys {
    pub l2p_flags: ::std::os::raw::c_uint,
    pub l2p_contigbytes: off_t,
    pub l2p_devoffset: off_t,
}
#[test]
fn bindgen_test_layout_log2phys() {
    assert_eq!(
        ::std::mem::size_of::<log2phys>(),
        20usize,
        concat!("Size of: ", stringify!(log2phys))
    );
    assert_eq!(
        ::std::mem::align_of::<log2phys>(),
        4usize,
        concat!("Alignment of ", stringify!(log2phys))
    );
    fn test_field_l2p_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_flags)
            )
        );
    }
    test_field_l2p_flags();
    fn test_field_l2p_contigbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_contigbytes) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_contigbytes)
            )
        );
    }
    test_field_l2p_contigbytes();
    fn test_field_l2p_devoffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<log2phys>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).l2p_devoffset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(log2phys),
                "::",
                stringify!(l2p_devoffset)
            )
        );
    }
    test_field_l2p_devoffset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _filesec {
    _unused: [u8; 0],
}
pub type filesec_t = *mut _filesec;
pub const filesec_property_t_FILESEC_OWNER: filesec_property_t = 1;
pub const filesec_property_t_FILESEC_GROUP: filesec_property_t = 2;
pub const filesec_property_t_FILESEC_UUID: filesec_property_t = 3;
pub const filesec_property_t_FILESEC_MODE: filesec_property_t = 4;
pub const filesec_property_t_FILESEC_ACL: filesec_property_t = 5;
pub const filesec_property_t_FILESEC_GRPUUID: filesec_property_t = 6;
pub const filesec_property_t_FILESEC_ACL_RAW: filesec_property_t = 100;
pub const filesec_property_t_FILESEC_ACL_ALLOCSIZE: filesec_property_t = 101;
pub type filesec_property_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcntl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open_dprotected_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat_dprotected_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat_authenticated_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flock(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_init() -> filesec_t;
}
extern "C" {
    pub fn filesec_dup(arg1: filesec_t) -> filesec_t;
}
extern "C" {
    pub fn filesec_free(arg1: filesec_t);
}
extern "C" {
    pub fn filesec_get_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_query_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_set_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn filesec_unset_property(
        arg1: filesec_t,
        arg2: filesec_property_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifaddrs {
    pub ifa_next: *mut ifaddrs,
    pub ifa_name: *mut ::std::os::raw::c_char,
    pub ifa_flags: ::std::os::raw::c_uint,
    pub ifa_addr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_dstaddr: *mut sockaddr,
    pub ifa_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifaddrs() {
    assert_eq!(
        ::std::mem::size_of::<ifaddrs>(),
        56usize,
        concat!("Size of: ", stringify!(ifaddrs))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaddrs>(),
        8usize,
        concat!("Alignment of ", stringify!(ifaddrs))
    );
    fn test_field_ifa_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_next)
            )
        );
    }
    test_field_ifa_next();
    fn test_field_ifa_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_name)
            )
        );
    }
    test_field_ifa_name();
    fn test_field_ifa_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_flags) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_flags)
            )
        );
    }
    test_field_ifa_flags();
    fn test_field_ifa_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_addr)
            )
        );
    }
    test_field_ifa_addr();
    fn test_field_ifa_netmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_netmask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_netmask)
            )
        );
    }
    test_field_ifa_netmask();
    fn test_field_ifa_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_dstaddr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_dstaddr)
            )
        );
    }
    test_field_ifa_dstaddr();
    fn test_field_ifa_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifa_data) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaddrs),
                "::",
                stringify!(ifa_data)
            )
        );
    }
    test_field_ifa_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifmaddrs {
    pub ifma_next: *mut ifmaddrs,
    pub ifma_name: *mut sockaddr,
    pub ifma_addr: *mut sockaddr,
    pub ifma_lladdr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_ifmaddrs() {
    assert_eq!(
        ::std::mem::size_of::<ifmaddrs>(),
        32usize,
        concat!("Size of: ", stringify!(ifmaddrs))
    );
    assert_eq!(
        ::std::mem::align_of::<ifmaddrs>(),
        8usize,
        concat!("Alignment of ", stringify!(ifmaddrs))
    );
    fn test_field_ifma_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_next)
            )
        );
    }
    test_field_ifma_next();
    fn test_field_ifma_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_name)
            )
        );
    }
    test_field_ifma_name();
    fn test_field_ifma_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_addr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_addr)
            )
        );
    }
    test_field_ifma_addr();
    fn test_field_ifma_lladdr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmaddrs>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifma_lladdr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmaddrs),
                "::",
                stringify!(ifma_lladdr)
            )
        );
    }
    test_field_ifma_lladdr();
}
extern "C" {
    pub fn getifaddrs(arg1: *mut *mut ifaddrs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeifaddrs(arg1: *mut ifaddrs);
}
extern "C" {
    pub fn getifmaddrs(arg1: *mut *mut ifmaddrs) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeifmaddrs(arg1: *mut ifmaddrs);
}
extern "C" {
    pub static mut h_errno: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(
        ::std::mem::size_of::<hostent>(),
        32usize,
        concat!("Size of: ", stringify!(hostent))
    );
    assert_eq!(
        ::std::mem::align_of::<hostent>(),
        8usize,
        concat!("Alignment of ", stringify!(hostent))
    );
    fn test_field_h_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_name)
            )
        );
    }
    test_field_h_name();
    fn test_field_h_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_aliases)
            )
        );
    }
    test_field_h_aliases();
    fn test_field_h_addrtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_addrtype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_addrtype)
            )
        );
    }
    test_field_h_addrtype();
    fn test_field_h_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_length) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_length)
            )
        );
    }
    test_field_h_length();
    fn test_field_h_addr_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<hostent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).h_addr_list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(hostent),
                "::",
                stringify!(h_addr_list)
            )
        );
    }
    test_field_h_addr_list();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(
        ::std::mem::size_of::<netent>(),
        24usize,
        concat!("Size of: ", stringify!(netent))
    );
    assert_eq!(
        ::std::mem::align_of::<netent>(),
        8usize,
        concat!("Alignment of ", stringify!(netent))
    );
    fn test_field_n_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_name)
            )
        );
    }
    test_field_n_name();
    fn test_field_n_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_aliases)
            )
        );
    }
    test_field_n_aliases();
    fn test_field_n_addrtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_addrtype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_addrtype)
            )
        );
    }
    test_field_n_addrtype();
    fn test_field_n_net() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<netent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n_net) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(netent),
                "::",
                stringify!(n_net)
            )
        );
    }
    test_field_n_net();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(
        ::std::mem::size_of::<servent>(),
        32usize,
        concat!("Size of: ", stringify!(servent))
    );
    assert_eq!(
        ::std::mem::align_of::<servent>(),
        8usize,
        concat!("Alignment of ", stringify!(servent))
    );
    fn test_field_s_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_name)
            )
        );
    }
    test_field_s_name();
    fn test_field_s_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_aliases)
            )
        );
    }
    test_field_s_aliases();
    fn test_field_s_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_port) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_port)
            )
        );
    }
    test_field_s_port();
    fn test_field_s_proto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<servent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).s_proto) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(servent),
                "::",
                stringify!(s_proto)
            )
        );
    }
    test_field_s_proto();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(
        ::std::mem::size_of::<protoent>(),
        24usize,
        concat!("Size of: ", stringify!(protoent))
    );
    assert_eq!(
        ::std::mem::align_of::<protoent>(),
        8usize,
        concat!("Alignment of ", stringify!(protoent))
    );
    fn test_field_p_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_name)
            )
        );
    }
    test_field_p_name();
    fn test_field_p_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_aliases)
            )
        );
    }
    test_field_p_aliases();
    fn test_field_p_proto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<protoent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_proto) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(protoent),
                "::",
                stringify!(p_proto)
            )
        );
    }
    test_field_p_proto();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_addr: *mut sockaddr,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<addrinfo>(),
        48usize,
        concat!("Size of: ", stringify!(addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(addrinfo))
    );
    fn test_field_ai_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_flags)
            )
        );
    }
    test_field_ai_flags();
    fn test_field_ai_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_family) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_family)
            )
        );
    }
    test_field_ai_family();
    fn test_field_ai_socktype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_socktype) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_socktype)
            )
        );
    }
    test_field_ai_socktype();
    fn test_field_ai_protocol() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_protocol) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_protocol)
            )
        );
    }
    test_field_ai_protocol();
    fn test_field_ai_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_addrlen) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addrlen)
            )
        );
    }
    test_field_ai_addrlen();
    fn test_field_ai_canonname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_canonname) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_canonname)
            )
        );
    }
    test_field_ai_canonname();
    fn test_field_ai_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_addr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_addr)
            )
        );
    }
    test_field_ai_addr();
    fn test_field_ai_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<addrinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_next) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(addrinfo),
                "::",
                stringify!(ai_next)
            )
        );
    }
    test_field_ai_next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(
        ::std::mem::size_of::<rpcent>(),
        24usize,
        concat!("Size of: ", stringify!(rpcent))
    );
    assert_eq!(
        ::std::mem::align_of::<rpcent>(),
        8usize,
        concat!("Alignment of ", stringify!(rpcent))
    );
    fn test_field_r_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_name)
            )
        );
    }
    test_field_r_name();
    fn test_field_r_aliases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_aliases) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_aliases)
            )
        );
    }
    test_field_r_aliases();
    fn test_field_r_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rpcent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r_number) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rpcent),
                "::",
                stringify!(r_number)
            )
        );
    }
    test_field_r_number();
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn freeaddrinfo(arg1: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getaddrinfo(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const addrinfo,
        arg4: *mut *mut addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(arg1: *const ::std::os::raw::c_char) -> *mut hostent;
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn getnameinfo(
        arg1: *const sockaddr,
        arg2: socklen_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
        arg5: *mut ::std::os::raw::c_char,
        arg6: socklen_t,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr(arg1: u32, arg2: ::std::os::raw::c_int) -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(arg1: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getprotobyname(arg1: *const ::std::os::raw::c_char) -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(arg1: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getservbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservbyport(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut servent;
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn sethostent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setnetent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setprotoent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn setservent(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn freehostent(arg1: *mut hostent);
}
extern "C" {
    pub fn gethostbyname2(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getipnodebyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut hostent;
}
extern "C" {
    pub fn getrpcbyname(name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn setrpcent(stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn herror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(arg1: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn innetgr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn setnetgrent(arg1: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    fn test_field_fd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(fd)
            )
        );
    }
    test_field_fd();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_revents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pollfd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(pollfd),
                "::",
                stringify!(revents)
            )
        );
    }
    test_field_revents();
}
pub type nfds_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn poll(
        arg1: *mut pollfd,
        arg2: nfds_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    fn test_field_sched_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(sched_priority)
            )
        );
    }
    test_field_sched_priority();
    fn test_field___opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sched_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(sched_param),
                "::",
                stringify!(__opaque)
            )
        );
    }
    test_field___opaque();
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpolicy_np(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpolicy_np(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
extern "C" {
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> size_t;
}
extern "C" {
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_yield_np();
}
extern "C" {
    pub fn pthread_jit_write_protect_np(enabled: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pthread_jit_write_protect_supported_np() -> ::std::os::raw::c_int;
}
pub type pthread_jit_write_callback_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn pthread_jit_write_with_callback_np(
        callback: pthread_jit_write_callback_t,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_jit_write_freeze_callbacks_np();
}
extern "C" {
    pub fn pthread_cpu_number_np(cpu_number_out: *mut size_t) -> ::std::os::raw::c_int;
}
pub type sem_t = ::std::os::raw::c_int;
extern "C" {
    pub fn sem_close(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_destroy(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_getvalue(
        arg1: *mut sem_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_init(
        arg1: *mut sem_t,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> *mut sem_t;
}
extern "C" {
    pub fn sem_post(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_trywait(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sem_wait(arg1: *mut sem_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub static sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closelog();
}
extern "C" {
    pub fn openlog(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlogmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_syslog$DARWIN_EXTSN"]
    pub fn syslog(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vsyslog(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: __darwin_va_list,
    );
}
pub type tcflag_t = ::std::os::raw::c_ulong;
pub type cc_t = ::std::os::raw::c_uchar;
pub type speed_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct termios {
    pub c_iflag: tcflag_t,
    pub c_oflag: tcflag_t,
    pub c_cflag: tcflag_t,
    pub c_lflag: tcflag_t,
    pub c_cc: [cc_t; 20usize],
    pub c_ispeed: speed_t,
    pub c_ospeed: speed_t,
}
#[test]
fn bindgen_test_layout_termios() {
    assert_eq!(
        ::std::mem::size_of::<termios>(),
        72usize,
        concat!("Size of: ", stringify!(termios))
    );
    assert_eq!(
        ::std::mem::align_of::<termios>(),
        8usize,
        concat!("Alignment of ", stringify!(termios))
    );
    fn test_field_c_iflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_iflag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_iflag)
            )
        );
    }
    test_field_c_iflag();
    fn test_field_c_oflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_oflag) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_oflag)
            )
        );
    }
    test_field_c_oflag();
    fn test_field_c_cflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_cflag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_cflag)
            )
        );
    }
    test_field_c_cflag();
    fn test_field_c_lflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_lflag) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_lflag)
            )
        );
    }
    test_field_c_lflag();
    fn test_field_c_cc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_cc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_cc)
            )
        );
    }
    test_field_c_cc();
    fn test_field_c_ispeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_ispeed) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_ispeed)
            )
        );
    }
    test_field_c_ispeed();
    fn test_field_c_ospeed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<termios>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).c_ospeed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(termios),
                "::",
                stringify!(c_ospeed)
            )
        );
    }
    test_field_c_ospeed();
}
extern "C" {
    pub fn cfgetispeed(arg1: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfgetospeed(arg1: *const termios) -> speed_t;
}
extern "C" {
    pub fn cfsetispeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfsetospeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetattr(arg1: ::std::os::raw::c_int, arg2: *mut termios) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsetattr(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *const termios,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcdrain(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflow(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcflush(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcsendbreak(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cfmakeraw(arg1: *mut termios);
}
extern "C" {
    pub fn cfsetspeed(arg1: *mut termios, arg2: speed_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct winsize {
    pub ws_row: ::std::os::raw::c_ushort,
    pub ws_col: ::std::os::raw::c_ushort,
    pub ws_xpixel: ::std::os::raw::c_ushort,
    pub ws_ypixel: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_winsize() {
    assert_eq!(
        ::std::mem::size_of::<winsize>(),
        8usize,
        concat!("Size of: ", stringify!(winsize))
    );
    assert_eq!(
        ::std::mem::align_of::<winsize>(),
        2usize,
        concat!("Alignment of ", stringify!(winsize))
    );
    fn test_field_ws_row() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_row) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_row)
            )
        );
    }
    test_field_ws_row();
    fn test_field_ws_col() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_col) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_col)
            )
        );
    }
    test_field_ws_col();
    fn test_field_ws_xpixel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_xpixel) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_xpixel)
            )
        );
    }
    test_field_ws_xpixel();
    fn test_field_ws_ypixel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<winsize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ws_ypixel) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(winsize),
                "::",
                stringify!(ws_ypixel)
            )
        );
    }
    test_field_ws_ypixel();
}
extern "C" {
    pub fn tcgetsid(arg1: ::std::os::raw::c_int) -> pid_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    fn test_field_ad_name_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_name_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_name_offset)
            )
        );
    }
    test_field_ad_name_offset();
    fn test_field_ad_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_flags)
            )
        );
    }
    test_field_ad_flags();
    fn test_field_ad_pad() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<accessx_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ad_pad) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(accessx_descriptor),
                "::",
                stringify!(ad_pad)
            )
        );
    }
    test_field_ad_pad();
}
extern "C" {
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
        arg6: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freadlink(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> pid_t;
}
extern "C" {
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getegid() -> gid_t;
}
extern "C" {
    pub fn geteuid() -> uid_t;
}
extern "C" {
    pub fn getgid() -> gid_t;
}
extern "C" {
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    pub fn getpid() -> pid_t;
}
extern "C" {
    pub fn getppid() -> pid_t;
}
extern "C" {
    pub fn getuid() -> uid_t;
}
extern "C" {
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> pid_t;
}
extern "C" {
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: size_t,
        __offset: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtempat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostempsat_np(
        dfd: ::std::os::raw::c_int,
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: size_t,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval64 {
    pub tv_sec: __int64_t,
    pub tv_usec: __int64_t,
}
#[test]
fn bindgen_test_layout_timeval64() {
    assert_eq!(
        ::std::mem::size_of::<timeval64>(),
        16usize,
        concat!("Size of: ", stringify!(timeval64))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval64>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval64))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval64),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval64),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    fn test_field_it_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_interval)
            )
        );
    }
    test_field_it_interval();
    fn test_field_it_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<itimerval>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(itimerval),
                "::",
                stringify!(it_value)
            )
        );
    }
    test_field_it_value();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    fn test_field_tz_minuteswest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_minuteswest) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_minuteswest)
            )
        );
    }
    test_field_tz_minuteswest();
    fn test_field_tz_dsttime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timezone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tz_dsttime) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(timezone),
                "::",
                stringify!(tz_dsttime)
            )
        );
    }
    test_field_tz_dsttime();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub tickadj: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::std::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    fn test_field_hz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(hz)
            )
        );
    }
    test_field_hz();
    fn test_field_tick() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tick) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(tick)
            )
        );
    }
    test_field_tick();
    fn test_field_tickadj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tickadj) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(tickadj)
            )
        );
    }
    test_field_tickadj();
    fn test_field_stathz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stathz) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(stathz)
            )
        );
    }
    test_field_stathz();
    fn test_field_profhz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<clockinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).profhz) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(clockinfo),
                "::",
                stringify!(profhz)
            )
        );
    }
    test_field_profhz();
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::std::os::raw::c_int, arg2: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getitimer(arg1: ::std::os::raw::c_int, arg2: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gettimeofday(
        arg1: *mut timeval,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        arg1: ::std::os::raw::c_int,
        arg2: *const itimerval,
        arg3: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const timeval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct net_event_data {
    pub if_family: u_int32_t,
    pub if_unit: u_int32_t,
    pub if_name: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_net_event_data() {
    assert_eq!(
        ::std::mem::size_of::<net_event_data>(),
        24usize,
        concat!("Size of: ", stringify!(net_event_data))
    );
    assert_eq!(
        ::std::mem::align_of::<net_event_data>(),
        4usize,
        concat!("Alignment of ", stringify!(net_event_data))
    );
    fn test_field_if_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_family) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_family)
            )
        );
    }
    test_field_if_family();
    fn test_field_if_unit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_unit) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_unit)
            )
        );
    }
    test_field_if_unit();
    fn test_field_if_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<net_event_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(net_event_data),
                "::",
                stringify!(if_name)
            )
        );
    }
    test_field_if_name();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval32 {
    pub tv_sec: __int32_t,
    pub tv_usec: __int32_t,
}
#[test]
fn bindgen_test_layout_timeval32() {
    assert_eq!(
        ::std::mem::size_of::<timeval32>(),
        8usize,
        concat!("Size of: ", stringify!(timeval32))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval32>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval32))
    );
    fn test_field_tv_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval32),
                "::",
                stringify!(tv_sec)
            )
        );
    }
    test_field_tv_sec();
    fn test_field_tv_usec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<timeval32>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(timeval32),
                "::",
                stringify!(tv_usec)
            )
        );
    }
    test_field_tv_usec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_data {
    pub ifi_type: u_char,
    pub ifi_typelen: u_char,
    pub ifi_physical: u_char,
    pub ifi_addrlen: u_char,
    pub ifi_hdrlen: u_char,
    pub ifi_recvquota: u_char,
    pub ifi_xmitquota: u_char,
    pub ifi_unused1: u_char,
    pub ifi_mtu: u_int32_t,
    pub ifi_metric: u_int32_t,
    pub ifi_baudrate: u_int32_t,
    pub ifi_ipackets: u_int32_t,
    pub ifi_ierrors: u_int32_t,
    pub ifi_opackets: u_int32_t,
    pub ifi_oerrors: u_int32_t,
    pub ifi_collisions: u_int32_t,
    pub ifi_ibytes: u_int32_t,
    pub ifi_obytes: u_int32_t,
    pub ifi_imcasts: u_int32_t,
    pub ifi_omcasts: u_int32_t,
    pub ifi_iqdrops: u_int32_t,
    pub ifi_noproto: u_int32_t,
    pub ifi_recvtiming: u_int32_t,
    pub ifi_xmittiming: u_int32_t,
    pub ifi_lastchange: timeval32,
    pub ifi_unused2: u_int32_t,
    pub ifi_hwassist: u_int32_t,
    pub ifi_reserved1: u_int32_t,
    pub ifi_reserved2: u_int32_t,
}
#[test]
fn bindgen_test_layout_if_data() {
    assert_eq!(
        ::std::mem::size_of::<if_data>(),
        96usize,
        concat!("Size of: ", stringify!(if_data))
    );
    assert_eq!(
        ::std::mem::align_of::<if_data>(),
        4usize,
        concat!("Alignment of ", stringify!(if_data))
    );
    fn test_field_ifi_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_type)
            )
        );
    }
    test_field_ifi_type();
    fn test_field_ifi_typelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_typelen) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_typelen)
            )
        );
    }
    test_field_ifi_typelen();
    fn test_field_ifi_physical() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_physical) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_physical)
            )
        );
    }
    test_field_ifi_physical();
    fn test_field_ifi_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_addrlen) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_addrlen)
            )
        );
    }
    test_field_ifi_addrlen();
    fn test_field_ifi_hdrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hdrlen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_hdrlen)
            )
        );
    }
    test_field_ifi_hdrlen();
    fn test_field_ifi_recvquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvquota) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_recvquota)
            )
        );
    }
    test_field_ifi_recvquota();
    fn test_field_ifi_xmitquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmitquota) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_xmitquota)
            )
        );
    }
    test_field_ifi_xmitquota();
    fn test_field_ifi_unused1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_unused1)
            )
        );
    }
    test_field_ifi_unused1();
    fn test_field_ifi_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_mtu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_mtu)
            )
        );
    }
    test_field_ifi_mtu();
    fn test_field_ifi_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_metric) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_metric)
            )
        );
    }
    test_field_ifi_metric();
    fn test_field_ifi_baudrate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_baudrate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_baudrate)
            )
        );
    }
    test_field_ifi_baudrate();
    fn test_field_ifi_ipackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ipackets) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ipackets)
            )
        );
    }
    test_field_ifi_ipackets();
    fn test_field_ifi_ierrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ierrors) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ierrors)
            )
        );
    }
    test_field_ifi_ierrors();
    fn test_field_ifi_opackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_opackets) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_opackets)
            )
        );
    }
    test_field_ifi_opackets();
    fn test_field_ifi_oerrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_oerrors) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_oerrors)
            )
        );
    }
    test_field_ifi_oerrors();
    fn test_field_ifi_collisions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_collisions) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_collisions)
            )
        );
    }
    test_field_ifi_collisions();
    fn test_field_ifi_ibytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ibytes) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_ibytes)
            )
        );
    }
    test_field_ifi_ibytes();
    fn test_field_ifi_obytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_obytes) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_obytes)
            )
        );
    }
    test_field_ifi_obytes();
    fn test_field_ifi_imcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_imcasts) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_imcasts)
            )
        );
    }
    test_field_ifi_imcasts();
    fn test_field_ifi_omcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_omcasts) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_omcasts)
            )
        );
    }
    test_field_ifi_omcasts();
    fn test_field_ifi_iqdrops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_iqdrops) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_iqdrops)
            )
        );
    }
    test_field_ifi_iqdrops();
    fn test_field_ifi_noproto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_noproto) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_noproto)
            )
        );
    }
    test_field_ifi_noproto();
    fn test_field_ifi_recvtiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvtiming) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_recvtiming)
            )
        );
    }
    test_field_ifi_recvtiming();
    fn test_field_ifi_xmittiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmittiming) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_xmittiming)
            )
        );
    }
    test_field_ifi_xmittiming();
    fn test_field_ifi_lastchange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_lastchange) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_lastchange)
            )
        );
    }
    test_field_ifi_lastchange();
    fn test_field_ifi_unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused2) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_unused2)
            )
        );
    }
    test_field_ifi_unused2();
    fn test_field_ifi_hwassist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hwassist) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_hwassist)
            )
        );
    }
    test_field_ifi_hwassist();
    fn test_field_ifi_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_reserved1) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_reserved1)
            )
        );
    }
    test_field_ifi_reserved1();
    fn test_field_ifi_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_reserved2) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data),
                "::",
                stringify!(ifi_reserved2)
            )
        );
    }
    test_field_ifi_reserved2();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct if_data64 {
    pub ifi_type: u_char,
    pub ifi_typelen: u_char,
    pub ifi_physical: u_char,
    pub ifi_addrlen: u_char,
    pub ifi_hdrlen: u_char,
    pub ifi_recvquota: u_char,
    pub ifi_xmitquota: u_char,
    pub ifi_unused1: u_char,
    pub ifi_mtu: u_int32_t,
    pub ifi_metric: u_int32_t,
    pub ifi_baudrate: u_int64_t,
    pub ifi_ipackets: u_int64_t,
    pub ifi_ierrors: u_int64_t,
    pub ifi_opackets: u_int64_t,
    pub ifi_oerrors: u_int64_t,
    pub ifi_collisions: u_int64_t,
    pub ifi_ibytes: u_int64_t,
    pub ifi_obytes: u_int64_t,
    pub ifi_imcasts: u_int64_t,
    pub ifi_omcasts: u_int64_t,
    pub ifi_iqdrops: u_int64_t,
    pub ifi_noproto: u_int64_t,
    pub ifi_recvtiming: u_int32_t,
    pub ifi_xmittiming: u_int32_t,
    pub ifi_lastchange: timeval32,
}
#[test]
fn bindgen_test_layout_if_data64() {
    assert_eq!(
        ::std::mem::size_of::<if_data64>(),
        128usize,
        concat!("Size of: ", stringify!(if_data64))
    );
    assert_eq!(
        ::std::mem::align_of::<if_data64>(),
        4usize,
        concat!("Alignment of ", stringify!(if_data64))
    );
    fn test_field_ifi_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_type)
            )
        );
    }
    test_field_ifi_type();
    fn test_field_ifi_typelen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_typelen) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_typelen)
            )
        );
    }
    test_field_ifi_typelen();
    fn test_field_ifi_physical() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_physical) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_physical)
            )
        );
    }
    test_field_ifi_physical();
    fn test_field_ifi_addrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_addrlen) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_addrlen)
            )
        );
    }
    test_field_ifi_addrlen();
    fn test_field_ifi_hdrlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_hdrlen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_hdrlen)
            )
        );
    }
    test_field_ifi_hdrlen();
    fn test_field_ifi_recvquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvquota) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_recvquota)
            )
        );
    }
    test_field_ifi_recvquota();
    fn test_field_ifi_xmitquota() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmitquota) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_xmitquota)
            )
        );
    }
    test_field_ifi_xmitquota();
    fn test_field_ifi_unused1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_unused1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_unused1)
            )
        );
    }
    test_field_ifi_unused1();
    fn test_field_ifi_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_mtu) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_mtu)
            )
        );
    }
    test_field_ifi_mtu();
    fn test_field_ifi_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_metric) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_metric)
            )
        );
    }
    test_field_ifi_metric();
    fn test_field_ifi_baudrate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_baudrate) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_baudrate)
            )
        );
    }
    test_field_ifi_baudrate();
    fn test_field_ifi_ipackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ipackets) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ipackets)
            )
        );
    }
    test_field_ifi_ipackets();
    fn test_field_ifi_ierrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ierrors) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ierrors)
            )
        );
    }
    test_field_ifi_ierrors();
    fn test_field_ifi_opackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_opackets) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_opackets)
            )
        );
    }
    test_field_ifi_opackets();
    fn test_field_ifi_oerrors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_oerrors) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_oerrors)
            )
        );
    }
    test_field_ifi_oerrors();
    fn test_field_ifi_collisions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_collisions) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_collisions)
            )
        );
    }
    test_field_ifi_collisions();
    fn test_field_ifi_ibytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_ibytes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_ibytes)
            )
        );
    }
    test_field_ifi_ibytes();
    fn test_field_ifi_obytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_obytes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_obytes)
            )
        );
    }
    test_field_ifi_obytes();
    fn test_field_ifi_imcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_imcasts) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_imcasts)
            )
        );
    }
    test_field_ifi_imcasts();
    fn test_field_ifi_omcasts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_omcasts) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_omcasts)
            )
        );
    }
    test_field_ifi_omcasts();
    fn test_field_ifi_iqdrops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_iqdrops) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_iqdrops)
            )
        );
    }
    test_field_ifi_iqdrops();
    fn test_field_ifi_noproto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_noproto) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_noproto)
            )
        );
    }
    test_field_ifi_noproto();
    fn test_field_ifi_recvtiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_recvtiming) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_recvtiming)
            )
        );
    }
    test_field_ifi_recvtiming();
    fn test_field_ifi_xmittiming() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_xmittiming) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_xmittiming)
            )
        );
    }
    test_field_ifi_xmittiming();
    fn test_field_ifi_lastchange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_data64>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifi_lastchange) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(if_data64),
                "::",
                stringify!(ifi_lastchange)
            )
        );
    }
    test_field_ifi_lastchange();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifnet_interface_advisory {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifqueue {
    pub ifq_head: *mut ::std::os::raw::c_void,
    pub ifq_tail: *mut ::std::os::raw::c_void,
    pub ifq_len: ::std::os::raw::c_int,
    pub ifq_maxlen: ::std::os::raw::c_int,
    pub ifq_drops: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifqueue() {
    assert_eq!(
        ::std::mem::size_of::<ifqueue>(),
        32usize,
        concat!("Size of: ", stringify!(ifqueue))
    );
    assert_eq!(
        ::std::mem::align_of::<ifqueue>(),
        8usize,
        concat!("Alignment of ", stringify!(ifqueue))
    );
    fn test_field_ifq_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_head)
            )
        );
    }
    test_field_ifq_head();
    fn test_field_ifq_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_tail)
            )
        );
    }
    test_field_ifq_tail();
    fn test_field_ifq_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_len)
            )
        );
    }
    test_field_ifq_len();
    fn test_field_ifq_maxlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_maxlen) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_maxlen)
            )
        );
    }
    test_field_ifq_maxlen();
    fn test_field_ifq_drops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifqueue>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifq_drops) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifqueue),
                "::",
                stringify!(ifq_drops)
            )
        );
    }
    test_field_ifq_drops();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_clonereq {
    pub ifcr_total: ::std::os::raw::c_int,
    pub ifcr_count: ::std::os::raw::c_int,
    pub ifcr_buffer: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_clonereq() {
    assert_eq!(
        ::std::mem::size_of::<if_clonereq>(),
        16usize,
        concat!("Size of: ", stringify!(if_clonereq))
    );
    assert_eq!(
        ::std::mem::align_of::<if_clonereq>(),
        8usize,
        concat!("Alignment of ", stringify!(if_clonereq))
    );
    fn test_field_ifcr_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_total) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_total)
            )
        );
    }
    test_field_ifcr_total();
    fn test_field_ifcr_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_count)
            )
        );
    }
    test_field_ifcr_count();
    fn test_field_ifcr_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_clonereq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcr_buffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_clonereq),
                "::",
                stringify!(ifcr_buffer)
            )
        );
    }
    test_field_ifcr_buffer();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_msghdr {
    pub ifm_msglen: ::std::os::raw::c_ushort,
    pub ifm_version: ::std::os::raw::c_uchar,
    pub ifm_type: ::std::os::raw::c_uchar,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: ::std::os::raw::c_ushort,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<if_msghdr>(),
        112usize,
        concat!("Size of: ", stringify!(if_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<if_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(if_msghdr))
    );
    fn test_field_ifm_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_msglen)
            )
        );
    }
    test_field_ifm_msglen();
    fn test_field_ifm_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_version)
            )
        );
    }
    test_field_ifm_version();
    fn test_field_ifm_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_type)
            )
        );
    }
    test_field_ifm_type();
    fn test_field_ifm_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_addrs)
            )
        );
    }
    test_field_ifm_addrs();
    fn test_field_ifm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_flags)
            )
        );
    }
    test_field_ifm_flags();
    fn test_field_ifm_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_index)
            )
        );
    }
    test_field_ifm_index();
    fn test_field_ifm_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr),
                "::",
                stringify!(ifm_data)
            )
        );
    }
    test_field_ifm_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifa_msghdr {
    pub ifam_msglen: ::std::os::raw::c_ushort,
    pub ifam_version: ::std::os::raw::c_uchar,
    pub ifam_type: ::std::os::raw::c_uchar,
    pub ifam_addrs: ::std::os::raw::c_int,
    pub ifam_flags: ::std::os::raw::c_int,
    pub ifam_index: ::std::os::raw::c_ushort,
    pub ifam_metric: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifa_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<ifa_msghdr>(),
        20usize,
        concat!("Size of: ", stringify!(ifa_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ifa_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ifa_msghdr))
    );
    fn test_field_ifam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_msglen)
            )
        );
    }
    test_field_ifam_msglen();
    fn test_field_ifam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_version)
            )
        );
    }
    test_field_ifam_version();
    fn test_field_ifam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_type)
            )
        );
    }
    test_field_ifam_type();
    fn test_field_ifam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_addrs)
            )
        );
    }
    test_field_ifam_addrs();
    fn test_field_ifam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_flags)
            )
        );
    }
    test_field_ifam_flags();
    fn test_field_ifam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_index)
            )
        );
    }
    test_field_ifam_index();
    fn test_field_ifam_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifa_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifam_metric) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifa_msghdr),
                "::",
                stringify!(ifam_metric)
            )
        );
    }
    test_field_ifam_metric();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifma_msghdr {
    pub ifmam_msglen: ::std::os::raw::c_ushort,
    pub ifmam_version: ::std::os::raw::c_uchar,
    pub ifmam_type: ::std::os::raw::c_uchar,
    pub ifmam_addrs: ::std::os::raw::c_int,
    pub ifmam_flags: ::std::os::raw::c_int,
    pub ifmam_index: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ifma_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<ifma_msghdr>(),
        16usize,
        concat!("Size of: ", stringify!(ifma_msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<ifma_msghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(ifma_msghdr))
    );
    fn test_field_ifmam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_msglen)
            )
        );
    }
    test_field_ifmam_msglen();
    fn test_field_ifmam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_version)
            )
        );
    }
    test_field_ifmam_version();
    fn test_field_ifmam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_type)
            )
        );
    }
    test_field_ifmam_type();
    fn test_field_ifmam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_addrs)
            )
        );
    }
    test_field_ifmam_addrs();
    fn test_field_ifmam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_flags)
            )
        );
    }
    test_field_ifmam_flags();
    fn test_field_ifmam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr),
                "::",
                stringify!(ifmam_index)
            )
        );
    }
    test_field_ifmam_index();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_msghdr2 {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: u_short,
    pub ifm_snd_len: ::std::os::raw::c_int,
    pub ifm_snd_maxlen: ::std::os::raw::c_int,
    pub ifm_snd_drops: ::std::os::raw::c_int,
    pub ifm_timer: ::std::os::raw::c_int,
    pub ifm_data: if_data64,
}
#[test]
fn bindgen_test_layout_if_msghdr2() {
    assert_eq!(
        ::std::mem::size_of::<if_msghdr2>(),
        160usize,
        concat!("Size of: ", stringify!(if_msghdr2))
    );
    assert_eq!(
        ::std::mem::align_of::<if_msghdr2>(),
        4usize,
        concat!("Alignment of ", stringify!(if_msghdr2))
    );
    fn test_field_ifm_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_msglen)
            )
        );
    }
    test_field_ifm_msglen();
    fn test_field_ifm_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_version)
            )
        );
    }
    test_field_ifm_version();
    fn test_field_ifm_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_type)
            )
        );
    }
    test_field_ifm_type();
    fn test_field_ifm_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_addrs)
            )
        );
    }
    test_field_ifm_addrs();
    fn test_field_ifm_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_flags)
            )
        );
    }
    test_field_ifm_flags();
    fn test_field_ifm_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_index)
            )
        );
    }
    test_field_ifm_index();
    fn test_field_ifm_snd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_len) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_len)
            )
        );
    }
    test_field_ifm_snd_len();
    fn test_field_ifm_snd_maxlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_maxlen) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_maxlen)
            )
        );
    }
    test_field_ifm_snd_maxlen();
    fn test_field_ifm_snd_drops() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_snd_drops) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_snd_drops)
            )
        );
    }
    test_field_ifm_snd_drops();
    fn test_field_ifm_timer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_timer) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_timer)
            )
        );
    }
    test_field_ifm_timer();
    fn test_field_ifm_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(if_msghdr2),
                "::",
                stringify!(ifm_data)
            )
        );
    }
    test_field_ifm_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifma_msghdr2 {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::std::os::raw::c_int,
    pub ifmam_flags: ::std::os::raw::c_int,
    pub ifmam_index: u_short,
    pub ifmam_refcount: i32,
}
#[test]
fn bindgen_test_layout_ifma_msghdr2() {
    assert_eq!(
        ::std::mem::size_of::<ifma_msghdr2>(),
        20usize,
        concat!("Size of: ", stringify!(ifma_msghdr2))
    );
    assert_eq!(
        ::std::mem::align_of::<ifma_msghdr2>(),
        4usize,
        concat!("Alignment of ", stringify!(ifma_msghdr2))
    );
    fn test_field_ifmam_msglen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_msglen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_msglen)
            )
        );
    }
    test_field_ifmam_msglen();
    fn test_field_ifmam_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_version) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_version)
            )
        );
    }
    test_field_ifmam_version();
    fn test_field_ifmam_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_type) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_type)
            )
        );
    }
    test_field_ifmam_type();
    fn test_field_ifmam_addrs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_addrs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_addrs)
            )
        );
    }
    test_field_ifmam_addrs();
    fn test_field_ifmam_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_flags)
            )
        );
    }
    test_field_ifmam_flags();
    fn test_field_ifmam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_index) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_index)
            )
        );
    }
    test_field_ifmam_index();
    fn test_field_ifmam_refcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifma_msghdr2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifmam_refcount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifma_msghdr2),
                "::",
                stringify!(ifmam_refcount)
            )
        );
    }
    test_field_ifmam_refcount();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifdevmtu {
    pub ifdm_current: ::std::os::raw::c_int,
    pub ifdm_min: ::std::os::raw::c_int,
    pub ifdm_max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifdevmtu() {
    assert_eq!(
        ::std::mem::size_of::<ifdevmtu>(),
        12usize,
        concat!("Size of: ", stringify!(ifdevmtu))
    );
    assert_eq!(
        ::std::mem::align_of::<ifdevmtu>(),
        4usize,
        concat!("Alignment of ", stringify!(ifdevmtu))
    );
    fn test_field_ifdm_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_current) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_current)
            )
        );
    }
    test_field_ifdm_current();
    fn test_field_ifdm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_min) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_min)
            )
        );
    }
    test_field_ifdm_min();
    fn test_field_ifdm_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdevmtu>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifdm_max) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdevmtu),
                "::",
                stringify!(ifdm_max)
            )
        );
    }
    test_field_ifdm_max();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifkpi {
    pub ifk_module_id: ::std::os::raw::c_uint,
    pub ifk_type: ::std::os::raw::c_uint,
    pub ifk_data: ifkpi__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union ifkpi__bindgen_ty_1 {
    pub ifk_ptr: *mut ::std::os::raw::c_void,
    pub ifk_value: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifkpi__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifkpi__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifkpi__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifkpi__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ifkpi__bindgen_ty_1))
    );
    fn test_field_ifk_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi__bindgen_ty_1),
                "::",
                stringify!(ifk_ptr)
            )
        );
    }
    test_field_ifk_ptr();
    fn test_field_ifk_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_value) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi__bindgen_ty_1),
                "::",
                stringify!(ifk_value)
            )
        );
    }
    test_field_ifk_value();
}
#[test]
fn bindgen_test_layout_ifkpi() {
    assert_eq!(
        ::std::mem::size_of::<ifkpi>(),
        16usize,
        concat!("Size of: ", stringify!(ifkpi))
    );
    assert_eq!(
        ::std::mem::align_of::<ifkpi>(),
        4usize,
        concat!("Alignment of ", stringify!(ifkpi))
    );
    fn test_field_ifk_module_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_module_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_module_id)
            )
        );
    }
    test_field_ifk_module_id();
    fn test_field_ifk_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_type)
            )
        );
    }
    test_field_ifk_type();
    fn test_field_ifk_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifkpi>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifk_data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ifkpi),
                "::",
                stringify!(ifk_data)
            )
        );
    }
    test_field_ifk_data();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_name: [::std::os::raw::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_flags: ::std::os::raw::c_short,
    pub ifru_metric: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_phys: ::std::os::raw::c_int,
    pub ifru_media: ::std::os::raw::c_int,
    pub ifru_intval: ::std::os::raw::c_int,
    pub ifru_data: caddr_t,
    pub ifru_devmtu: ifdevmtu,
    pub ifru_kpi: ifkpi,
    pub ifru_wake_flags: u_int32_t,
    pub ifru_route_refcnt: u_int32_t,
    pub ifru_cap: [::std::os::raw::c_int; 2usize],
    pub ifru_functional_type: u_int32_t,
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifreq__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ifreq__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq__bindgen_ty_1))
    );
    fn test_field_ifru_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_addr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_addr)
            )
        );
    }
    test_field_ifru_addr();
    fn test_field_ifru_dstaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_dstaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_dstaddr)
            )
        );
    }
    test_field_ifru_dstaddr();
    fn test_field_ifru_broadaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_broadaddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_broadaddr)
            )
        );
    }
    test_field_ifru_broadaddr();
    fn test_field_ifru_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_flags)
            )
        );
    }
    test_field_ifru_flags();
    fn test_field_ifru_metric() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_metric) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_metric)
            )
        );
    }
    test_field_ifru_metric();
    fn test_field_ifru_mtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_mtu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_mtu)
            )
        );
    }
    test_field_ifru_mtu();
    fn test_field_ifru_phys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_phys) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_phys)
            )
        );
    }
    test_field_ifru_phys();
    fn test_field_ifru_media() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_media) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_media)
            )
        );
    }
    test_field_ifru_media();
    fn test_field_ifru_intval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_intval) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_intval)
            )
        );
    }
    test_field_ifru_intval();
    fn test_field_ifru_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_data)
            )
        );
    }
    test_field_ifru_data();
    fn test_field_ifru_devmtu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_devmtu) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_devmtu)
            )
        );
    }
    test_field_ifru_devmtu();
    fn test_field_ifru_kpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_kpi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_kpi)
            )
        );
    }
    test_field_ifru_kpi();
    fn test_field_ifru_wake_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_wake_flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_wake_flags)
            )
        );
    }
    test_field_ifru_wake_flags();
    fn test_field_ifru_route_refcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_route_refcnt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_route_refcnt)
            )
        );
    }
    test_field_ifru_route_refcnt();
    fn test_field_ifru_cap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_cap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_cap)
            )
        );
    }
    test_field_ifru_cap();
    fn test_field_ifru_functional_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifru_functional_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq__bindgen_ty_1),
                "::",
                stringify!(ifru_functional_type)
            )
        );
    }
    test_field_ifru_functional_type();
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(
        ::std::mem::size_of::<ifreq>(),
        32usize,
        concat!("Size of: ", stringify!(ifreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifreq>(),
        8usize,
        concat!("Alignment of ", stringify!(ifreq))
    );
    fn test_field_ifr_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifr_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_name)
            )
        );
    }
    test_field_ifr_name();
    fn test_field_ifr_ifru() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifr_ifru) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifreq),
                "::",
                stringify!(ifr_ifru)
            )
        );
    }
    test_field_ifr_ifru();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifaliasreq {
    pub ifra_name: [::std::os::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[test]
fn bindgen_test_layout_ifaliasreq() {
    assert_eq!(
        ::std::mem::size_of::<ifaliasreq>(),
        64usize,
        concat!("Size of: ", stringify!(ifaliasreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifaliasreq>(),
        1usize,
        concat!("Alignment of ", stringify!(ifaliasreq))
    );
    fn test_field_ifra_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_name)
            )
        );
    }
    test_field_ifra_name();
    fn test_field_ifra_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_addr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_addr)
            )
        );
    }
    test_field_ifra_addr();
    fn test_field_ifra_broadaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_broadaddr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_broadaddr)
            )
        );
    }
    test_field_ifra_broadaddr();
    fn test_field_ifra_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifaliasreq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifra_mask) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ifaliasreq),
                "::",
                stringify!(ifra_mask)
            )
        );
    }
    test_field_ifra_mask();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rslvmulti_req {
    pub sa: *mut sockaddr,
    pub llsa: *mut *mut sockaddr,
}
#[test]
fn bindgen_test_layout_rslvmulti_req() {
    assert_eq!(
        ::std::mem::size_of::<rslvmulti_req>(),
        16usize,
        concat!("Size of: ", stringify!(rslvmulti_req))
    );
    assert_eq!(
        ::std::mem::align_of::<rslvmulti_req>(),
        8usize,
        concat!("Alignment of ", stringify!(rslvmulti_req))
    );
    fn test_field_sa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rslvmulti_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rslvmulti_req),
                "::",
                stringify!(sa)
            )
        );
    }
    test_field_sa();
    fn test_field_llsa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rslvmulti_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).llsa) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rslvmulti_req),
                "::",
                stringify!(llsa)
            )
        );
    }
    test_field_llsa();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ifmediareq {
    pub ifm_name: [::std::os::raw::c_char; 16usize],
    pub ifm_current: ::std::os::raw::c_int,
    pub ifm_mask: ::std::os::raw::c_int,
    pub ifm_status: ::std::os::raw::c_int,
    pub ifm_active: ::std::os::raw::c_int,
    pub ifm_count: ::std::os::raw::c_int,
    pub ifm_ulist: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifmediareq() {
    assert_eq!(
        ::std::mem::size_of::<ifmediareq>(),
        44usize,
        concat!("Size of: ", stringify!(ifmediareq))
    );
    assert_eq!(
        ::std::mem::align_of::<ifmediareq>(),
        4usize,
        concat!("Alignment of ", stringify!(ifmediareq))
    );
    fn test_field_ifm_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_name)
            )
        );
    }
    test_field_ifm_name();
    fn test_field_ifm_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_current) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_current)
            )
        );
    }
    test_field_ifm_current();
    fn test_field_ifm_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_mask) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_mask)
            )
        );
    }
    test_field_ifm_mask();
    fn test_field_ifm_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_status) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_status)
            )
        );
    }
    test_field_ifm_status();
    fn test_field_ifm_active() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_active) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_active)
            )
        );
    }
    test_field_ifm_active();
    fn test_field_ifm_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_count) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_count)
            )
        );
    }
    test_field_ifm_count();
    fn test_field_ifm_ulist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifmediareq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifm_ulist) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(ifmediareq),
                "::",
                stringify!(ifm_ulist)
            )
        );
    }
    test_field_ifm_ulist();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct ifdrv {
    pub ifd_name: [::std::os::raw::c_char; 16usize],
    pub ifd_cmd: ::std::os::raw::c_ulong,
    pub ifd_len: size_t,
    pub ifd_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifdrv() {
    assert_eq!(
        ::std::mem::size_of::<ifdrv>(),
        40usize,
        concat!("Size of: ", stringify!(ifdrv))
    );
    assert_eq!(
        ::std::mem::align_of::<ifdrv>(),
        4usize,
        concat!("Alignment of ", stringify!(ifdrv))
    );
    fn test_field_ifd_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_name)
            )
        );
    }
    test_field_ifd_name();
    fn test_field_ifd_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_cmd) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_cmd)
            )
        );
    }
    test_field_ifd_cmd();
    fn test_field_ifd_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_len) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_len)
            )
        );
    }
    test_field_ifd_len();
    fn test_field_ifd_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifdrv>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifd_data) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ifdrv),
                "::",
                stringify!(ifd_data)
            )
        );
    }
    test_field_ifd_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifstat {
    pub ifs_name: [::std::os::raw::c_char; 16usize],
    pub ascii: [::std::os::raw::c_char; 801usize],
}
#[test]
fn bindgen_test_layout_ifstat() {
    assert_eq!(
        ::std::mem::size_of::<ifstat>(),
        817usize,
        concat!("Size of: ", stringify!(ifstat))
    );
    assert_eq!(
        ::std::mem::align_of::<ifstat>(),
        1usize,
        concat!("Alignment of ", stringify!(ifstat))
    );
    fn test_field_ifs_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifs_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifstat),
                "::",
                stringify!(ifs_name)
            )
        );
    }
    test_field_ifs_name();
    fn test_field_ascii() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ascii) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ifstat),
                "::",
                stringify!(ascii)
            )
        );
    }
    test_field_ascii();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: ::std::os::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C, packed(4))]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ifconf__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ifconf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ifconf__bindgen_ty_1))
    );
    fn test_field_ifcu_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcu_buf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf__bindgen_ty_1),
                "::",
                stringify!(ifcu_buf)
            )
        );
    }
    test_field_ifcu_buf();
    fn test_field_ifcu_req() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifcu_req) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf__bindgen_ty_1),
                "::",
                stringify!(ifcu_req)
            )
        );
    }
    test_field_ifcu_req();
}
#[test]
fn bindgen_test_layout_ifconf() {
    assert_eq!(
        ::std::mem::size_of::<ifconf>(),
        12usize,
        concat!("Size of: ", stringify!(ifconf))
    );
    assert_eq!(
        ::std::mem::align_of::<ifconf>(),
        4usize,
        concat!("Alignment of ", stringify!(ifconf))
    );
    fn test_field_ifc_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf),
                "::",
                stringify!(ifc_len)
            )
        );
    }
    test_field_ifc_len();
    fn test_field_ifc_ifcu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ifconf>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ifc_ifcu) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ifconf),
                "::",
                stringify!(ifc_ifcu)
            )
        );
    }
    test_field_ifc_ifcu();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kev_dl_proto_data {
    pub link_data: net_event_data,
    pub proto_family: u_int32_t,
    pub proto_remaining_count: u_int32_t,
}
#[test]
fn bindgen_test_layout_kev_dl_proto_data() {
    assert_eq!(
        ::std::mem::size_of::<kev_dl_proto_data>(),
        32usize,
        concat!("Size of: ", stringify!(kev_dl_proto_data))
    );
    assert_eq!(
        ::std::mem::align_of::<kev_dl_proto_data>(),
        4usize,
        concat!("Alignment of ", stringify!(kev_dl_proto_data))
    );
    fn test_field_link_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).link_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(link_data)
            )
        );
    }
    test_field_link_data();
    fn test_field_proto_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_family) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(proto_family)
            )
        );
    }
    test_field_proto_family();
    fn test_field_proto_remaining_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kev_dl_proto_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proto_remaining_count) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(kev_dl_proto_data),
                "::",
                stringify!(proto_remaining_count)
            )
        );
    }
    test_field_proto_remaining_count();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_nameindex {
    pub if_index: ::std::os::raw::c_uint,
    pub if_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_nameindex() {
    assert_eq!(
        ::std::mem::size_of::<if_nameindex>(),
        16usize,
        concat!("Size of: ", stringify!(if_nameindex))
    );
    assert_eq!(
        ::std::mem::align_of::<if_nameindex>(),
        8usize,
        concat!("Alignment of ", stringify!(if_nameindex))
    );
    fn test_field_if_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_nameindex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(if_nameindex),
                "::",
                stringify!(if_index)
            )
        );
    }
    test_field_if_index();
    fn test_field_if_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<if_nameindex>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).if_name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(if_nameindex),
                "::",
                stringify!(if_name)
            )
        );
    }
    test_field_if_name();
}
extern "C" {
    pub fn if_nametoindex(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn if_indextoname(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn if_nameindex() -> *mut if_nameindex;
}
extern "C" {
    pub fn if_freenameindex(arg1: *mut if_nameindex);
}
pub type tcp_seq = __uint32_t;
pub type tcp_cc = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcphdr {
    pub th_sport: ::std::os::raw::c_ushort,
    pub th_dport: ::std::os::raw::c_ushort,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub th_flags: ::std::os::raw::c_uchar,
    pub th_win: ::std::os::raw::c_ushort,
    pub th_sum: ::std::os::raw::c_ushort,
    pub th_urp: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(
        ::std::mem::size_of::<tcphdr>(),
        20usize,
        concat!("Size of: ", stringify!(tcphdr))
    );
    assert_eq!(
        ::std::mem::align_of::<tcphdr>(),
        4usize,
        concat!("Alignment of ", stringify!(tcphdr))
    );
    fn test_field_th_sport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_sport) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_sport)
            )
        );
    }
    test_field_th_sport();
    fn test_field_th_dport() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_dport) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_dport)
            )
        );
    }
    test_field_th_dport();
    fn test_field_th_seq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_seq) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_seq)
            )
        );
    }
    test_field_th_seq();
    fn test_field_th_ack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_ack) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_ack)
            )
        );
    }
    test_field_th_ack();
    fn test_field_th_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_flags) as usize - ptr as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_flags)
            )
        );
    }
    test_field_th_flags();
    fn test_field_th_win() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_win) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_win)
            )
        );
    }
    test_field_th_win();
    fn test_field_th_sum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_sum) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_sum)
            )
        );
    }
    test_field_th_sum();
    fn test_field_th_urp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcphdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).th_urp) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(tcphdr),
                "::",
                stringify!(th_urp)
            )
        );
    }
    test_field_th_urp();
}
impl tcphdr {
    #[inline]
    pub fn th_x2(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn th_off(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        th_x2: ::std::os::raw::c_uint,
        th_off: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let th_x2: u32 = unsafe { ::std::mem::transmute(th_x2) };
            th_x2 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let th_off: u32 = unsafe { ::std::mem::transmute(th_off) };
            th_off as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcp_connection_info {
    pub tcpi_state: u_int8_t,
    pub tcpi_snd_wscale: u_int8_t,
    pub tcpi_rcv_wscale: u_int8_t,
    pub __pad1: u_int8_t,
    pub tcpi_options: u_int32_t,
    pub tcpi_flags: u_int32_t,
    pub tcpi_rto: u_int32_t,
    pub tcpi_maxseg: u_int32_t,
    pub tcpi_snd_ssthresh: u_int32_t,
    pub tcpi_snd_cwnd: u_int32_t,
    pub tcpi_snd_wnd: u_int32_t,
    pub tcpi_snd_sbbytes: u_int32_t,
    pub tcpi_rcv_wnd: u_int32_t,
    pub tcpi_rttcur: u_int32_t,
    pub tcpi_srtt: u_int32_t,
    pub tcpi_rttvar: u_int32_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub tcpi_txpackets: u_int64_t,
    pub tcpi_txbytes: u_int64_t,
    pub tcpi_txretransmitbytes: u_int64_t,
    pub tcpi_rxpackets: u_int64_t,
    pub tcpi_rxbytes: u_int64_t,
    pub tcpi_rxoutoforderbytes: u_int64_t,
    pub tcpi_txretransmitpackets: u_int64_t,
}
#[test]
fn bindgen_test_layout_tcp_connection_info() {
    assert_eq!(
        ::std::mem::size_of::<tcp_connection_info>(),
        112usize,
        concat!("Size of: ", stringify!(tcp_connection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tcp_connection_info>(),
        8usize,
        concat!("Alignment of ", stringify!(tcp_connection_info))
    );
    fn test_field_tcpi_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_state) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_state)
            )
        );
    }
    test_field_tcpi_state();
    fn test_field_tcpi_snd_wscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_wscale) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_wscale)
            )
        );
    }
    test_field_tcpi_snd_wscale();
    fn test_field_tcpi_rcv_wscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rcv_wscale) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rcv_wscale)
            )
        );
    }
    test_field_tcpi_rcv_wscale();
    fn test_field___pad1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(__pad1)
            )
        );
    }
    test_field___pad1();
    fn test_field_tcpi_options() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_options) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_options)
            )
        );
    }
    test_field_tcpi_options();
    fn test_field_tcpi_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_flags) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_flags)
            )
        );
    }
    test_field_tcpi_flags();
    fn test_field_tcpi_rto() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rto) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rto)
            )
        );
    }
    test_field_tcpi_rto();
    fn test_field_tcpi_maxseg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_maxseg) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_maxseg)
            )
        );
    }
    test_field_tcpi_maxseg();
    fn test_field_tcpi_snd_ssthresh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_ssthresh) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_ssthresh)
            )
        );
    }
    test_field_tcpi_snd_ssthresh();
    fn test_field_tcpi_snd_cwnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_cwnd) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_cwnd)
            )
        );
    }
    test_field_tcpi_snd_cwnd();
    fn test_field_tcpi_snd_wnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_wnd) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_wnd)
            )
        );
    }
    test_field_tcpi_snd_wnd();
    fn test_field_tcpi_snd_sbbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_snd_sbbytes) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_snd_sbbytes)
            )
        );
    }
    test_field_tcpi_snd_sbbytes();
    fn test_field_tcpi_rcv_wnd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rcv_wnd) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rcv_wnd)
            )
        );
    }
    test_field_tcpi_rcv_wnd();
    fn test_field_tcpi_rttcur() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rttcur) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rttcur)
            )
        );
    }
    test_field_tcpi_rttcur();
    fn test_field_tcpi_srtt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_srtt) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_srtt)
            )
        );
    }
    test_field_tcpi_srtt();
    fn test_field_tcpi_rttvar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rttvar) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rttvar)
            )
        );
    }
    test_field_tcpi_rttvar();
    fn test_field_tcpi_txpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txpackets) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txpackets)
            )
        );
    }
    test_field_tcpi_txpackets();
    fn test_field_tcpi_txbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txbytes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txbytes)
            )
        );
    }
    test_field_tcpi_txbytes();
    fn test_field_tcpi_txretransmitbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txretransmitbytes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txretransmitbytes)
            )
        );
    }
    test_field_tcpi_txretransmitbytes();
    fn test_field_tcpi_rxpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxpackets) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxpackets)
            )
        );
    }
    test_field_tcpi_rxpackets();
    fn test_field_tcpi_rxbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxbytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxbytes)
            )
        );
    }
    test_field_tcpi_rxbytes();
    fn test_field_tcpi_rxoutoforderbytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_rxoutoforderbytes) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_rxoutoforderbytes)
            )
        );
    }
    test_field_tcpi_rxoutoforderbytes();
    fn test_field_tcpi_txretransmitpackets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<tcp_connection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcpi_txretransmitpackets) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(tcp_connection_info),
                "::",
                stringify!(tcpi_txretransmitpackets)
            )
        );
    }
    test_field_tcpi_txretransmitpackets();
}
impl tcp_connection_info {
    #[inline]
    pub fn tcpi_tfo_cookie_req(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_req(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_loss(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_loss(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_sent(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_sent(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_acked(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_acked(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_syn_data_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_syn_data_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_req_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_req_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_sent(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_sent(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_invalid(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_invalid(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_cookie_wrong(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_cookie_wrong(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_no_cookie_rcv(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_no_cookie_rcv(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_heuristics_disable(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_heuristics_disable(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_send_blackhole(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_send_blackhole(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_recv_blackhole(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_recv_blackhole(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_tfo_onebyte_proxy(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tcpi_tfo_onebyte_proxy(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pad2(&self) -> u_int32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 17u8) as u32) }
    }
    #[inline]
    pub fn set___pad2(&mut self, val: u_int32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 17u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_tfo_cookie_req: u_int32_t,
        tcpi_tfo_cookie_rcv: u_int32_t,
        tcpi_tfo_syn_loss: u_int32_t,
        tcpi_tfo_syn_data_sent: u_int32_t,
        tcpi_tfo_syn_data_acked: u_int32_t,
        tcpi_tfo_syn_data_rcv: u_int32_t,
        tcpi_tfo_cookie_req_rcv: u_int32_t,
        tcpi_tfo_cookie_sent: u_int32_t,
        tcpi_tfo_cookie_invalid: u_int32_t,
        tcpi_tfo_cookie_wrong: u_int32_t,
        tcpi_tfo_no_cookie_rcv: u_int32_t,
        tcpi_tfo_heuristics_disable: u_int32_t,
        tcpi_tfo_send_blackhole: u_int32_t,
        tcpi_tfo_recv_blackhole: u_int32_t,
        tcpi_tfo_onebyte_proxy: u_int32_t,
        __pad2: u_int32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tcpi_tfo_cookie_req: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_req) };
            tcpi_tfo_cookie_req as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tcpi_tfo_cookie_rcv: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_rcv) };
            tcpi_tfo_cookie_rcv as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tcpi_tfo_syn_loss: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_syn_loss) };
            tcpi_tfo_syn_loss as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let tcpi_tfo_syn_data_sent: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_sent) };
            tcpi_tfo_syn_data_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let tcpi_tfo_syn_data_acked: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_acked) };
            tcpi_tfo_syn_data_acked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let tcpi_tfo_syn_data_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_syn_data_rcv) };
            tcpi_tfo_syn_data_rcv as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let tcpi_tfo_cookie_req_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_req_rcv) };
            tcpi_tfo_cookie_req_rcv as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let tcpi_tfo_cookie_sent: u32 = unsafe { ::std::mem::transmute(tcpi_tfo_cookie_sent) };
            tcpi_tfo_cookie_sent as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tcpi_tfo_cookie_invalid: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_invalid) };
            tcpi_tfo_cookie_invalid as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let tcpi_tfo_cookie_wrong: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_cookie_wrong) };
            tcpi_tfo_cookie_wrong as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let tcpi_tfo_no_cookie_rcv: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_no_cookie_rcv) };
            tcpi_tfo_no_cookie_rcv as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let tcpi_tfo_heuristics_disable: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_heuristics_disable) };
            tcpi_tfo_heuristics_disable as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let tcpi_tfo_send_blackhole: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_send_blackhole) };
            tcpi_tfo_send_blackhole as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tcpi_tfo_recv_blackhole: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_recv_blackhole) };
            tcpi_tfo_recv_blackhole as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let tcpi_tfo_onebyte_proxy: u32 =
                unsafe { ::std::mem::transmute(tcpi_tfo_onebyte_proxy) };
            tcpi_tfo_onebyte_proxy as u64
        });
        __bindgen_bitfield_unit.set(15usize, 17u8, {
            let __pad2: u32 = unsafe { ::std::mem::transmute(__pad2) };
            __pad2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ttysize {
    pub ts_lines: ::std::os::raw::c_ushort,
    pub ts_cols: ::std::os::raw::c_ushort,
    pub ts_xxx: ::std::os::raw::c_ushort,
    pub ts_yyy: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_ttysize() {
    assert_eq!(
        ::std::mem::size_of::<ttysize>(),
        8usize,
        concat!("Size of: ", stringify!(ttysize))
    );
    assert_eq!(
        ::std::mem::align_of::<ttysize>(),
        2usize,
        concat!("Alignment of ", stringify!(ttysize))
    );
    fn test_field_ts_lines() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_lines) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_lines)
            )
        );
    }
    test_field_ts_lines();
    fn test_field_ts_cols() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_cols) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_cols)
            )
        );
    }
    test_field_ts_cols();
    fn test_field_ts_xxx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_xxx) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_xxx)
            )
        );
    }
    test_field_ts_xxx();
    fn test_field_ts_yyy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ttysize>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ts_yyy) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(ttysize),
                "::",
                stringify!(ts_yyy)
            )
        );
    }
    test_field_ts_yyy();
}
extern "C" {
    pub fn ioctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mlockall(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munlockall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mlock(arg1: *const ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mmap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
        arg5: ::std::os::raw::c_int,
        arg6: off_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mprotect(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msync(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munlock(arg1: *const ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn munmap(arg1: *mut ::std::os::raw::c_void, arg2: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shm_open(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shm_unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn madvise(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mincore(
        arg1: *const ::std::os::raw::c_void,
        arg2: size_t,
        arg3: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn minherit(
        arg1: *mut ::std::os::raw::c_void,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ostat {
    pub st_dev: __uint16_t,
    pub st_ino: ino_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_uid: __uint16_t,
    pub st_gid: __uint16_t,
    pub st_rdev: __uint16_t,
    pub st_size: __int32_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_blksize: __int32_t,
    pub st_blocks: __int32_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
}
#[test]
fn bindgen_test_layout_ostat() {
    assert_eq!(
        ::std::mem::size_of::<ostat>(),
        96usize,
        concat!("Size of: ", stringify!(ostat))
    );
    assert_eq!(
        ::std::mem::align_of::<ostat>(),
        8usize,
        concat!("Alignment of ", stringify!(ostat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_atimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_atimespec)
            )
        );
    }
    test_field_st_atimespec();
    fn test_field_st_mtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_mtimespec)
            )
        );
    }
    test_field_st_mtimespec();
    fn test_field_st_ctimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_ctimespec)
            )
        );
    }
    test_field_st_ctimespec();
    fn test_field_st_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_blksize)
            )
        );
    }
    test_field_st_blksize();
    fn test_field_st_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_blocks)
            )
        );
    }
    test_field_st_blocks();
    fn test_field_st_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_flags)
            )
        );
    }
    test_field_st_flags();
    fn test_field_st_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ostat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(ostat),
                "::",
                stringify!(st_gen)
            )
        );
    }
    test_field_st_gen();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: dev_t,
    pub st_mode: mode_t,
    pub st_nlink: nlink_t,
    pub st_ino: __darwin_ino64_t,
    pub st_uid: uid_t,
    pub st_gid: gid_t,
    pub st_rdev: dev_t,
    pub st_atimespec: timespec,
    pub st_mtimespec: timespec,
    pub st_ctimespec: timespec,
    pub st_birthtimespec: timespec,
    pub st_size: off_t,
    pub st_blocks: blkcnt_t,
    pub st_blksize: blksize_t,
    pub st_flags: __uint32_t,
    pub st_gen: __uint32_t,
    pub st_lspare: __int32_t,
    pub st_qspare: [__int64_t; 2usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    fn test_field_st_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_dev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_dev)
            )
        );
    }
    test_field_st_dev();
    fn test_field_st_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mode)
            )
        );
    }
    test_field_st_mode();
    fn test_field_st_nlink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_nlink) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_nlink)
            )
        );
    }
    test_field_st_nlink();
    fn test_field_st_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ino) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ino)
            )
        );
    }
    test_field_st_ino();
    fn test_field_st_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_uid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_uid)
            )
        );
    }
    test_field_st_uid();
    fn test_field_st_gid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gid)
            )
        );
    }
    test_field_st_gid();
    fn test_field_st_rdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_rdev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_rdev)
            )
        );
    }
    test_field_st_rdev();
    fn test_field_st_atimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_atimespec) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_atimespec)
            )
        );
    }
    test_field_st_atimespec();
    fn test_field_st_mtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_mtimespec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_mtimespec)
            )
        );
    }
    test_field_st_mtimespec();
    fn test_field_st_ctimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_ctimespec) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_ctimespec)
            )
        );
    }
    test_field_st_ctimespec();
    fn test_field_st_birthtimespec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_birthtimespec) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_birthtimespec)
            )
        );
    }
    test_field_st_birthtimespec();
    fn test_field_st_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_size) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_size)
            )
        );
    }
    test_field_st_size();
    fn test_field_st_blocks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blocks) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blocks)
            )
        );
    }
    test_field_st_blocks();
    fn test_field_st_blksize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_blksize) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_blksize)
            )
        );
    }
    test_field_st_blksize();
    fn test_field_st_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_flags) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_flags)
            )
        );
    }
    test_field_st_flags();
    fn test_field_st_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_gen) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_gen)
            )
        );
    }
    test_field_st_gen();
    fn test_field_st_lspare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_lspare) as usize - ptr as usize
            },
            124usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_lspare)
            )
        );
    }
    test_field_st_lspare();
    fn test_field_st_qspare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).st_qspare) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(stat),
                "::",
                stringify!(st_qspare)
            )
        );
    }
    test_field_st_qspare();
}
extern "C" {
    pub fn chmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(arg1: ::std::os::raw::c_int, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(arg1: ::std::os::raw::c_int, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdir(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat(arg1: *const ::std::os::raw::c_char, arg2: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(arg1: mode_t) -> mode_t;
}
extern "C" {
    pub fn fchmodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut stat,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: mode_t,
        arg4: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmodx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchflags(arg1: ::std::os::raw::c_int, arg2: __uint32_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodx_np(arg1: ::std::os::raw::c_int, arg2: filesec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchflags(arg1: *const ::std::os::raw::c_char, arg2: __uint32_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(arg1: *const ::std::os::raw::c_char, arg2: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstatx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirx_np(arg1: *const ::std::os::raw::c_char, arg2: filesec_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifox_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn statx_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut stat,
        arg3: filesec_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umaskx_np(arg1: filesec_t) -> ::std::os::raw::c_int;
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = ::std::os::raw::c_uint;
extern "C" {
    pub fn readv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn writev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
    ) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        arg1: ::std::os::raw::c_int,
        arg2: *const iovec,
        arg3: ::std::os::raw::c_int,
        arg4: off_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_un {
    pub sun_len: ::std::os::raw::c_uchar,
    pub sun_family: sa_family_t,
    pub sun_path: [::std::os::raw::c_char; 104usize],
}
#[test]
fn bindgen_test_layout_sockaddr_un() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_un>(),
        106usize,
        concat!("Size of: ", stringify!(sockaddr_un))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_un>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr_un))
    );
    fn test_field_sun_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_len)
            )
        );
    }
    test_field_sun_len();
    fn test_field_sun_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_family) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_family)
            )
        );
    }
    test_field_sun_family();
    fn test_field_sun_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<sockaddr_un>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sun_path) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(sockaddr_un),
                "::",
                stringify!(sun_path)
            )
        );
    }
    test_field_sun_path();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct waitq_set {
    _unused: [u8; 0],
}
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
pub type au_ctlmode_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid {
    pub port: dev_t,
    pub machine: u_int32_t,
}
#[test]
fn bindgen_test_layout_au_tid() {
    assert_eq!(
        ::std::mem::size_of::<au_tid>(),
        8usize,
        concat!("Size of: ", stringify!(au_tid))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid))
    );
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_machine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).machine) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid),
                "::",
                stringify!(machine)
            )
        );
    }
    test_field_machine();
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_tid_addr {
    pub at_port: dev_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
#[test]
fn bindgen_test_layout_au_tid_addr() {
    assert_eq!(
        ::std::mem::size_of::<au_tid_addr>(),
        24usize,
        concat!("Size of: ", stringify!(au_tid_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<au_tid_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(au_tid_addr))
    );
    fn test_field_at_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_port)
            )
        );
    }
    test_field_at_port();
    fn test_field_at_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_type) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_type)
            )
        );
    }
    test_field_at_type();
    fn test_field_at_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_tid_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_addr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_tid_addr),
                "::",
                stringify!(at_addr)
            )
        );
    }
    test_field_at_addr();
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_mask {
    pub am_success: ::std::os::raw::c_uint,
    pub am_failure: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_au_mask() {
    assert_eq!(
        ::std::mem::size_of::<au_mask>(),
        8usize,
        concat!("Size of: ", stringify!(au_mask))
    );
    assert_eq!(
        ::std::mem::align_of::<au_mask>(),
        4usize,
        concat!("Alignment of ", stringify!(au_mask))
    );
    fn test_field_am_success() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_mask>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).am_success) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_mask),
                "::",
                stringify!(am_success)
            )
        );
    }
    test_field_am_success();
    fn test_field_am_failure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_mask>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).am_failure) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_mask),
                "::",
                stringify!(am_failure)
            )
        );
    }
    test_field_am_failure();
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditinfo() {
    assert_eq!(
        ::std::mem::size_of::<auditinfo>(),
        24usize,
        concat!("Size of: ", stringify!(auditinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditinfo))
    );
    fn test_field_ai_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_auid)
            )
        );
    }
    test_field_ai_auid();
    fn test_field_ai_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_mask)
            )
        );
    }
    test_field_ai_mask();
    fn test_field_ai_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_termid)
            )
        );
    }
    test_field_ai_termid();
    fn test_field_ai_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo),
                "::",
                stringify!(ai_asid)
            )
        );
    }
    test_field_ai_asid();
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditinfo_addr() {
    assert_eq!(
        ::std::mem::size_of::<auditinfo_addr>(),
        48usize,
        concat!("Size of: ", stringify!(auditinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditinfo_addr))
    );
    fn test_field_ai_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_auid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_auid)
            )
        );
    }
    test_field_ai_auid();
    fn test_field_ai_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_mask) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_mask)
            )
        );
    }
    test_field_ai_mask();
    fn test_field_ai_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_termid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_termid)
            )
        );
    }
    test_field_ai_termid();
    fn test_field_ai_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_asid) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_asid)
            )
        );
    }
    test_field_ai_asid();
    fn test_field_ai_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ai_flags) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(auditinfo_addr),
                "::",
                stringify!(ai_flags)
            )
        );
    }
    test_field_ai_flags();
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditpinfo() {
    assert_eq!(
        ::std::mem::size_of::<auditpinfo>(),
        28usize,
        concat!("Size of: ", stringify!(auditpinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(auditpinfo))
    );
    fn test_field_ap_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_pid)
            )
        );
    }
    test_field_ap_pid();
    fn test_field_ap_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_auid)
            )
        );
    }
    test_field_ap_auid();
    fn test_field_ap_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_mask)
            )
        );
    }
    test_field_ap_mask();
    fn test_field_ap_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_termid)
            )
        );
    }
    test_field_ap_termid();
    fn test_field_ap_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo),
                "::",
                stringify!(ap_asid)
            )
        );
    }
    test_field_ap_asid();
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditpinfo_addr() {
    assert_eq!(
        ::std::mem::size_of::<auditpinfo_addr>(),
        56usize,
        concat!("Size of: ", stringify!(auditpinfo_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<auditpinfo_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(auditpinfo_addr))
    );
    fn test_field_ap_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_pid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_pid)
            )
        );
    }
    test_field_ap_pid();
    fn test_field_ap_auid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_auid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_auid)
            )
        );
    }
    test_field_ap_auid();
    fn test_field_ap_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_mask)
            )
        );
    }
    test_field_ap_mask();
    fn test_field_ap_termid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_termid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_termid)
            )
        );
    }
    test_field_ap_termid();
    fn test_field_ap_asid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_asid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_asid)
            )
        );
    }
    test_field_ap_asid();
    fn test_field_ap_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<auditpinfo_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ap_flags) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(auditpinfo_addr),
                "::",
                stringify!(ap_flags)
            )
        );
    }
    test_field_ap_flags();
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
#[test]
fn bindgen_test_layout_au_session() {
    assert_eq!(
        ::std::mem::size_of::<au_session>(),
        16usize,
        concat!("Size of: ", stringify!(au_session))
    );
    assert_eq!(
        ::std::mem::align_of::<au_session>(),
        8usize,
        concat!("Alignment of ", stringify!(au_session))
    );
    fn test_field_as_aia_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_session>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_aia_p) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_session),
                "::",
                stringify!(as_aia_p)
            )
        );
    }
    test_field_as_aia_p();
    fn test_field_as_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_session>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_session),
                "::",
                stringify!(as_mask)
            )
        );
    }
    test_field_as_mask();
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_expire_after {
    pub age: time_t,
    pub size: size_t,
    pub op_type: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_au_expire_after() {
    assert_eq!(
        ::std::mem::size_of::<au_expire_after>(),
        24usize,
        concat!("Size of: ", stringify!(au_expire_after))
    );
    assert_eq!(
        ::std::mem::align_of::<au_expire_after>(),
        8usize,
        concat!("Alignment of ", stringify!(au_expire_after))
    );
    fn test_field_age() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).age) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(age)
            )
        );
    }
    test_field_age();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_op_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_expire_after>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).op_type) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(au_expire_after),
                "::",
                stringify!(op_type)
            )
        );
    }
    test_field_op_type();
}
pub type au_expire_after_t = au_expire_after;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_qctrl {
    pub aq_hiwater: ::std::os::raw::c_int,
    pub aq_lowater: ::std::os::raw::c_int,
    pub aq_bufsz: ::std::os::raw::c_int,
    pub aq_delay: ::std::os::raw::c_int,
    pub aq_minfree: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_au_qctrl() {
    assert_eq!(
        ::std::mem::size_of::<au_qctrl>(),
        20usize,
        concat!("Size of: ", stringify!(au_qctrl))
    );
    assert_eq!(
        ::std::mem::align_of::<au_qctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(au_qctrl))
    );
    fn test_field_aq_hiwater() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_hiwater) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_hiwater)
            )
        );
    }
    test_field_aq_hiwater();
    fn test_field_aq_lowater() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_lowater) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_lowater)
            )
        );
    }
    test_field_aq_lowater();
    fn test_field_aq_bufsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_bufsz) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_bufsz)
            )
        );
    }
    test_field_aq_bufsz();
    fn test_field_aq_delay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_delay) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_delay)
            )
        );
    }
    test_field_aq_delay();
    fn test_field_aq_minfree() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_qctrl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aq_minfree) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(au_qctrl),
                "::",
                stringify!(aq_minfree)
            )
        );
    }
    test_field_aq_minfree();
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_stat {
    pub as_version: ::std::os::raw::c_uint,
    pub as_numevent: ::std::os::raw::c_uint,
    pub as_generated: ::std::os::raw::c_int,
    pub as_nonattrib: ::std::os::raw::c_int,
    pub as_kernel: ::std::os::raw::c_int,
    pub as_audit: ::std::os::raw::c_int,
    pub as_auditctl: ::std::os::raw::c_int,
    pub as_enqueue: ::std::os::raw::c_int,
    pub as_written: ::std::os::raw::c_int,
    pub as_wblocked: ::std::os::raw::c_int,
    pub as_rblocked: ::std::os::raw::c_int,
    pub as_dropped: ::std::os::raw::c_int,
    pub as_totalsize: ::std::os::raw::c_int,
    pub as_memused: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_audit_stat() {
    assert_eq!(
        ::std::mem::size_of::<audit_stat>(),
        56usize,
        concat!("Size of: ", stringify!(audit_stat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_stat>(),
        4usize,
        concat!("Alignment of ", stringify!(audit_stat))
    );
    fn test_field_as_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_version)
            )
        );
    }
    test_field_as_version();
    fn test_field_as_numevent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_numevent) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_numevent)
            )
        );
    }
    test_field_as_numevent();
    fn test_field_as_generated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_generated) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_generated)
            )
        );
    }
    test_field_as_generated();
    fn test_field_as_nonattrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_nonattrib) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_nonattrib)
            )
        );
    }
    test_field_as_nonattrib();
    fn test_field_as_kernel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_kernel) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_kernel)
            )
        );
    }
    test_field_as_kernel();
    fn test_field_as_audit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_audit) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_audit)
            )
        );
    }
    test_field_as_audit();
    fn test_field_as_auditctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_auditctl) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_auditctl)
            )
        );
    }
    test_field_as_auditctl();
    fn test_field_as_enqueue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_enqueue) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_enqueue)
            )
        );
    }
    test_field_as_enqueue();
    fn test_field_as_written() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_written) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_written)
            )
        );
    }
    test_field_as_written();
    fn test_field_as_wblocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_wblocked) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_wblocked)
            )
        );
    }
    test_field_as_wblocked();
    fn test_field_as_rblocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_rblocked) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_rblocked)
            )
        );
    }
    test_field_as_rblocked();
    fn test_field_as_dropped() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_dropped) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_dropped)
            )
        );
    }
    test_field_as_dropped();
    fn test_field_as_totalsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_totalsize) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_totalsize)
            )
        );
    }
    test_field_as_totalsize();
    fn test_field_as_memused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_stat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_memused) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_stat),
                "::",
                stringify!(as_memused)
            )
        );
    }
    test_field_as_memused();
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
#[test]
fn bindgen_test_layout_audit_fstat() {
    assert_eq!(
        ::std::mem::size_of::<audit_fstat>(),
        16usize,
        concat!("Size of: ", stringify!(audit_fstat))
    );
    assert_eq!(
        ::std::mem::align_of::<audit_fstat>(),
        8usize,
        concat!("Alignment of ", stringify!(audit_fstat))
    );
    fn test_field_af_filesz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_fstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).af_filesz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_fstat),
                "::",
                stringify!(af_filesz)
            )
        );
    }
    test_field_af_filesz();
    fn test_field_af_currsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<audit_fstat>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).af_currsz) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(audit_fstat),
                "::",
                stringify!(af_currsz)
            )
        );
    }
    test_field_af_currsz();
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
#[test]
fn bindgen_test_layout_au_evclass_map() {
    assert_eq!(
        ::std::mem::size_of::<au_evclass_map>(),
        8usize,
        concat!("Size of: ", stringify!(au_evclass_map))
    );
    assert_eq!(
        ::std::mem::align_of::<au_evclass_map>(),
        4usize,
        concat!("Alignment of ", stringify!(au_evclass_map))
    );
    fn test_field_ec_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_evclass_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec_number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(au_evclass_map),
                "::",
                stringify!(ec_number)
            )
        );
    }
    test_field_ec_number();
    fn test_field_ec_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<au_evclass_map>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec_class) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(au_evclass_map),
                "::",
                stringify!(ec_class)
            )
        );
    }
    test_field_ec_class();
}
pub type au_evclass_map_t = au_evclass_map;
extern "C" {
    pub fn audit(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditon(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn auditctl(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getauid(arg1: *mut au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setauid(arg1: *const au_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit_addr(
        arg1: *mut auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit_addr(
        arg1: *const auditinfo_addr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getaudit(arg1: *mut auditinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setaudit(arg1: *const auditinfo) -> ::std::os::raw::c_int;
}
pub type boolean_t = ::std::os::raw::c_int;
pub type natural_t = __darwin_natural_t;
pub type integer_t = ::std::os::raw::c_int;
pub type vm_offset_t = usize;
pub type vm_size_t = usize;
pub type mach_vm_address_t = u64;
pub type mach_vm_offset_t = u64;
pub type mach_vm_size_t = u64;
pub type vm_map_offset_t = u64;
pub type vm_map_address_t = u64;
pub type vm_map_size_t = u64;
pub type vm32_offset_t = u32;
pub type vm32_address_t = u32;
pub type vm32_size_t = u32;
pub type mach_port_context_t = vm_offset_t;
pub type mach_port_name_t = natural_t;
pub type mach_port_name_array_t = *mut mach_port_name_t;
pub type mach_port_array_t = *mut mach_port_t;
pub type mach_port_right_t = natural_t;
pub type mach_port_type_t = natural_t;
pub type mach_port_type_array_t = *mut mach_port_type_t;
pub type mach_port_urefs_t = natural_t;
pub type mach_port_delta_t = integer_t;
pub type mach_port_seqno_t = natural_t;
pub type mach_port_mscount_t = natural_t;
pub type mach_port_msgcount_t = natural_t;
pub type mach_port_rights_t = natural_t;
pub type mach_port_srights_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_status {
    pub mps_pset: mach_port_rights_t,
    pub mps_seqno: mach_port_seqno_t,
    pub mps_mscount: mach_port_mscount_t,
    pub mps_qlimit: mach_port_msgcount_t,
    pub mps_msgcount: mach_port_msgcount_t,
    pub mps_sorights: mach_port_rights_t,
    pub mps_srights: boolean_t,
    pub mps_pdrequest: boolean_t,
    pub mps_nsrequest: boolean_t,
    pub mps_flags: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_status() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_status>(),
        40usize,
        concat!("Size of: ", stringify!(mach_port_status))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_status>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_status))
    );
    fn test_field_mps_pset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pset)
            )
        );
    }
    test_field_mps_pset();
    fn test_field_mps_seqno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_seqno) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_seqno)
            )
        );
    }
    test_field_mps_seqno();
    fn test_field_mps_mscount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_mscount) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_mscount)
            )
        );
    }
    test_field_mps_mscount();
    fn test_field_mps_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_qlimit) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_qlimit)
            )
        );
    }
    test_field_mps_qlimit();
    fn test_field_mps_msgcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_msgcount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_msgcount)
            )
        );
    }
    test_field_mps_msgcount();
    fn test_field_mps_sorights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_sorights) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_sorights)
            )
        );
    }
    test_field_mps_sorights();
    fn test_field_mps_srights() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_srights) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_srights)
            )
        );
    }
    test_field_mps_srights();
    fn test_field_mps_pdrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_pdrequest) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_pdrequest)
            )
        );
    }
    test_field_mps_pdrequest();
    fn test_field_mps_nsrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_nsrequest) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_nsrequest)
            )
        );
    }
    test_field_mps_nsrequest();
    fn test_field_mps_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mps_flags) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_status),
                "::",
                stringify!(mps_flags)
            )
        );
    }
    test_field_mps_flags();
}
pub type mach_port_status_t = mach_port_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_limits {
    pub mpl_qlimit: mach_port_msgcount_t,
}
#[test]
fn bindgen_test_layout_mach_port_limits() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_limits>(),
        4usize,
        concat!("Size of: ", stringify!(mach_port_limits))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_limits>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_limits))
    );
    fn test_field_mpl_qlimit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_limits>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl_qlimit) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_limits),
                "::",
                stringify!(mpl_qlimit)
            )
        );
    }
    test_field_mpl_qlimit();
}
pub type mach_port_limits_t = mach_port_limits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_info_ext {
    pub mpie_status: mach_port_status_t,
    pub mpie_boost_cnt: mach_port_msgcount_t,
    pub reserved: [u32; 6usize],
}
#[test]
fn bindgen_test_layout_mach_port_info_ext() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_info_ext>(),
        68usize,
        concat!("Size of: ", stringify!(mach_port_info_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_info_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_info_ext))
    );
    fn test_field_mpie_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_status)
            )
        );
    }
    test_field_mpie_status();
    fn test_field_mpie_boost_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpie_boost_cnt) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(mpie_boost_cnt)
            )
        );
    }
    test_field_mpie_boost_cnt();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_info_ext>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_info_ext),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type mach_port_info_ext_t = mach_port_info_ext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_guard_info {
    pub mpgi_guard: u64,
}
#[test]
fn bindgen_test_layout_mach_port_guard_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_guard_info>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_guard_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_guard_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_guard_info))
    );
    fn test_field_mpgi_guard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_guard_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpgi_guard) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_guard_info),
                "::",
                stringify!(mpgi_guard)
            )
        );
    }
    test_field_mpgi_guard();
}
pub type mach_port_guard_info_t = mach_port_guard_info;
pub type mach_port_info_t = *mut integer_t;
pub type mach_port_flavor_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_port_qos {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub len: natural_t,
}
#[test]
fn bindgen_test_layout_mach_port_qos() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_qos>(),
        8usize,
        concat!("Size of: ", stringify!(mach_port_qos))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_qos>(),
        4usize,
        concat!("Alignment of ", stringify!(mach_port_qos))
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_qos>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_qos),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
}
impl mach_port_qos {
    #[inline]
    pub fn name(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_name(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn prealloc(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_prealloc(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad1(&self) -> boolean_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pad1(&mut self, val: boolean_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        name: ::std::os::raw::c_uint,
        prealloc: ::std::os::raw::c_uint,
        pad1: boolean_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let name: u32 = unsafe { ::std::mem::transmute(name) };
            name as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let prealloc: u32 = unsafe { ::std::mem::transmute(prealloc) };
            prealloc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let pad1: u32 = unsafe { ::std::mem::transmute(pad1) };
            pad1 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type mach_port_qos_t = mach_port_qos;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mach_service_port_info {
    pub mspi_string_name: [::std::os::raw::c_char; 255usize],
    pub mspi_domain_type: u8,
}
#[test]
fn bindgen_test_layout_mach_service_port_info() {
    assert_eq!(
        ::std::mem::size_of::<mach_service_port_info>(),
        256usize,
        concat!("Size of: ", stringify!(mach_service_port_info))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_service_port_info>(),
        1usize,
        concat!("Alignment of ", stringify!(mach_service_port_info))
    );
    fn test_field_mspi_string_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_string_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_string_name)
            )
        );
    }
    test_field_mspi_string_name();
    fn test_field_mspi_domain_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_service_port_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mspi_domain_type) as usize - ptr as usize
            },
            255usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_service_port_info),
                "::",
                stringify!(mspi_domain_type)
            )
        );
    }
    test_field_mspi_domain_type();
}
pub type mach_service_port_info_data_t = mach_service_port_info;
pub type mach_service_port_info_t = *mut mach_service_port_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mach_port_options {
    pub flags: u32,
    pub mpl: mach_port_limits_t,
    pub __bindgen_anon_1: mach_port_options__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mach_port_options__bindgen_ty_1 {
    pub reserved: [u64; 2usize],
    pub work_interval_port: mach_port_name_t,
    pub service_port_info: mach_service_port_info_t,
    pub service_port_name: mach_port_name_t,
}
#[test]
fn bindgen_test_layout_mach_port_options__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(mach_port_options__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options__bindgen_ty_1))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_work_interval_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).work_interval_port) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(work_interval_port)
            )
        );
    }
    test_field_work_interval_port();
    fn test_field_service_port_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_info)
            )
        );
    }
    test_field_service_port_info();
    fn test_field_service_port_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).service_port_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options__bindgen_ty_1),
                "::",
                stringify!(service_port_name)
            )
        );
    }
    test_field_service_port_name();
}
#[test]
fn bindgen_test_layout_mach_port_options() {
    assert_eq!(
        ::std::mem::size_of::<mach_port_options>(),
        24usize,
        concat!("Size of: ", stringify!(mach_port_options))
    );
    assert_eq!(
        ::std::mem::align_of::<mach_port_options>(),
        8usize,
        concat!("Alignment of ", stringify!(mach_port_options))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_mpl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mach_port_options>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mpl) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(mach_port_options),
                "::",
                stringify!(mpl)
            )
        );
    }
    test_field_mpl();
}
pub type mach_port_options_t = mach_port_options;
pub type mach_port_options_ptr_t = *mut mach_port_options_t;
pub const mach_port_guard_exception_codes_kGUARD_EXC_DESTROY: mach_port_guard_exception_codes = 1;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS: mach_port_guard_exception_codes = 2;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_OPTIONS:
    mach_port_guard_exception_codes = 3;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SET_CONTEXT: mach_port_guard_exception_codes =
    4;
pub const mach_port_guard_exception_codes_kGUARD_EXC_UNGUARDED: mach_port_guard_exception_codes = 8;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INCORRECT_GUARD:
    mach_port_guard_exception_codes = 16;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE: mach_port_guard_exception_codes =
    32;
pub const mach_port_guard_exception_codes_kGUARD_EXC_STRICT_REPLY: mach_port_guard_exception_codes =
    64;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MSG_FILTERED: mach_port_guard_exception_codes =
    128;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_RIGHT:
    mach_port_guard_exception_codes = 256;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_NAME: mach_port_guard_exception_codes =
    512;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_VALUE:
    mach_port_guard_exception_codes = 1024;
pub const mach_port_guard_exception_codes_kGUARD_EXC_INVALID_ARGUMENT:
    mach_port_guard_exception_codes = 2048;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RIGHT_EXISTS: mach_port_guard_exception_codes =
    4096;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_NO_SPACE:
    mach_port_guard_exception_codes = 8192;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_FAILURE: mach_port_guard_exception_codes =
    16384;
pub const mach_port_guard_exception_codes_kGUARD_EXC_KERN_RESOURCE:
    mach_port_guard_exception_codes = 32768;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_REPLY:
    mach_port_guard_exception_codes = 65536;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_VOUCHER:
    mach_port_guard_exception_codes = 131072;
pub const mach_port_guard_exception_codes_kGUARD_EXC_SEND_INVALID_RIGHT:
    mach_port_guard_exception_codes = 262144;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_INVALID_NAME:
    mach_port_guard_exception_codes = 524288;
pub const mach_port_guard_exception_codes_kGUARD_EXC_RCV_GUARDED_DESC:
    mach_port_guard_exception_codes = 1048576;
pub const mach_port_guard_exception_codes_kGUARD_EXC_MOD_REFS_NON_FATAL:
    mach_port_guard_exception_codes = 2097152;
pub const mach_port_guard_exception_codes_kGUARD_EXC_IMMOVABLE_NON_FATAL:
    mach_port_guard_exception_codes = 4194304;
pub const mach_port_guard_exception_codes_kGUARD_EXC_REQUIRE_REPLY_PORT_SEMANTICS:
    mach_port_guard_exception_codes = 8388608;
pub type mach_port_guard_exception_codes = ::std::os::raw::c_uint;
extern "C" {
    pub fn audit_session_self() -> mach_port_name_t;
}
extern "C" {
    pub fn audit_session_join(port: mach_port_name_t) -> au_asid_t;
}
extern "C" {
    pub fn audit_session_port(
        asid: au_asid_t,
        portname: *mut mach_port_name_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct label {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct posix_cred {
    _unused: [u8; 0],
}
pub type kauth_cred_t = *mut ucred;
pub type posix_cred_t = *mut posix_cred;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::std::os::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_xucred() {
    assert_eq!(
        ::std::mem::size_of::<xucred>(),
        76usize,
        concat!("Size of: ", stringify!(xucred))
    );
    assert_eq!(
        ::std::mem::align_of::<xucred>(),
        4usize,
        concat!("Alignment of ", stringify!(xucred))
    );
    fn test_field_cr_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_version) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_version)
            )
        );
    }
    test_field_cr_version();
    fn test_field_cr_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_uid)
            )
        );
    }
    test_field_cr_uid();
    fn test_field_cr_ngroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ngroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_ngroups)
            )
        );
    }
    test_field_cr_ngroups();
    fn test_field_cr_groups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_groups) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(xucred),
                "::",
                stringify!(cr_groups)
            )
        );
    }
    test_field_cr_groups();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmspace {
    pub dummy: i32,
    pub dummy2: caddr_t,
    pub dummy3: [i32; 5usize],
    pub dummy4: [caddr_t; 3usize],
}
#[test]
fn bindgen_test_layout_vmspace() {
    assert_eq!(
        ::std::mem::size_of::<vmspace>(),
        64usize,
        concat!("Size of: ", stringify!(vmspace))
    );
    assert_eq!(
        ::std::mem::align_of::<vmspace>(),
        8usize,
        concat!("Alignment of ", stringify!(vmspace))
    );
    fn test_field_dummy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy)
            )
        );
    }
    test_field_dummy();
    fn test_field_dummy2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy2)
            )
        );
    }
    test_field_dummy2();
    fn test_field_dummy3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy3)
            )
        );
    }
    test_field_dummy3();
    fn test_field_dummy4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vmspace>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(vmspace),
                "::",
                stringify!(dummy4)
            )
        );
    }
    test_field_dummy4();
}
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct kevent {
    pub ident: usize,
    pub filter: i16,
    pub flags: u16,
    pub fflags: u32,
    pub data: isize,
    pub udata: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_kevent() {
    assert_eq!(
        ::std::mem::size_of::<kevent>(),
        32usize,
        concat!("Size of: ", stringify!(kevent))
    );
    assert_eq!(
        ::std::mem::align_of::<kevent>(),
        4usize,
        concat!("Alignment of ", stringify!(kevent))
    );
    fn test_field_ident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(ident)
            )
        );
    }
    test_field_ident();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_fflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fflags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(fflags)
            )
        );
    }
    test_field_fflags();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_udata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).udata) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent),
                "::",
                stringify!(udata)
            )
        );
    }
    test_field_udata();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kevent64_s {
    pub ident: u64,
    pub filter: i16,
    pub flags: u16,
    pub fflags: u32,
    pub data: i64,
    pub udata: u64,
    pub ext: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_kevent64_s() {
    assert_eq!(
        ::std::mem::size_of::<kevent64_s>(),
        48usize,
        concat!("Size of: ", stringify!(kevent64_s))
    );
    assert_eq!(
        ::std::mem::align_of::<kevent64_s>(),
        8usize,
        concat!("Alignment of ", stringify!(kevent64_s))
    );
    fn test_field_ident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ident) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(ident)
            )
        );
    }
    test_field_ident();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_fflags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fflags) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(fflags)
            )
        );
    }
    test_field_fflags();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_udata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).udata) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(udata)
            )
        );
    }
    test_field_udata();
    fn test_field_ext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kevent64_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ext) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(kevent64_s),
                "::",
                stringify!(ext)
            )
        );
    }
    test_field_ext();
}
pub const eNoteReapDeprecated: _bindgen_ty_2 = 268435456;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const eNoteExitReparentedDeprecated: _bindgen_ty_3 = 524288;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct klist {
    pub slh_first: *mut knote,
}
#[test]
fn bindgen_test_layout_klist() {
    assert_eq!(
        ::std::mem::size_of::<klist>(),
        8usize,
        concat!("Size of: ", stringify!(klist))
    );
    assert_eq!(
        ::std::mem::align_of::<klist>(),
        8usize,
        concat!("Alignment of ", stringify!(klist))
    );
    fn test_field_slh_first() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<klist>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).slh_first) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(klist),
                "::",
                stringify!(slh_first)
            )
        );
    }
    test_field_slh_first();
}
extern "C" {
    pub fn kqueue() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kevent(
        kq: ::std::os::raw::c_int,
        changelist: *const kevent,
        nchanges: ::std::os::raw::c_int,
        eventlist: *mut kevent,
        nevents: ::std::os::raw::c_int,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kevent64(
        kq: ::std::os::raw::c_int,
        changelist: *const kevent64_s,
        nchanges: ::std::os::raw::c_int,
        eventlist: *mut kevent64_s,
        nevents: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pgrp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ident {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct extern_proc {
    pub p_un: extern_proc__bindgen_ty_1,
    pub p_vmspace: *mut vmspace,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::std::os::raw::c_int,
    pub p_stat: ::std::os::raw::c_char,
    pub p_pid: pid_t,
    pub p_oppid: pid_t,
    pub p_dupfd: ::std::os::raw::c_int,
    pub user_stack: caddr_t,
    pub exit_thread: *mut ::std::os::raw::c_void,
    pub p_debugger: ::std::os::raw::c_int,
    pub sigwait: boolean_t,
    pub p_estcpu: u_int,
    pub p_cpticks: ::std::os::raw::c_int,
    pub p_pctcpu: fixpt_t,
    pub p_wchan: *mut ::std::os::raw::c_void,
    pub p_wmesg: *mut ::std::os::raw::c_char,
    pub p_swtime: u_int,
    pub p_slptime: u_int,
    pub p_realtimer: itimerval,
    pub p_rtime: timeval,
    pub p_uticks: u_quad_t,
    pub p_sticks: u_quad_t,
    pub p_iticks: u_quad_t,
    pub p_traceflag: ::std::os::raw::c_int,
    pub p_tracep: *mut vnode,
    pub p_siglist: ::std::os::raw::c_int,
    pub p_textvp: *mut vnode,
    pub p_holdcnt: ::std::os::raw::c_int,
    pub p_sigmask: sigset_t,
    pub p_sigignore: sigset_t,
    pub p_sigcatch: sigset_t,
    pub p_priority: u_char,
    pub p_usrpri: u_char,
    pub p_nice: ::std::os::raw::c_char,
    pub p_comm: [::std::os::raw::c_char; 17usize],
    pub p_pgrp: *mut pgrp,
    pub p_addr: *mut user,
    pub p_xstat: u_short,
    pub p_acflag: u_short,
    pub p_ru: *mut rusage,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union extern_proc__bindgen_ty_1 {
    pub p_st1: extern_proc__bindgen_ty_1__bindgen_ty_1,
    pub __p_starttime: timeval,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extern_proc__bindgen_ty_1__bindgen_ty_1 {
    pub __p_forw: *mut proc_,
    pub __p_back: *mut proc_,
}
#[test]
fn bindgen_test_layout_extern_proc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field___p_forw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_forw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__p_forw)
            )
        );
    }
    test_field___p_forw();
    fn test_field___p_back() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_back) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__p_back)
            )
        );
    }
    test_field___p_back();
}
#[test]
fn bindgen_test_layout_extern_proc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(extern_proc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(extern_proc__bindgen_ty_1))
    );
    fn test_field_p_st1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_st1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1),
                "::",
                stringify!(p_st1)
            )
        );
    }
    test_field_p_st1();
    fn test_field___p_starttime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__p_starttime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc__bindgen_ty_1),
                "::",
                stringify!(__p_starttime)
            )
        );
    }
    test_field___p_starttime();
}
#[test]
fn bindgen_test_layout_extern_proc() {
    assert_eq!(
        ::std::mem::size_of::<extern_proc>(),
        296usize,
        concat!("Size of: ", stringify!(extern_proc))
    );
    assert_eq!(
        ::std::mem::align_of::<extern_proc>(),
        8usize,
        concat!("Alignment of ", stringify!(extern_proc))
    );
    fn test_field_p_un() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_un) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_un)
            )
        );
    }
    test_field_p_un();
    fn test_field_p_vmspace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_vmspace) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_vmspace)
            )
        );
    }
    test_field_p_vmspace();
    fn test_field_p_sigacts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigacts) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigacts)
            )
        );
    }
    test_field_p_sigacts();
    fn test_field_p_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_flag) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_flag)
            )
        );
    }
    test_field_p_flag();
    fn test_field_p_stat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_stat) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_stat)
            )
        );
    }
    test_field_p_stat();
    fn test_field_p_pid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pid)
            )
        );
    }
    test_field_p_pid();
    fn test_field_p_oppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_oppid) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_oppid)
            )
        );
    }
    test_field_p_oppid();
    fn test_field_p_dupfd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_dupfd) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_dupfd)
            )
        );
    }
    test_field_p_dupfd();
    fn test_field_user_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_stack) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(user_stack)
            )
        );
    }
    test_field_user_stack();
    fn test_field_exit_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exit_thread) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(exit_thread)
            )
        );
    }
    test_field_exit_thread();
    fn test_field_p_debugger() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_debugger) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_debugger)
            )
        );
    }
    test_field_p_debugger();
    fn test_field_sigwait() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sigwait) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(sigwait)
            )
        );
    }
    test_field_sigwait();
    fn test_field_p_estcpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_estcpu) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_estcpu)
            )
        );
    }
    test_field_p_estcpu();
    fn test_field_p_cpticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_cpticks) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_cpticks)
            )
        );
    }
    test_field_p_cpticks();
    fn test_field_p_pctcpu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pctcpu) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pctcpu)
            )
        );
    }
    test_field_p_pctcpu();
    fn test_field_p_wchan() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_wchan) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_wchan)
            )
        );
    }
    test_field_p_wchan();
    fn test_field_p_wmesg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_wmesg) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_wmesg)
            )
        );
    }
    test_field_p_wmesg();
    fn test_field_p_swtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_swtime) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_swtime)
            )
        );
    }
    test_field_p_swtime();
    fn test_field_p_slptime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_slptime) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_slptime)
            )
        );
    }
    test_field_p_slptime();
    fn test_field_p_realtimer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_realtimer) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_realtimer)
            )
        );
    }
    test_field_p_realtimer();
    fn test_field_p_rtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_rtime) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_rtime)
            )
        );
    }
    test_field_p_rtime();
    fn test_field_p_uticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_uticks) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_uticks)
            )
        );
    }
    test_field_p_uticks();
    fn test_field_p_sticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sticks) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sticks)
            )
        );
    }
    test_field_p_sticks();
    fn test_field_p_iticks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_iticks) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_iticks)
            )
        );
    }
    test_field_p_iticks();
    fn test_field_p_traceflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_traceflag) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_traceflag)
            )
        );
    }
    test_field_p_traceflag();
    fn test_field_p_tracep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_tracep) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_tracep)
            )
        );
    }
    test_field_p_tracep();
    fn test_field_p_siglist() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_siglist) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_siglist)
            )
        );
    }
    test_field_p_siglist();
    fn test_field_p_textvp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_textvp) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_textvp)
            )
        );
    }
    test_field_p_textvp();
    fn test_field_p_holdcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_holdcnt) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_holdcnt)
            )
        );
    }
    test_field_p_holdcnt();
    fn test_field_p_sigmask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigmask) as usize - ptr as usize
            },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigmask)
            )
        );
    }
    test_field_p_sigmask();
    fn test_field_p_sigignore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigignore) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigignore)
            )
        );
    }
    test_field_p_sigignore();
    fn test_field_p_sigcatch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_sigcatch) as usize - ptr as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_sigcatch)
            )
        );
    }
    test_field_p_sigcatch();
    fn test_field_p_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_priority) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_priority)
            )
        );
    }
    test_field_p_priority();
    fn test_field_p_usrpri() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_usrpri) as usize - ptr as usize
            },
            241usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_usrpri)
            )
        );
    }
    test_field_p_usrpri();
    fn test_field_p_nice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_nice) as usize - ptr as usize
            },
            242usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_nice)
            )
        );
    }
    test_field_p_nice();
    fn test_field_p_comm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_comm) as usize - ptr as usize
            },
            243usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_comm)
            )
        );
    }
    test_field_p_comm();
    fn test_field_p_pgrp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_pgrp) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_pgrp)
            )
        );
    }
    test_field_p_pgrp();
    fn test_field_p_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_addr) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_addr)
            )
        );
    }
    test_field_p_addr();
    fn test_field_p_xstat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_xstat) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_xstat)
            )
        );
    }
    test_field_p_xstat();
    fn test_field_p_acflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_acflag) as usize - ptr as usize
            },
            282usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_acflag)
            )
        );
    }
    test_field_p_acflag();
    fn test_field_p_ru() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<extern_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_ru) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(extern_proc),
                "::",
                stringify!(p_ru)
            )
        );
    }
    test_field_p_ru();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ctlname {
    pub ctl_name: *mut ::std::os::raw::c_char,
    pub ctl_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctlname() {
    assert_eq!(
        ::std::mem::size_of::<ctlname>(),
        16usize,
        concat!("Size of: ", stringify!(ctlname))
    );
    assert_eq!(
        ::std::mem::align_of::<ctlname>(),
        8usize,
        concat!("Alignment of ", stringify!(ctlname))
    );
    fn test_field_ctl_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ctlname>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctl_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(ctlname),
                "::",
                stringify!(ctl_name)
            )
        );
    }
    test_field_ctl_name();
    fn test_field_ctl_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<ctlname>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctl_type) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(ctlname),
                "::",
                stringify!(ctl_type)
            )
        );
    }
    test_field_ctl_type();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pcred {
    pub pc_lock: [::std::os::raw::c_char; 72usize],
    pub pc_ucred: *mut ucred,
    pub p_ruid: uid_t,
    pub p_svuid: uid_t,
    pub p_rgid: gid_t,
    pub p_svgid: gid_t,
    pub p_refcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__pcred() {
    assert_eq!(
        ::std::mem::size_of::<_pcred>(),
        104usize,
        concat!("Size of: ", stringify!(_pcred))
    );
    assert_eq!(
        ::std::mem::align_of::<_pcred>(),
        8usize,
        concat!("Alignment of ", stringify!(_pcred))
    );
    fn test_field_pc_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc_lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(pc_lock)
            )
        );
    }
    test_field_pc_lock();
    fn test_field_pc_ucred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc_ucred) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(pc_ucred)
            )
        );
    }
    test_field_pc_ucred();
    fn test_field_p_ruid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_ruid) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_ruid)
            )
        );
    }
    test_field_p_ruid();
    fn test_field_p_svuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_svuid) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_svuid)
            )
        );
    }
    test_field_p_svuid();
    fn test_field_p_rgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_rgid) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_rgid)
            )
        );
    }
    test_field_p_rgid();
    fn test_field_p_svgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_svgid) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_svgid)
            )
        );
    }
    test_field_p_svgid();
    fn test_field_p_refcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_pcred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).p_refcnt) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_pcred),
                "::",
                stringify!(p_refcnt)
            )
        );
    }
    test_field_p_refcnt();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ucred {
    pub cr_ref: i32,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::std::os::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout__ucred() {
    assert_eq!(
        ::std::mem::size_of::<_ucred>(),
        76usize,
        concat!("Size of: ", stringify!(_ucred))
    );
    assert_eq!(
        ::std::mem::align_of::<_ucred>(),
        4usize,
        concat!("Alignment of ", stringify!(_ucred))
    );
    fn test_field_cr_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ref) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_ref)
            )
        );
    }
    test_field_cr_ref();
    fn test_field_cr_uid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_uid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_uid)
            )
        );
    }
    test_field_cr_uid();
    fn test_field_cr_ngroups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_ngroups) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_ngroups)
            )
        );
    }
    test_field_cr_ngroups();
    fn test_field_cr_groups() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_ucred>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cr_groups) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_ucred),
                "::",
                stringify!(cr_groups)
            )
        );
    }
    test_field_cr_groups();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kinfo_proc {
    pub kp_proc: extern_proc,
    pub kp_eproc: kinfo_proc_eproc,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kinfo_proc_eproc {
    pub e_paddr: *mut proc_,
    pub e_sess: *mut session,
    pub e_pcred: _pcred,
    pub e_ucred: _ucred,
    pub e_vm: vmspace,
    pub e_ppid: pid_t,
    pub e_pgid: pid_t,
    pub e_jobc: ::std::os::raw::c_short,
    pub e_tdev: dev_t,
    pub e_tpgid: pid_t,
    pub e_tsess: *mut session,
    pub e_wmesg: [::std::os::raw::c_char; 8usize],
    pub e_xsize: segsz_t,
    pub e_xrssize: ::std::os::raw::c_short,
    pub e_xccount: ::std::os::raw::c_short,
    pub e_xswrss: ::std::os::raw::c_short,
    pub e_flag: i32,
    pub e_login: [::std::os::raw::c_char; 12usize],
    pub e_spare: [i32; 4usize],
}
#[test]
fn bindgen_test_layout_kinfo_proc_eproc() {
    assert_eq!(
        ::std::mem::size_of::<kinfo_proc_eproc>(),
        352usize,
        concat!("Size of: ", stringify!(kinfo_proc_eproc))
    );
    assert_eq!(
        ::std::mem::align_of::<kinfo_proc_eproc>(),
        8usize,
        concat!("Alignment of ", stringify!(kinfo_proc_eproc))
    );
    fn test_field_e_paddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_paddr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_paddr)
            )
        );
    }
    test_field_e_paddr();
    fn test_field_e_sess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_sess) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_sess)
            )
        );
    }
    test_field_e_sess();
    fn test_field_e_pcred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_pcred) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_pcred)
            )
        );
    }
    test_field_e_pcred();
    fn test_field_e_ucred() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_ucred) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_ucred)
            )
        );
    }
    test_field_e_ucred();
    fn test_field_e_vm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_vm) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_vm)
            )
        );
    }
    test_field_e_vm();
    fn test_field_e_ppid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_ppid) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_ppid)
            )
        );
    }
    test_field_e_ppid();
    fn test_field_e_pgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_pgid) as usize - ptr as usize
            },
            268usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_pgid)
            )
        );
    }
    test_field_e_pgid();
    fn test_field_e_jobc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_jobc) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_jobc)
            )
        );
    }
    test_field_e_jobc();
    fn test_field_e_tdev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tdev) as usize - ptr as usize
            },
            276usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tdev)
            )
        );
    }
    test_field_e_tdev();
    fn test_field_e_tpgid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tpgid) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tpgid)
            )
        );
    }
    test_field_e_tpgid();
    fn test_field_e_tsess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_tsess) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_tsess)
            )
        );
    }
    test_field_e_tsess();
    fn test_field_e_wmesg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_wmesg) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_wmesg)
            )
        );
    }
    test_field_e_wmesg();
    fn test_field_e_xsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xsize) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xsize)
            )
        );
    }
    test_field_e_xsize();
    fn test_field_e_xrssize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xrssize) as usize - ptr as usize
            },
            308usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xrssize)
            )
        );
    }
    test_field_e_xrssize();
    fn test_field_e_xccount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xccount) as usize - ptr as usize
            },
            310usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xccount)
            )
        );
    }
    test_field_e_xccount();
    fn test_field_e_xswrss() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_xswrss) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_xswrss)
            )
        );
    }
    test_field_e_xswrss();
    fn test_field_e_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_flag) as usize - ptr as usize
            },
            316usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_flag)
            )
        );
    }
    test_field_e_flag();
    fn test_field_e_login() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_login) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_login)
            )
        );
    }
    test_field_e_login();
    fn test_field_e_spare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc_eproc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_spare) as usize - ptr as usize
            },
            332usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc_eproc),
                "::",
                stringify!(e_spare)
            )
        );
    }
    test_field_e_spare();
}
#[test]
fn bindgen_test_layout_kinfo_proc() {
    assert_eq!(
        ::std::mem::size_of::<kinfo_proc>(),
        648usize,
        concat!("Size of: ", stringify!(kinfo_proc))
    );
    assert_eq!(
        ::std::mem::align_of::<kinfo_proc>(),
        8usize,
        concat!("Alignment of ", stringify!(kinfo_proc))
    );
    fn test_field_kp_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kp_proc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc),
                "::",
                stringify!(kp_proc)
            )
        );
    }
    test_field_kp_proc();
    fn test_field_kp_eproc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<kinfo_proc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kp_eproc) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(kinfo_proc),
                "::",
                stringify!(kp_eproc)
            )
        );
    }
    test_field_kp_eproc();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xsw_usage {
    pub xsu_total: u_int64_t,
    pub xsu_avail: u_int64_t,
    pub xsu_used: u_int64_t,
    pub xsu_pagesize: u_int32_t,
    pub xsu_encrypted: boolean_t,
}
#[test]
fn bindgen_test_layout_xsw_usage() {
    assert_eq!(
        ::std::mem::size_of::<xsw_usage>(),
        32usize,
        concat!("Size of: ", stringify!(xsw_usage))
    );
    assert_eq!(
        ::std::mem::align_of::<xsw_usage>(),
        8usize,
        concat!("Alignment of ", stringify!(xsw_usage))
    );
    fn test_field_xsu_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_total) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_total)
            )
        );
    }
    test_field_xsu_total();
    fn test_field_xsu_avail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_avail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_avail)
            )
        );
    }
    test_field_xsu_avail();
    fn test_field_xsu_used() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_used) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_used)
            )
        );
    }
    test_field_xsu_used();
    fn test_field_xsu_pagesize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_pagesize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_pagesize)
            )
        );
    }
    test_field_xsu_pagesize();
    fn test_field_xsu_encrypted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<xsw_usage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xsu_encrypted) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(xsw_usage),
                "::",
                stringify!(xsu_encrypted)
            )
        );
    }
    test_field_xsu_encrypted();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loadavg {
    pub ldavg: [fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(
        ::std::mem::size_of::<loadavg>(),
        24usize,
        concat!("Size of: ", stringify!(loadavg))
    );
    assert_eq!(
        ::std::mem::align_of::<loadavg>(),
        8usize,
        concat!("Alignment of ", stringify!(loadavg))
    );
    fn test_field_ldavg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<loadavg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ldavg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(loadavg),
                "::",
                stringify!(ldavg)
            )
        );
    }
    test_field_ldavg();
    fn test_field_fscale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<loadavg>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fscale) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(loadavg),
                "::",
                stringify!(fscale)
            )
        );
    }
    test_field_fscale();
}
extern "C" {
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn sysctl(
        arg1: *mut ::std::os::raw::c_int,
        arg2: u_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut size_t,
        arg5: *mut ::std::os::raw::c_void,
        arg6: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctlbyname(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut size_t,
        arg4: *mut ::std::os::raw::c_void,
        arg5: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sysctlnametomib(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user {}
#[test]
fn bindgen_test_layout_user() {
    assert_eq!(
        ::std::mem::size_of::<user>(),
        0usize,
        concat!("Size of: ", stringify!(user))
    );
    assert_eq!(
        ::std::mem::align_of::<user>(),
        1usize,
        concat!("Alignment of ", stringify!(user))
    );
}
pub type regoff_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regex_t {
    pub re_magic: ::std::os::raw::c_int,
    pub re_nsub: size_t,
    pub re_endp: *const ::std::os::raw::c_char,
    pub re_g: *mut re_guts,
}
#[test]
fn bindgen_test_layout_regex_t() {
    assert_eq!(
        ::std::mem::size_of::<regex_t>(),
        32usize,
        concat!("Size of: ", stringify!(regex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regex_t))
    );
    fn test_field_re_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_magic)
            )
        );
    }
    test_field_re_magic();
    fn test_field_re_nsub() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_nsub) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_nsub)
            )
        );
    }
    test_field_re_nsub();
    fn test_field_re_endp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_endp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_endp)
            )
        );
    }
    test_field_re_endp();
    fn test_field_re_g() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).re_g) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(regex_t),
                "::",
                stringify!(re_g)
            )
        );
    }
    test_field_re_g();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct regmatch_t {
    pub rm_so: regoff_t,
    pub rm_eo: regoff_t,
}
#[test]
fn bindgen_test_layout_regmatch_t() {
    assert_eq!(
        ::std::mem::size_of::<regmatch_t>(),
        16usize,
        concat!("Size of: ", stringify!(regmatch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<regmatch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(regmatch_t))
    );
    fn test_field_rm_so() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regmatch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rm_so) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(regmatch_t),
                "::",
                stringify!(rm_so)
            )
        );
    }
    test_field_rm_so();
    fn test_field_rm_eo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<regmatch_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rm_eo) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(regmatch_t),
                "::",
                stringify!(rm_eo)
            )
        );
    }
    test_field_rm_eo();
}
extern "C" {
    pub fn regcomp(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regerror(
        arg1: ::std::os::raw::c_int,
        arg2: *const regex_t,
        arg3: *mut ::std::os::raw::c_char,
        arg4: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn regexec(
        arg1: *const regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        __pmatch: *mut regmatch_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regfree(arg1: *mut regex_t);
}
extern "C" {
    pub fn regncomp(
        arg1: *mut regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regnexec(
        arg1: *const regex_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
        arg4: size_t,
        __pmatch: *mut regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwcomp(
        arg1: *mut regex_t,
        arg2: *const wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwexec(
        arg1: *const regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        __pmatch: *mut regmatch_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwncomp(
        arg1: *mut regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn regwnexec(
        arg1: *const regex_t,
        arg2: *const wchar_t,
        arg3: size_t,
        arg4: size_t,
        __pmatch: *mut regmatch_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    pub name: *const ::std::os::raw::c_char,
    pub has_arg: ::std::os::raw::c_int,
    pub flag: *mut ::std::os::raw::c_int,
    pub val: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_option() {
    assert_eq!(
        ::std::mem::size_of::<option>(),
        32usize,
        concat!("Size of: ", stringify!(option))
    );
    assert_eq!(
        ::std::mem::align_of::<option>(),
        8usize,
        concat!("Alignment of ", stringify!(option))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_has_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(has_arg)
            )
        );
    }
    test_field_has_arg();
    fn test_field_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flag) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(flag)
            )
        );
    }
    test_field_flag();
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<option>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(option),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
extern "C" {
    pub fn getopt_long(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const option,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt_long_only(
        arg1: ::std::os::raw::c_int,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const option,
        arg5: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " List of CPUs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_cpuset {
    pub str_: [::std::os::raw::c_char; 257usize],
    pub cpus: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_spdk_cpuset() {
    assert_eq!(
        ::std::mem::size_of::<spdk_cpuset>(),
        385usize,
        concat!("Size of: ", stringify!(spdk_cpuset))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_cpuset>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_cpuset))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_cpuset>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_cpuset),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_cpus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_cpuset>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpus) as usize - ptr as usize
            },
            257usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_cpuset),
                "::",
                stringify!(cpus)
            )
        );
    }
    test_field_cpus();
}
extern "C" {
    #[doc = " Allocate CPU set object."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated zeroed cpuset on success, or NULL on failure."]
    pub fn spdk_cpuset_alloc() -> *mut spdk_cpuset;
}
extern "C" {
    #[doc = " Free allocated CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be freed."]
    pub fn spdk_cpuset_free(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Compare two CPU sets."]
    #[doc = ""]
    #[doc = " \\param set1 CPU set1."]
    #[doc = " \\param set2 CPU set2."]
    #[doc = ""]
    #[doc = " \\return true if both CPU sets are equal."]
    pub fn spdk_cpuset_equal(set1: *const spdk_cpuset, set2: *const spdk_cpuset) -> bool;
}
extern "C" {
    #[doc = " Copy the content of CPU set to another."]
    #[doc = ""]
    #[doc = " \\param dst Destination CPU set"]
    #[doc = " \\param src Source CPU set"]
    pub fn spdk_cpuset_copy(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform AND operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_and(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform OR operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_or(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Perform XOR operation on two CPU sets. The result is stored in dst."]
    #[doc = ""]
    #[doc = " \\param dst First argument of operation. This value also stores the result of operation."]
    #[doc = " \\param src Second argument of operation."]
    pub fn spdk_cpuset_xor(dst: *mut spdk_cpuset, src: *const spdk_cpuset);
}
extern "C" {
    #[doc = " Negate all CPUs in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be negated. This value also stores the result of operation."]
    pub fn spdk_cpuset_negate(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Clear all CPUs in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set to be cleared."]
    pub fn spdk_cpuset_zero(set: *mut spdk_cpuset);
}
extern "C" {
    #[doc = " Set or clear CPU state in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = " \\param cpu CPU index to be set or cleared."]
    #[doc = " \\param state *true* to set cpu, *false* to clear."]
    pub fn spdk_cpuset_set_cpu(set: *mut spdk_cpuset, cpu: u32, state: bool);
}
extern "C" {
    #[doc = " Get the state of CPU in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = " \\param cpu CPU index."]
    #[doc = ""]
    #[doc = " \\return the state of selected CPU."]
    pub fn spdk_cpuset_get_cpu(set: *const spdk_cpuset, cpu: u32) -> bool;
}
extern "C" {
    #[doc = " Get the number of CPUs that are set in CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set object."]
    #[doc = ""]
    #[doc = " \\return the number of CPUs."]
    pub fn spdk_cpuset_count(set: *const spdk_cpuset) -> u32;
}
extern "C" {
    #[doc = " Convert a CPU set to hex string."]
    #[doc = ""]
    #[doc = " \\param set CPU set."]
    #[doc = ""]
    #[doc = " \\return a pointer to hexadecimal representation of CPU set. Buffer to store a"]
    #[doc = " string is dynamically allocated internally and freed with CPU set object."]
    #[doc = " Memory returned by this function might be changed after subsequent calls to"]
    #[doc = " this function so string should be copied by user."]
    pub fn spdk_cpuset_fmt(set: *mut spdk_cpuset) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert a string containing a CPU core mask into a CPU set."]
    #[doc = ""]
    #[doc = " \\param set CPU set."]
    #[doc = " \\param mask String defining CPU set. By default hexadecimal value is used or"]
    #[doc = " as CPU list enclosed in square brackets defined as: 'c1[-c2][,c3[-c4],...]'."]
    #[doc = ""]
    #[doc = " \\return zero if success, non zero if fails."]
    pub fn spdk_cpuset_parse(
        set: *mut spdk_cpuset,
        mask: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " for passing user-provided log call"]
#[doc = ""]
#[doc = " \\param level Log level threshold."]
#[doc = " \\param file Name of the current source file."]
#[doc = " \\param line Current source file line."]
#[doc = " \\param func Current source function name."]
#[doc = " \\param format Format string to the message."]
#[doc = " \\param args Additional arguments for format string."]
pub type logfunc = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_int,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
extern "C" {
    #[doc = " Initialize the logging module. Messages prior"]
    #[doc = " to this call will be dropped."]
    pub fn spdk_log_open(logf: logfunc);
}
extern "C" {
    #[doc = " Close the currently active log. Messages after this call"]
    #[doc = " will be dropped."]
    pub fn spdk_log_close();
}
extern "C" {
    #[doc = " Enable or disable timestamps"]
    pub fn spdk_log_enable_timestamps(value: bool);
}
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_DISABLED: spdk_log_level = -1;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_ERROR: spdk_log_level = 0;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_WARN: spdk_log_level = 1;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_NOTICE: spdk_log_level = 2;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_INFO: spdk_log_level = 3;
#[doc = " All messages will be suppressed."]
pub const spdk_log_level_SPDK_LOG_DEBUG: spdk_log_level = 4;
pub type spdk_log_level = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Set the log level threshold to log messages. Messages with a higher"]
    #[doc = " level than this are ignored."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold to set to log messages."]
    pub fn spdk_log_set_level(level: spdk_log_level);
}
extern "C" {
    #[doc = " Get the current log level threshold."]
    #[doc = ""]
    #[doc = " \\return the current log level threshold."]
    pub fn spdk_log_get_level() -> spdk_log_level;
}
extern "C" {
    #[doc = " Set the current log level threshold for printing to stderr."]
    #[doc = " Messages with a level less than or equal to this level"]
    #[doc = " are also printed to stderr. You can use \\c SPDK_LOG_DISABLED to completely"]
    #[doc = " suppress log printing."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold for printing to stderr."]
    pub fn spdk_log_set_print_level(level: spdk_log_level);
}
extern "C" {
    #[doc = " Get the current log level print threshold."]
    #[doc = ""]
    #[doc = " \\return the current log level print threshold."]
    pub fn spdk_log_get_print_level() -> spdk_log_level;
}
extern "C" {
    #[doc = " Write messages to the log file. If \\c level is set to \\c SPDK_LOG_DISABLED,"]
    #[doc = " this log message won't be written."]
    #[doc = ""]
    #[doc = " \\param level Log level threshold."]
    #[doc = " \\param file Name of the current source file."]
    #[doc = " \\param line Current source line number."]
    #[doc = " \\param func Current source function name."]
    #[doc = " \\param format Format string to the message."]
    pub fn spdk_log(
        level: spdk_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Same as spdk_log except that instead of being called with variable number of"]
    #[doc = " arguments it is called with an argument list as defined in stdarg.h"]
    #[doc = ""]
    #[doc = " \\param level Log level threshold."]
    #[doc = " \\param file Name of the current source file."]
    #[doc = " \\param line Current source line number."]
    #[doc = " \\param func Current source function name."]
    #[doc = " \\param format Format string to the message."]
    #[doc = " \\param ap printf arguments"]
    pub fn spdk_vlog(
        level: spdk_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    );
}
extern "C" {
    #[doc = " Log the contents of a raw buffer to a file."]
    #[doc = ""]
    #[doc = " \\param fp File to hold the log."]
    #[doc = " \\param label Label to print to the file."]
    #[doc = " \\param buf Buffer that holds the log information."]
    #[doc = " \\param len Length of buffer to dump."]
    pub fn spdk_log_dump(
        fp: *mut FILE,
        label: *const ::std::os::raw::c_char,
        buf: *const ::std::os::raw::c_void,
        len: size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_log_flag {
    pub tailq: spdk_log_flag__bindgen_ty_1,
    pub name: *const ::std::os::raw::c_char,
    pub enabled: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_log_flag__bindgen_ty_1 {
    pub tqe_next: *mut spdk_log_flag,
    pub tqe_prev: *mut *mut spdk_log_flag,
}
#[test]
fn bindgen_test_layout_spdk_log_flag__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_log_flag__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_log_flag__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_log_flag__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_log_flag__bindgen_ty_1))
    );
    fn test_field_tqe_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag__bindgen_ty_1),
                "::",
                stringify!(tqe_next)
            )
        );
    }
    test_field_tqe_next();
    fn test_field_tqe_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag__bindgen_ty_1),
                "::",
                stringify!(tqe_prev)
            )
        );
    }
    test_field_tqe_prev();
}
#[test]
fn bindgen_test_layout_spdk_log_flag() {
    assert_eq!(
        ::std::mem::size_of::<spdk_log_flag>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_log_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_log_flag>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_log_flag))
    );
    fn test_field_tailq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tailq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(tailq)
            )
        );
    }
    test_field_tailq();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_log_flag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_log_flag),
                "::",
                stringify!(enabled)
            )
        );
    }
    test_field_enabled();
}
extern "C" {
    #[doc = " Register a log flag."]
    #[doc = ""]
    #[doc = " \\param name Name of the log flag."]
    #[doc = " \\param flag Log flag to be added."]
    pub fn spdk_log_register_flag(name: *const ::std::os::raw::c_char, flag: *mut spdk_log_flag);
}
extern "C" {
    #[doc = " Get the first registered log flag."]
    #[doc = ""]
    #[doc = " \\return The first registered log flag."]
    pub fn spdk_log_get_first_flag() -> *mut spdk_log_flag;
}
extern "C" {
    #[doc = " Get the next registered log flag."]
    #[doc = ""]
    #[doc = " \\param flag The current log flag."]
    #[doc = ""]
    #[doc = " \\return The next registered log flag."]
    pub fn spdk_log_get_next_flag(flag: *mut spdk_log_flag) -> *mut spdk_log_flag;
}
extern "C" {
    #[doc = " Check whether the log flag exists and is enabled."]
    #[doc = ""]
    #[doc = " \\return true if enabled, or false otherwise."]
    pub fn spdk_log_get_flag(flag: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    #[doc = " Enable the log flag."]
    #[doc = ""]
    #[doc = " \\param flag Log flag to be enabled."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_log_set_flag(flag: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Clear a log flag."]
    #[doc = ""]
    #[doc = " \\param flag Log flag to clear."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_log_clear_flag(flag: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Show all the log flags and their usage."]
    #[doc = ""]
    #[doc = " \\param f File to hold all the flags' information."]
    #[doc = " \\param log_arg Command line option to set/enable the log flag."]
    pub fn spdk_log_usage(f: *mut FILE, log_arg: *const ::std::os::raw::c_char);
}
pub const spdk_thread_poller_rc_SPDK_POLLER_IDLE: spdk_thread_poller_rc = 0;
pub const spdk_thread_poller_rc_SPDK_POLLER_BUSY: spdk_thread_poller_rc = 1;
pub type spdk_thread_poller_rc = ::std::os::raw::c_uint;
#[doc = " A stackless, lightweight thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_thread {
    _unused: [u8; 0],
}
#[doc = " A function repeatedly called on the same spdk_thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_poller {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel_iter {
    _unused: [u8; 0],
}
#[doc = " A function that is called each time a new thread is created."]
#[doc = " The implementor of this function should frequently call"]
#[doc = " spdk_thread_poll() on the thread provided."]
#[doc = ""]
#[doc = " \\param thread The new spdk_thread."]
pub type spdk_new_thread_fn =
    ::std::option::Option<unsafe extern "C" fn(thread: *mut spdk_thread) -> ::std::os::raw::c_int>;
pub const spdk_thread_op_SPDK_THREAD_OP_NEW: spdk_thread_op = 0;
pub const spdk_thread_op_SPDK_THREAD_OP_RESCHED: spdk_thread_op = 1;
#[doc = " SPDK thread operation type."]
pub type spdk_thread_op = ::std::os::raw::c_uint;
#[doc = " Function to be called for SPDK thread operation."]
pub type spdk_thread_op_fn = ::std::option::Option<
    unsafe extern "C" fn(thread: *mut spdk_thread, op: spdk_thread_op) -> ::std::os::raw::c_int,
>;
#[doc = " Function to check whether the SPDK thread operation is supported."]
pub type spdk_thread_op_supported_fn =
    ::std::option::Option<unsafe extern "C" fn(op: spdk_thread_op) -> bool>;
#[doc = " A function that will be called on the target thread."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_thread_pass_msg()."]
pub type spdk_msg_fn =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void)>;
#[doc = " Function to be called to pass a message to a thread."]
#[doc = ""]
#[doc = " \\param fn Callback function for a thread."]
#[doc = " \\param ctx Context passed to fn."]
#[doc = " \\param thread_ctx Context for the thread."]
pub type spdk_thread_pass_msg = ::std::option::Option<
    unsafe extern "C" fn(
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
        thread_ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Callback function for a poller."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_poller_register()."]
#[doc = " \\return 0 to indicate that polling took place but no events were found;"]
#[doc = " positive to indicate that polling took place and some events were processed;"]
#[doc = " negative if the poller does not provide spin-wait information."]
pub type spdk_poller_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[doc = " Function to be called to start a poller for the thread."]
#[doc = ""]
#[doc = " \\param thread_ctx Context for the thread."]
#[doc = " \\param fn Callback function for a poller."]
#[doc = " \\param arg Argument passed to callback."]
#[doc = " \\param period_microseconds Polling period in microseconds."]
#[doc = ""]
#[doc = " \\return a pointer to the poller on success, or NULL on failure."]
pub type spdk_start_poller = ::std::option::Option<
    unsafe extern "C" fn(
        thread_ctx: *mut ::std::os::raw::c_void,
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
    ) -> *mut spdk_poller,
>;
#[doc = " Function to be called to stop a poller."]
#[doc = ""]
#[doc = " \\param poller Poller to stop."]
#[doc = " \\param thread_ctx Context for the thread."]
pub type spdk_stop_poller = ::std::option::Option<
    unsafe extern "C" fn(poller: *mut spdk_poller, thread_ctx: *mut ::std::os::raw::c_void),
>;
#[doc = " Callback function to set poller into interrupt mode or back to poll mode."]
#[doc = ""]
#[doc = " \\param poller Poller to set interrupt or poll mode."]
#[doc = " \\param cb_arg Argument passed to the callback function."]
#[doc = " \\param interrupt_mode Set interrupt mode for true, or poll mode for false"]
pub type spdk_poller_set_interrupt_mode_cb = ::std::option::Option<
    unsafe extern "C" fn(
        poller: *mut spdk_poller,
        cb_arg: *mut ::std::os::raw::c_void,
        interrupt_mode: bool,
    ),
>;
extern "C" {
    #[doc = " Mark that the poller is capable of entering interrupt mode."]
    #[doc = ""]
    #[doc = " When registering the poller set interrupt callback, the callback will get"]
    #[doc = " executed immediately if its spdk_thread is in the interrupt mode."]
    #[doc = ""]
    #[doc = " \\param poller The poller to register callback function."]
    #[doc = " \\param cb_fn Callback function called when the poller must transition into or out of interrupt mode"]
    #[doc = " \\param cb_arg Argument passed to the callback function."]
    pub fn spdk_poller_register_interrupt(
        poller: *mut spdk_poller,
        cb_fn: spdk_poller_set_interrupt_mode_cb,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
#[doc = " I/O channel creation callback."]
#[doc = ""]
#[doc = " \\param io_device I/O device associated with this channel."]
#[doc = " \\param ctx_buf Context for the I/O device."]
pub type spdk_io_channel_create_cb = ::std::option::Option<
    unsafe extern "C" fn(
        io_device: *mut ::std::os::raw::c_void,
        ctx_buf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " I/O channel destruction callback."]
#[doc = ""]
#[doc = " \\param io_device I/O device associated with this channel."]
#[doc = " \\param ctx_buf Context for the I/O device."]
pub type spdk_io_channel_destroy_cb = ::std::option::Option<
    unsafe extern "C" fn(
        io_device: *mut ::std::os::raw::c_void,
        ctx_buf: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " I/O device unregister callback."]
#[doc = ""]
#[doc = " \\param io_device Unregistered I/O device."]
pub type spdk_io_device_unregister_cb =
    ::std::option::Option<unsafe extern "C" fn(io_device: *mut ::std::os::raw::c_void)>;
#[doc = " Called on the appropriate thread for each channel associated with io_device."]
#[doc = ""]
#[doc = " \\param i I/O channel iterator."]
pub type spdk_channel_msg =
    ::std::option::Option<unsafe extern "C" fn(i: *mut spdk_io_channel_iter)>;
#[doc = " spdk_for_each_channel() callback."]
#[doc = ""]
#[doc = " \\param i I/O channel iterator."]
#[doc = " \\param status 0 if it completed successfully, or negative errno if it failed."]
pub type spdk_channel_for_each_cpl = ::std::option::Option<
    unsafe extern "C" fn(i: *mut spdk_io_channel_iter, status: ::std::os::raw::c_int),
>;
#[doc = " \\brief Represents a per-thread channel for accessing an I/O device."]
#[doc = ""]
#[doc = " An I/O device may be a physical entity (i.e. NVMe controller) or a software"]
#[doc = "  entity (i.e. a blobstore)."]
#[doc = ""]
#[doc = " This structure is not part of the API - all accesses should be done through"]
#[doc = "  spdk_io_channel function calls."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel {
    pub thread: *mut spdk_thread,
    pub dev: *mut io_device,
    pub ref_: u32,
    pub destroy_ref: u32,
    pub tailq: spdk_io_channel__bindgen_ty_1,
    pub destroy_cb: spdk_io_channel_destroy_cb,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_io_channel__bindgen_ty_1 {
    pub tqe_next: *mut spdk_io_channel,
    pub tqe_prev: *mut *mut spdk_io_channel,
}
#[test]
fn bindgen_test_layout_spdk_io_channel__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_io_channel__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_io_channel__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_io_channel__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_io_channel__bindgen_ty_1))
    );
    fn test_field_tqe_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel__bindgen_ty_1),
                "::",
                stringify!(tqe_next)
            )
        );
    }
    test_field_tqe_next();
    fn test_field_tqe_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel__bindgen_ty_1),
                "::",
                stringify!(tqe_prev)
            )
        );
    }
    test_field_tqe_prev();
}
#[test]
fn bindgen_test_layout_spdk_io_channel() {
    assert_eq!(
        ::std::mem::size_of::<spdk_io_channel>(),
        48usize,
        concat!("Size of: ", stringify!(spdk_io_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_io_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_io_channel))
    );
    fn test_field_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(thread)
            )
        );
    }
    test_field_thread();
    fn test_field_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(dev)
            )
        );
    }
    test_field_dev();
    fn test_field_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(ref_)
            )
        );
    }
    test_field_ref();
    fn test_field_destroy_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_ref) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(destroy_ref)
            )
        );
    }
    test_field_destroy_ref();
    fn test_field_tailq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tailq) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(tailq)
            )
        );
    }
    test_field_tailq();
    fn test_field_destroy_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_io_channel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).destroy_cb) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_io_channel),
                "::",
                stringify!(destroy_cb)
            )
        );
    }
    test_field_destroy_cb();
}
extern "C" {
    #[doc = " Initialize the threading library. Must be called once prior to allocating any threads."]
    #[doc = ""]
    #[doc = " \\param new_thread_fn Called each time a new SPDK thread is created. The implementor"]
    #[doc = " is expected to frequently call spdk_thread_poll() on the provided thread."]
    #[doc = " \\param ctx_sz For each thread allocated, an additional region of memory of"]
    #[doc = " size ctx_size will also be allocated, for use by the thread scheduler. A pointer"]
    #[doc = " to this region may be obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\return 0 on success. Negated errno on failure."]
    pub fn spdk_thread_lib_init(
        new_thread_fn: spdk_new_thread_fn,
        ctx_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize the threading library. Must be called once prior to allocating any threads"]
    #[doc = ""]
    #[doc = " Both thread_op_fn and thread_op_type_supported_fn have to be specified or not"]
    #[doc = " specified together."]
    #[doc = ""]
    #[doc = " \\param thread_op_fn Called for SPDK thread operation."]
    #[doc = " \\param thread_op_supported_fn Called to check whether the SPDK thread operation is supported."]
    #[doc = " \\param ctx_sz For each thread allocated, for use by the thread scheduler. A pointer"]
    #[doc = " to this region may be obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\return 0 on success. Negated errno on failure."]
    pub fn spdk_thread_lib_init_ext(
        thread_op_fn: spdk_thread_op_fn,
        thread_op_supported_fn: spdk_thread_op_supported_fn,
        ctx_sz: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release all resources associated with this library."]
    pub fn spdk_thread_lib_fini();
}
extern "C" {
    #[doc = " Creates a new SPDK thread object."]
    #[doc = ""]
    #[doc = " \\param name Human-readable name for the thread; can be retrieved with spdk_thread_get_name()."]
    #[doc = " The string is copied, so the pointed-to data only needs to be valid during the"]
    #[doc = " spdk_thread_create() call. May be NULL to specify no name."]
    #[doc = " \\param cpumask Optional mask of CPU cores on which to schedule this thread. This is only"]
    #[doc = " a suggestion to the scheduler. The value is copied, so cpumask may be released when"]
    #[doc = " this function returns. May be NULL if no mask is required."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated thread on success or NULL on failure.."]
    pub fn spdk_thread_create(
        name: *const ::std::os::raw::c_char,
        cpumask: *mut spdk_cpuset,
    ) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Force the current system thread to act as if executing the given SPDK thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to set."]
    pub fn spdk_set_thread(thread: *mut spdk_thread);
}
extern "C" {
    #[doc = " Mark the thread as exited, failing all future spdk_thread_send_msg(),"]
    #[doc = " spdk_poller_register(), and spdk_get_io_channel() calls. May only be called"]
    #[doc = " within an spdk poller or message."]
    #[doc = ""]
    #[doc = " All I/O channel references associated with the thread must be released"]
    #[doc = " using spdk_put_io_channel(), and all active pollers associated with the thread"]
    #[doc = " should be unregistered using spdk_poller_unregister(), prior to calling"]
    #[doc = " this function. This function will complete these processing. The completion can"]
    #[doc = " be queried by spdk_thread_is_exited()."]
    #[doc = ""]
    #[doc = " \\param thread The thread to destroy."]
    #[doc = ""]
    #[doc = " \\return always 0. (return value was deprecated but keep it for ABI compatibility.)"]
    pub fn spdk_thread_exit(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether the thread is marked as exited."]
    #[doc = ""]
    #[doc = " \\param thread The thread to query."]
    #[doc = ""]
    #[doc = " \\return true if marked as exited, false otherwise."]
    pub fn spdk_thread_is_exited(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Destroy a thread, releasing all of its resources. May only be called"]
    #[doc = " on a thread previously marked as exited."]
    #[doc = ""]
    #[doc = " \\param thread The thread to destroy."]
    #[doc = ""]
    pub fn spdk_thread_destroy(thread: *mut spdk_thread);
}
extern "C" {
    #[doc = " Return a pointer to this thread's context."]
    #[doc = ""]
    #[doc = " \\param thread The thread on which to get the context."]
    #[doc = ""]
    #[doc = " \\return a pointer to the per-thread context, or NULL if there is"]
    #[doc = " no per-thread context."]
    pub fn spdk_thread_get_ctx(thread: *mut spdk_thread) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the thread's cpumask."]
    #[doc = ""]
    #[doc = " \\param thread The thread to get the cpumask for."]
    #[doc = ""]
    #[doc = " \\return cpuset pointer"]
    pub fn spdk_thread_get_cpumask(thread: *mut spdk_thread) -> *mut spdk_cpuset;
}
extern "C" {
    #[doc = " Set the current thread's cpumask to the specified value. The thread may be"]
    #[doc = " rescheduled to one of the CPUs specified in the cpumask."]
    #[doc = ""]
    #[doc = " This API requires SPDK thread operation supports SPDK_THREAD_OP_RESCHED."]
    #[doc = ""]
    #[doc = " \\param cpumask The new cpumask for the thread."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negated errno otherwise."]
    pub fn spdk_thread_set_cpumask(cpumask: *mut spdk_cpuset) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the thread object associated with the context handle previously"]
    #[doc = " obtained by calling spdk_thread_get_ctx()."]
    #[doc = ""]
    #[doc = " \\param ctx A context previously obtained by calling spdk_thread_get_ctx()"]
    #[doc = ""]
    #[doc = " \\return The associated thread."]
    pub fn spdk_thread_get_from_ctx(ctx: *mut ::std::os::raw::c_void) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Perform one iteration worth of processing on the thread. This includes"]
    #[doc = " both expired and continuous pollers as well as messages. If the thread"]
    #[doc = " has exited, return immediately."]
    #[doc = ""]
    #[doc = " \\param thread The thread to process"]
    #[doc = " \\param max_msgs The maximum number of messages that will be processed."]
    #[doc = "                 Use 0 to process the default number of messages (8)."]
    #[doc = " \\param now The current time, in ticks. Optional. If 0 is passed, this"]
    #[doc = "            function will call spdk_get_ticks() to get the current time."]
    #[doc = "            The current time is used as start time and this function"]
    #[doc = "            will call spdk_get_ticks() at its end to know end time to"]
    #[doc = "            measure run time of this function."]
    #[doc = ""]
    #[doc = " \\return 1 if work was done. 0 if no work was done."]
    pub fn spdk_thread_poll(
        thread: *mut spdk_thread,
        max_msgs: u32,
        now: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of ticks until the next timed poller"]
    #[doc = " would expire. Timed pollers are pollers for which"]
    #[doc = " period_microseconds is greater than 0."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check poller expiration times on"]
    #[doc = ""]
    #[doc = " \\return Number of ticks. If no timed pollers, return 0."]
    pub fn spdk_thread_next_poller_expiration(thread: *mut spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Returns whether there are any active pollers (pollers for which"]
    #[doc = " period_microseconds equals 0) registered to be run on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return 1 if there is at least one active poller, 0 otherwise."]
    pub fn spdk_thread_has_active_pollers(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns whether there are any pollers registered to be run"]
    #[doc = " on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return true if there is any active poller, false otherwise."]
    pub fn spdk_thread_has_pollers(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Returns whether there are scheduled operations to be run on the thread."]
    #[doc = ""]
    #[doc = " \\param thread The thread to check."]
    #[doc = ""]
    #[doc = " \\return true if there are no scheduled operations, false otherwise."]
    pub fn spdk_thread_is_idle(thread: *mut spdk_thread) -> bool;
}
extern "C" {
    #[doc = " Get count of allocated threads."]
    pub fn spdk_thread_get_count() -> u32;
}
extern "C" {
    #[doc = " Get a handle to the current thread."]
    #[doc = ""]
    #[doc = " This handle may be passed to other threads and used as the target of"]
    #[doc = " spdk_thread_send_msg()."]
    #[doc = ""]
    #[doc = " \\sa spdk_io_channel_get_thread()"]
    #[doc = ""]
    #[doc = " \\return a pointer to the current thread on success or NULL on failure."]
    pub fn spdk_get_thread() -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Get a thread's name."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return the name of the thread."]
    pub fn spdk_thread_get_name(thread: *const spdk_thread) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get a thread's ID."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return the ID of the thread.."]
    pub fn spdk_thread_get_id(thread: *const spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Get the thread by the ID."]
    #[doc = ""]
    #[doc = " \\param id ID of the thread."]
    #[doc = " \\return Thread whose ID matches or NULL otherwise."]
    pub fn spdk_thread_get_by_id(id: u64) -> *mut spdk_thread;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_thread_stats {
    pub busy_tsc: u64,
    pub idle_tsc: u64,
}
#[test]
fn bindgen_test_layout_spdk_thread_stats() {
    assert_eq!(
        ::std::mem::size_of::<spdk_thread_stats>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_thread_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_thread_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_thread_stats))
    );
    fn test_field_busy_tsc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_thread_stats>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).busy_tsc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_thread_stats),
                "::",
                stringify!(busy_tsc)
            )
        );
    }
    test_field_busy_tsc();
    fn test_field_idle_tsc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_thread_stats>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).idle_tsc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_thread_stats),
                "::",
                stringify!(idle_tsc)
            )
        );
    }
    test_field_idle_tsc();
}
extern "C" {
    #[doc = " Get statistics about the current thread."]
    #[doc = ""]
    #[doc = " Copy cumulative thread stats values to the provided thread stats structure."]
    #[doc = ""]
    #[doc = " \\param stats User's thread_stats structure."]
    pub fn spdk_thread_get_stats(stats: *mut spdk_thread_stats) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the TSC value from the end of the last time this thread was polled."]
    #[doc = ""]
    #[doc = " \\param thread Thread to query."]
    #[doc = ""]
    #[doc = " \\return TSC value from the end of the last time this thread was polled."]
    pub fn spdk_thread_get_last_tsc(thread: *mut spdk_thread) -> u64;
}
extern "C" {
    #[doc = " Send a message to the given thread."]
    #[doc = ""]
    #[doc = " The message will be sent asynchronously - i.e. spdk_thread_send_msg will always return"]
    #[doc = " prior to `fn` being called."]
    #[doc = ""]
    #[doc = " \\param thread The target thread."]
    #[doc = " \\param fn This function will be called on the given thread."]
    #[doc = " \\param ctx This context will be passed to fn when called."]
    #[doc = ""]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -ENOMEM if the message could not be allocated"]
    #[doc = " \\return -EIO if the message could not be sent to the destination thread"]
    pub fn spdk_thread_send_msg(
        thread: *const spdk_thread,
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a message to the given thread. Only one critical message can be outstanding at the same"]
    #[doc = " time. It's intended to use this function in any cases that might interrupt the execution of the"]
    #[doc = " application, such as signal handlers."]
    #[doc = ""]
    #[doc = " The message will be sent asynchronously - i.e. spdk_thread_send_critical_msg will always return"]
    #[doc = " prior to `fn` being called."]
    #[doc = ""]
    #[doc = " \\param thread The target thread."]
    #[doc = " \\param fn This function will be called on the given thread."]
    #[doc = ""]
    #[doc = " \\return 0 on success"]
    #[doc = " \\return -EIO if the message could not be sent to the destination thread, due to an already"]
    #[doc = " outstanding critical message"]
    pub fn spdk_thread_send_critical_msg(
        thread: *mut spdk_thread,
        fn_: spdk_msg_fn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a message to each thread, serially."]
    #[doc = ""]
    #[doc = " The message is sent asynchronously - i.e. spdk_for_each_thread will return"]
    #[doc = " prior to `fn` being called on each thread."]
    #[doc = ""]
    #[doc = " \\param fn This is the function that will be called on each thread."]
    #[doc = " \\param ctx This context will be passed to fn when called."]
    #[doc = " \\param cpl This will be called on the originating thread after `fn` has been"]
    #[doc = " called on each thread."]
    pub fn spdk_for_each_thread(
        fn_: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
        cpl: spdk_msg_fn,
    );
}
extern "C" {
    #[doc = " Set current spdk_thread into interrupt mode or back to poll mode."]
    #[doc = ""]
    #[doc = " Only valid when thread interrupt facility is enabled by"]
    #[doc = " spdk_interrupt_mode_enable()."]
    #[doc = ""]
    #[doc = " \\param enable_interrupt Set interrupt mode for true, or poll mode for false"]
    pub fn spdk_thread_set_interrupt_mode(enable_interrupt: bool);
}
extern "C" {
    #[doc = " Register a poller on the current thread."]
    #[doc = ""]
    #[doc = " The poller can be unregistered by calling spdk_poller_unregister()."]
    #[doc = ""]
    #[doc = " \\param fn This function will be called every `period_microseconds`."]
    #[doc = " \\param arg Argument passed to fn."]
    #[doc = " \\param period_microseconds How often to call `fn`. If 0, call `fn` as often"]
    #[doc = "  as possible."]
    #[doc = ""]
    #[doc = " \\return a pointer to the poller registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_poller_register(
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
    ) -> *mut spdk_poller;
}
extern "C" {
    #[doc = " Register a poller on the current thread with arbitrary name."]
    #[doc = ""]
    #[doc = " The poller can be unregistered by calling spdk_poller_unregister()."]
    #[doc = ""]
    #[doc = " \\param fn This function will be called every `period_microseconds`."]
    #[doc = " \\param arg Argument passed to fn."]
    #[doc = " \\param period_microseconds How often to call `fn`. If 0, call `fn` as often"]
    #[doc = "  as possible."]
    #[doc = " \\param name Human readable name for the poller. Pointer of the poller function"]
    #[doc = " name is set if NULL."]
    #[doc = ""]
    #[doc = " \\return a pointer to the poller registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_poller_register_named(
        fn_: spdk_poller_fn,
        arg: *mut ::std::os::raw::c_void,
        period_microseconds: u64,
        name: *const ::std::os::raw::c_char,
    ) -> *mut spdk_poller;
}
extern "C" {
    #[doc = " Unregister a poller on the current thread."]
    #[doc = ""]
    #[doc = " \\param ppoller The poller to unregister."]
    pub fn spdk_poller_unregister(ppoller: *mut *mut spdk_poller);
}
extern "C" {
    #[doc = " Pause a poller on the current thread."]
    #[doc = ""]
    #[doc = " The poller is not run until it is resumed with spdk_poller_resume().  It is"]
    #[doc = " perfectly fine to pause an already paused poller."]
    #[doc = ""]
    #[doc = " \\param poller The poller to pause."]
    pub fn spdk_poller_pause(poller: *mut spdk_poller);
}
extern "C" {
    #[doc = " Resume a poller on the current thread."]
    #[doc = ""]
    #[doc = " Resumes a poller paused with spdk_poller_pause().  It is perfectly fine to"]
    #[doc = " resume an unpaused poller."]
    #[doc = ""]
    #[doc = " \\param poller The poller to resume."]
    pub fn spdk_poller_resume(poller: *mut spdk_poller);
}
extern "C" {
    #[doc = " Register the opaque io_device context as an I/O device."]
    #[doc = ""]
    #[doc = " After an I/O device is registered, it can return I/O channels using the"]
    #[doc = " spdk_get_io_channel() function."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = " \\param create_cb Callback function invoked to allocate any resources required"]
    #[doc = " for a new I/O channel."]
    #[doc = " \\param destroy_cb Callback function invoked to release the resources for an"]
    #[doc = " I/O channel."]
    #[doc = " \\param ctx_size The size of the context buffer allocated to store references"]
    #[doc = " to allocated I/O channel resources."]
    #[doc = " \\param name A string name for the device used only for debugging. Optional -"]
    #[doc = " may be NULL."]
    pub fn spdk_io_device_register(
        io_device: *mut ::std::os::raw::c_void,
        create_cb: spdk_io_channel_create_cb,
        destroy_cb: spdk_io_channel_destroy_cb,
        ctx_size: u32,
        name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Unregister the opaque io_device context as an I/O device."]
    #[doc = ""]
    #[doc = " The actual unregistration might be deferred until all active I/O channels are"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = " \\param unregister_cb An optional callback function invoked to release any"]
    #[doc = " references to this I/O device."]
    pub fn spdk_io_device_unregister(
        io_device: *mut ::std::os::raw::c_void,
        unregister_cb: spdk_io_device_unregister_cb,
    );
}
extern "C" {
    #[doc = " Get an I/O channel for the specified io_device to be used by the calling thread."]
    #[doc = ""]
    #[doc = " The io_device context pointer specified must have previously been registered"]
    #[doc = " using spdk_io_device_register(). If an existing I/O channel does not exist"]
    #[doc = " yet for the given io_device on the calling thread, it will allocate an I/O"]
    #[doc = " channel and invoke the create_cb function pointer specified in spdk_io_device_register()."]
    #[doc = " If an I/O channel already exists for the given io_device on the calling thread,"]
    #[doc = " its reference is returned rather than creating a new I/O channel."]
    #[doc = ""]
    #[doc = " \\param io_device The pointer to io_device context."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel for this device on success or NULL on failure."]
    pub fn spdk_get_io_channel(io_device: *mut ::std::os::raw::c_void) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Release a reference to an I/O channel. This happens asynchronously."]
    #[doc = ""]
    #[doc = " This must be called on the same thread that called spdk_get_io_channel()"]
    #[doc = " for the specified I/O channel. If this releases the last reference to the"]
    #[doc = " I/O channel, The destroy_cb function specified in spdk_io_device_register()"]
    #[doc = " will be invoked to release any associated resources."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel to release a reference."]
    pub fn spdk_put_io_channel(ch: *mut spdk_io_channel);
}
extern "C" {
    #[doc = " Get I/O channel from the context buffer. This is the inverse of"]
    #[doc = " spdk_io_channel_get_ctx()."]
    #[doc = ""]
    #[doc = " \\param ctx The pointer to the context buffer."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel associated with the context buffer."]
    pub fn spdk_io_channel_from_ctx(ctx: *mut ::std::os::raw::c_void) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Get the thread associated with an I/O channel."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel."]
    #[doc = ""]
    #[doc = " \\return a pointer to the thread associated with the I/O channel"]
    pub fn spdk_io_channel_get_thread(ch: *mut spdk_io_channel) -> *mut spdk_thread;
}
extern "C" {
    #[doc = " Call 'fn' on each channel associated with io_device."]
    #[doc = ""]
    #[doc = " This happens asynchronously, so fn may be called after spdk_for_each_channel"]
    #[doc = " returns. 'fn' will be called for each channel serially, such that two calls"]
    #[doc = " to 'fn' will not overlap in time. After 'fn' has been called, call"]
    #[doc = " spdk_for_each_channel_continue() to continue iterating."]
    #[doc = ""]
    #[doc = " \\param io_device 'fn' will be called on each channel associated with this io_device."]
    #[doc = " \\param fn Called on the appropriate thread for each channel associated with io_device."]
    #[doc = " \\param ctx Context buffer registered to spdk_io_channel_iter that can be obatined"]
    #[doc = " form the function spdk_io_channel_iter_get_ctx()."]
    #[doc = " \\param cpl Called on the thread that spdk_for_each_channel was initially called"]
    #[doc = " from when 'fn' has been called on each channel."]
    pub fn spdk_for_each_channel(
        io_device: *mut ::std::os::raw::c_void,
        fn_: spdk_channel_msg,
        ctx: *mut ::std::os::raw::c_void,
        cpl: spdk_channel_for_each_cpl,
    );
}
extern "C" {
    #[doc = " Get io_device from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the io_device."]
    pub fn spdk_io_channel_iter_get_io_device(
        i: *mut spdk_io_channel_iter,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get I/O channel from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the I/O channel."]
    pub fn spdk_io_channel_iter_get_channel(i: *mut spdk_io_channel_iter) -> *mut spdk_io_channel;
}
extern "C" {
    #[doc = " Get context buffer from the I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = ""]
    #[doc = " \\return a pointer to the context buffer."]
    pub fn spdk_io_channel_iter_get_ctx(
        i: *mut spdk_io_channel_iter,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get the io_device for the specified I/O channel."]
    #[doc = ""]
    #[doc = " \\param ch I/O channel."]
    #[doc = ""]
    #[doc = " \\return a pointer to the io_device for the I/O channel"]
    pub fn spdk_io_channel_get_io_device(ch: *mut spdk_io_channel) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Helper function to iterate all channels for spdk_for_each_channel()."]
    #[doc = ""]
    #[doc = " \\param i I/O channel iterator."]
    #[doc = " \\param status Status for the I/O channel iterator."]
    pub fn spdk_for_each_channel_continue(
        i: *mut spdk_io_channel_iter,
        status: ::std::os::raw::c_int,
    );
}
#[doc = " A representative for registered interrupt file descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_interrupt {
    _unused: [u8; 0],
}
#[doc = " Callback function registered for interrupt file descriptor."]
#[doc = ""]
#[doc = " \\param ctx Context passed as arg to spdk_interrupt_register()."]
#[doc = ""]
#[doc = " \\return 0 to indicate that interrupt took place but no events were found;"]
#[doc = " positive to indicate that interrupt took place and some events were processed;"]
#[doc = " negative if no event information is provided."]
pub type spdk_interrupt_fn = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Register an spdk_interrupt on the current thread. The provided function"]
    #[doc = " will be called any time the associated file descriptor is written to."]
    #[doc = ""]
    #[doc = " \\param efd File descriptor of the spdk_interrupt."]
    #[doc = " \\param fn Called each time there are events in spdk_interrupt."]
    #[doc = " \\param arg Function argument for fn."]
    #[doc = " \\param name Human readable name for the spdk_interrupt. Pointer of the spdk_interrupt"]
    #[doc = " name is set if NULL."]
    #[doc = ""]
    #[doc = " \\return a pointer to the spdk_interrupt registered on the current thread on success"]
    #[doc = " or NULL on failure."]
    pub fn spdk_interrupt_register(
        efd: ::std::os::raw::c_int,
        fn_: spdk_interrupt_fn,
        arg: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
    ) -> *mut spdk_interrupt;
}
extern "C" {
    #[doc = " Unregister an spdk_interrupt on the current thread."]
    #[doc = ""]
    #[doc = " \\param pintr The spdk_interrupt to unregister."]
    pub fn spdk_interrupt_unregister(pintr: *mut *mut spdk_interrupt);
}
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_IN: spdk_interrupt_event_types = 1;
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_OUT: spdk_interrupt_event_types = 4;
pub const spdk_interrupt_event_types_SPDK_INTERRUPT_EVENT_ET: spdk_interrupt_event_types =
    2147483648;
pub type spdk_interrupt_event_types = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Change the event_types associated with the spdk_interrupt on the current thread."]
    #[doc = ""]
    #[doc = " \\param intr The pointer to the spdk_interrupt registered on the current thread."]
    #[doc = " \\param event_types New event_types for the spdk_interrupt."]
    #[doc = ""]
    #[doc = " \\return 0 if success or -errno if failed."]
    pub fn spdk_interrupt_set_event_types(
        intr: *mut spdk_interrupt,
        event_types: spdk_interrupt_event_types,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a file descriptor that becomes ready whenever any of the registered"]
    #[doc = " interrupt file descriptors are ready"]
    #[doc = ""]
    #[doc = " \\param thread The thread to get."]
    #[doc = ""]
    #[doc = " \\return The spdk_interrupt fd of thread itself."]
    pub fn spdk_thread_get_interrupt_fd(thread: *mut spdk_thread) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set SPDK run as event driven mode"]
    #[doc = ""]
    #[doc = " \\return 0 on success or -errno on failure"]
    pub fn spdk_interrupt_mode_enable() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reports whether interrupt mode is set."]
    #[doc = ""]
    #[doc = " \\return True if interrupt mode is set, false otherwise."]
    pub fn spdk_interrupt_mode_is_enabled() -> bool;
}
#[doc = " Event handler function."]
#[doc = ""]
#[doc = " \\param arg1 Argument 1."]
#[doc = " \\param arg2 Argument 2."]
pub type spdk_event_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " \\brief An event is a function that is passed to and called on an lcore."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_event {
    _unused: [u8; 0],
}
#[doc = " Callback function for customized shutdown handling of application."]
pub type spdk_app_shutdown_cb = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Signal handler fucntion."]
#[doc = ""]
#[doc = " \\param signal Signal number."]
pub type spdk_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(signal: ::std::os::raw::c_int)>;
#[doc = " \\brief Event framework initialization options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_app_opts {
    pub name: *const ::std::os::raw::c_char,
    pub json_config_file: *const ::std::os::raw::c_char,
    pub json_config_ignore_errors: bool,
    pub rpc_addr: *const ::std::os::raw::c_char,
    pub reactor_mask: *const ::std::os::raw::c_char,
    pub tpoint_group_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub shutdown_cb: spdk_app_shutdown_cb,
    pub enable_coredump: bool,
    pub mem_channel: ::std::os::raw::c_int,
    pub main_core: ::std::os::raw::c_int,
    pub mem_size: ::std::os::raw::c_int,
    pub no_pci: bool,
    pub hugepage_single_segments: bool,
    pub unlink_hugepage: bool,
    pub hugedir: *const ::std::os::raw::c_char,
    pub print_level: spdk_log_level,
    pub num_pci_addr: size_t,
    pub pci_blocked: *mut spdk_pci_addr,
    pub pci_allowed: *mut spdk_pci_addr,
    pub iova_mode: *const ::std::os::raw::c_char,
    pub delay_subsystem_init: bool,
    pub num_entries: u64,
    #[doc = " Opaque context for use of the env implementation."]
    pub env_context: *mut ::std::os::raw::c_void,
    #[doc = " for passing user-provided log call"]
    pub log: logfunc,
    pub base_virtaddr: u64,
    #[doc = " The size of spdk_app_opts according to the caller of this library is used for ABI"]
    #[doc = " compatibility. The library uses this field to know how many fields in this"]
    #[doc = " structure are valid. And the library will populate any remaining fields with default values."]
    #[doc = " After that, new added fields should be put after opts_size."]
    pub opts_size: size_t,
}
#[test]
fn bindgen_test_layout_spdk_app_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_app_opts>(),
        184usize,
        concat!("Size of: ", stringify!(spdk_app_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_app_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_app_opts))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_json_config_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).json_config_file) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(json_config_file)
            )
        );
    }
    test_field_json_config_file();
    fn test_field_json_config_ignore_errors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).json_config_ignore_errors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(json_config_ignore_errors)
            )
        );
    }
    test_field_json_config_ignore_errors();
    fn test_field_rpc_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rpc_addr) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(rpc_addr)
            )
        );
    }
    test_field_rpc_addr();
    fn test_field_reactor_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reactor_mask) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(reactor_mask)
            )
        );
    }
    test_field_reactor_mask();
    fn test_field_tpoint_group_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tpoint_group_mask) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(tpoint_group_mask)
            )
        );
    }
    test_field_tpoint_group_mask();
    fn test_field_shm_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shm_id) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(shm_id)
            )
        );
    }
    test_field_shm_id();
    fn test_field_shutdown_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shutdown_cb) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(shutdown_cb)
            )
        );
    }
    test_field_shutdown_cb();
    fn test_field_enable_coredump() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enable_coredump) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(enable_coredump)
            )
        );
    }
    test_field_enable_coredump();
    fn test_field_mem_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_channel) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(mem_channel)
            )
        );
    }
    test_field_mem_channel();
    fn test_field_main_core() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_core) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(main_core)
            )
        );
    }
    test_field_main_core();
    fn test_field_mem_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(mem_size)
            )
        );
    }
    test_field_mem_size();
    fn test_field_no_pci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).no_pci) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(no_pci)
            )
        );
    }
    test_field_no_pci();
    fn test_field_hugepage_single_segments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugepage_single_segments) as usize - ptr as usize
            },
            81usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(hugepage_single_segments)
            )
        );
    }
    test_field_hugepage_single_segments();
    fn test_field_unlink_hugepage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink_hugepage) as usize - ptr as usize
            },
            82usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(unlink_hugepage)
            )
        );
    }
    test_field_unlink_hugepage();
    fn test_field_hugedir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugedir) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(hugedir)
            )
        );
    }
    test_field_hugedir();
    fn test_field_print_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).print_level) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(print_level)
            )
        );
    }
    test_field_print_level();
    fn test_field_num_pci_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_pci_addr) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(num_pci_addr)
            )
        );
    }
    test_field_num_pci_addr();
    fn test_field_pci_blocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_blocked) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(pci_blocked)
            )
        );
    }
    test_field_pci_blocked();
    fn test_field_pci_allowed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_allowed) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(pci_allowed)
            )
        );
    }
    test_field_pci_allowed();
    fn test_field_iova_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iova_mode) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(iova_mode)
            )
        );
    }
    test_field_iova_mode();
    fn test_field_delay_subsystem_init() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delay_subsystem_init) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(delay_subsystem_init)
            )
        );
    }
    test_field_delay_subsystem_init();
    fn test_field_num_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(num_entries)
            )
        );
    }
    test_field_num_entries();
    fn test_field_env_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).env_context) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(env_context)
            )
        );
    }
    test_field_env_context();
    fn test_field_log() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(log)
            )
        );
    }
    test_field_log();
    fn test_field_base_virtaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_virtaddr) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(base_virtaddr)
            )
        );
    }
    test_field_base_virtaddr();
    fn test_field_opts_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_app_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opts_size) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_app_opts),
                "::",
                stringify!(opts_size)
            )
        );
    }
    test_field_opts_size();
}
extern "C" {
    #[doc = " Initialize the default value of opts"]
    #[doc = ""]
    #[doc = " \\param opts Data structure where SPDK will initialize the default options."]
    #[doc = " \\param opts_size Must be set to sizeof(struct spdk_app_opts)."]
    pub fn spdk_app_opts_init(opts: *mut spdk_app_opts, opts_size: size_t);
}
extern "C" {
    #[doc = " Start the framework."]
    #[doc = ""]
    #[doc = " Before calling this function, opts must be initialized by"]
    #[doc = " spdk_app_opts_init(). Once started, the framework will call start_fn on"]
    #[doc = " an spdk_thread running on the current system thread with the"]
    #[doc = " argument provided."]
    #[doc = ""]
    #[doc = " If opts->delay_subsystem_init is set"]
    #[doc = " (e.g. through --wait-for-rpc flag in spdk_app_parse_args())"]
    #[doc = " this function will only start a limited RPC server accepting"]
    #[doc = " only a few RPC commands - mostly related to pre-initialization."]
    #[doc = " With this option, the framework won't be started and start_fn"]
    #[doc = " won't be called until the user sends an `rpc_framework_start_init`"]
    #[doc = " RPC command, which marks the pre-initialization complete and"]
    #[doc = " allows start_fn to be finally called."]
    #[doc = ""]
    #[doc = " This call will block until spdk_app_stop() is called. If an error"]
    #[doc = " condition occurs during the intialization code within spdk_app_start(),"]
    #[doc = " this function will immediately return before invoking start_fn."]
    #[doc = ""]
    #[doc = " \\param opts_user Initialization options used for this application. It should not be"]
    #[doc = "             NULL. And the opts_size value inside the opts structure should not be zero."]
    #[doc = " \\param start_fn Entry point that will execute on an internally created thread"]
    #[doc = "                 once the framework has been started."]
    #[doc = " \\param ctx Argument passed to function start_fn."]
    #[doc = ""]
    #[doc = " \\return 0 on success or non-zero on failure."]
    pub fn spdk_app_start(
        opts_user: *mut spdk_app_opts,
        start_fn: spdk_msg_fn,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform final shutdown operations on an application using the event framework."]
    pub fn spdk_app_fini();
}
extern "C" {
    #[doc = " Start shutting down the framework."]
    #[doc = ""]
    #[doc = " Typically this function is not called directly, and the shutdown process is"]
    #[doc = " started implicitly by a process signal. But in applications that are using"]
    #[doc = " SPDK for a subset of its process threads, this function can be called in lieu"]
    #[doc = " of a signal."]
    pub fn spdk_app_start_shutdown();
}
extern "C" {
    #[doc = " Stop the framework."]
    #[doc = ""]
    #[doc = " This does not wait for all threads to exit. Instead, it kicks off the shutdown"]
    #[doc = " process and returns. Once the shutdown process is complete, spdk_app_start()"]
    #[doc = " will return."]
    #[doc = ""]
    #[doc = " \\param rc The rc value specified here will be returned to caller of spdk_app_start()."]
    pub fn spdk_app_stop(rc: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Return the shared memory id for this application."]
    #[doc = ""]
    #[doc = " \\return shared memory id."]
    pub fn spdk_app_get_shm_id() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string containing a CPU core mask into a bitmask"]
    #[doc = ""]
    #[doc = " \\param mask String containing a CPU core mask."]
    #[doc = " \\param cpumask Bitmask of CPU cores."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_app_parse_core_mask(
        mask: *const ::std::os::raw::c_char,
        cpumask: *mut spdk_cpuset,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the mask of the CPU cores active for this application"]
    #[doc = ""]
    #[doc = " \\return the bitmask of the active CPU cores."]
    pub fn spdk_app_get_core_mask() -> *const spdk_cpuset;
}
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_HELP: spdk_app_parse_args_rvals = 0;
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_SUCCESS: spdk_app_parse_args_rvals = 1;
pub const spdk_app_parse_args_rvals_SPDK_APP_PARSE_ARGS_FAIL: spdk_app_parse_args_rvals = 2;
pub type spdk_app_parse_args_rvals = ::std::os::raw::c_uint;
pub use self::spdk_app_parse_args_rvals as spdk_app_parse_args_rvals_t;
extern "C" {
    #[doc = " Helper function for parsing arguments and printing usage messages."]
    #[doc = ""]
    #[doc = " \\param argc Count of arguments in argv parameter array."]
    #[doc = " \\param argv Array of command line arguments."]
    #[doc = " \\param opts Default options for the application."]
    #[doc = " \\param getopt_str String representing the app-specific command line parameters."]
    #[doc = " Characters in this string must not conflict with characters in SPDK_APP_GETOPT_STRING."]
    #[doc = " \\param app_long_opts Array of full-name parameters. Can be NULL."]
    #[doc = " \\param parse Function pointer to call if an argument in getopt_str is found."]
    #[doc = " \\param usage Function pointer to print usage messages for app-specific command"]
    #[doc = "\t\tline parameters."]
    #[doc = "\\return SPDK_APP_PARSE_ARGS_FAIL on failure, SPDK_APP_PARSE_ARGS_SUCCESS on"]
    #[doc = "        success, SPDK_APP_PARSE_ARGS_HELP if '-h' passed as an option."]
    pub fn spdk_app_parse_args(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        opts: *mut spdk_app_opts,
        getopt_str: *const ::std::os::raw::c_char,
        app_long_opts: *mut option,
        parse: ::std::option::Option<
            unsafe extern "C" fn(
                ch: ::std::os::raw::c_int,
                arg: *mut ::std::os::raw::c_char,
            ) -> ::std::os::raw::c_int,
        >,
        usage: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> spdk_app_parse_args_rvals_t;
}
extern "C" {
    #[doc = " Print usage strings for common SPDK command line options."]
    #[doc = ""]
    #[doc = " May only be called after spdk_app_parse_args()."]
    pub fn spdk_app_usage();
}
extern "C" {
    #[doc = " Allocate an event to be passed to spdk_event_call()."]
    #[doc = ""]
    #[doc = " \\param lcore Lcore to run this event."]
    #[doc = " \\param fn Function used to execute event."]
    #[doc = " \\param arg1 Argument passed to function fn."]
    #[doc = " \\param arg2 Argument passed to function fn."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated event."]
    pub fn spdk_event_allocate(
        lcore: u32,
        fn_: spdk_event_fn,
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> *mut spdk_event;
}
extern "C" {
    #[doc = " Pass the given event to the associated lcore and call the function."]
    #[doc = ""]
    #[doc = " \\param event Event to execute."]
    pub fn spdk_event_call(event: *mut spdk_event);
}
extern "C" {
    #[doc = " Enable or disable monitoring of context switches."]
    #[doc = ""]
    #[doc = " \\param enabled True to enable, false to disable."]
    pub fn spdk_framework_enable_context_switch_monitor(enabled: bool);
}
extern "C" {
    #[doc = " Return whether context switch monitoring is enabled."]
    #[doc = ""]
    #[doc = " \\return true if enabled or false otherwise."]
    pub fn spdk_framework_context_switch_monitor_enabled() -> bool;
}
#[doc = " \\brief Environment initialization options"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_env_opts {
    pub name: *const ::std::os::raw::c_char,
    pub core_mask: *const ::std::os::raw::c_char,
    pub shm_id: ::std::os::raw::c_int,
    pub mem_channel: ::std::os::raw::c_int,
    pub main_core: ::std::os::raw::c_int,
    pub mem_size: ::std::os::raw::c_int,
    pub no_pci: bool,
    pub hugepage_single_segments: bool,
    pub unlink_hugepage: bool,
    pub num_pci_addr: size_t,
    pub hugedir: *const ::std::os::raw::c_char,
    pub pci_blocked: *mut spdk_pci_addr,
    pub pci_allowed: *mut spdk_pci_addr,
    pub iova_mode: *const ::std::os::raw::c_char,
    pub base_virtaddr: u64,
    #[doc = " Opaque context for use of the env implementation."]
    pub env_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_spdk_env_opts() {
    assert_eq!(
        ::std::mem::size_of::<spdk_env_opts>(),
        96usize,
        concat!("Size of: ", stringify!(spdk_env_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_env_opts>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_env_opts))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_core_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).core_mask) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(core_mask)
            )
        );
    }
    test_field_core_mask();
    fn test_field_shm_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shm_id) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(shm_id)
            )
        );
    }
    test_field_shm_id();
    fn test_field_mem_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_channel) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(mem_channel)
            )
        );
    }
    test_field_mem_channel();
    fn test_field_main_core() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_core) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(main_core)
            )
        );
    }
    test_field_main_core();
    fn test_field_mem_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mem_size) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(mem_size)
            )
        );
    }
    test_field_mem_size();
    fn test_field_no_pci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).no_pci) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(no_pci)
            )
        );
    }
    test_field_no_pci();
    fn test_field_hugepage_single_segments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugepage_single_segments) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(hugepage_single_segments)
            )
        );
    }
    test_field_hugepage_single_segments();
    fn test_field_unlink_hugepage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unlink_hugepage) as usize - ptr as usize
            },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(unlink_hugepage)
            )
        );
    }
    test_field_unlink_hugepage();
    fn test_field_num_pci_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_pci_addr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(num_pci_addr)
            )
        );
    }
    test_field_num_pci_addr();
    fn test_field_hugedir() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hugedir) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(hugedir)
            )
        );
    }
    test_field_hugedir();
    fn test_field_pci_blocked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_blocked) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(pci_blocked)
            )
        );
    }
    test_field_pci_blocked();
    fn test_field_pci_allowed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pci_allowed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(pci_allowed)
            )
        );
    }
    test_field_pci_allowed();
    fn test_field_iova_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iova_mode) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(iova_mode)
            )
        );
    }
    test_field_iova_mode();
    fn test_field_base_virtaddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_virtaddr) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(base_virtaddr)
            )
        );
    }
    test_field_base_virtaddr();
    fn test_field_env_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_env_opts>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).env_context) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_env_opts),
                "::",
                stringify!(env_context)
            )
        );
    }
    test_field_env_context();
}
extern "C" {
    #[doc = " Allocate dma/sharable memory based on a given dma_flg. It is a memory buffer"]
    #[doc = " with the given size, alignment and socket id."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr **Deprecated**. Please use spdk_vtophys() for retrieving physical"]
    #[doc = " addresses. A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = " \\param flags Combination of SPDK_MALLOC flags (\\ref SPDK_MALLOC_DMA, \\ref SPDK_MALLOC_SHARE)."]
    #[doc = " At least one flag must be specified."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_malloc(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
        flags: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate dma/sharable memory based on a given dma_flg. It is a memory buffer"]
    #[doc = " with the given size, alignment and socket id. Also, the buffer will be zeroed."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr **Deprecated**. Please use spdk_vtophys() for retrieving physical"]
    #[doc = " addresses. A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = " \\param flags Combination of SPDK_MALLOC flags (\\ref SPDK_MALLOC_DMA, \\ref SPDK_MALLOC_SHARE)."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_zmalloc(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
        flags: u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Resize a dma/sharable memory buffer with the given new size and alignment."]
    #[doc = " Existing contents are preserved."]
    #[doc = ""]
    #[doc = " \\param buf Buffer to resize."]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = ""]
    #[doc = " \\return a pointer to the resized memory buffer."]
    pub fn spdk_realloc(
        buf: *mut ::std::os::raw::c_void,
        size: size_t,
        align: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free buffer memory that was previously allocated with spdk_malloc() or spdk_zmalloc()."]
    #[doc = ""]
    #[doc = " \\param buf Buffer to free."]
    pub fn spdk_free(buf: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialize the default value of opts."]
    #[doc = ""]
    #[doc = " \\param opts Data structure where SPDK will initialize the default options."]
    pub fn spdk_env_opts_init(opts: *mut spdk_env_opts);
}
extern "C" {
    #[doc = " Initialize or reinitialize the environment library."]
    #[doc = " For initialization, this must be called prior to using any other functions"]
    #[doc = " in this library. For reinitialization, the parameter `opts` must be set to"]
    #[doc = " NULL and this must be called after the environment library was finished by"]
    #[doc = " spdk_env_fini() within the same process."]
    #[doc = ""]
    #[doc = " \\param opts Environment initialization options."]
    #[doc = " \\return 0 on success, or negative errno on failure."]
    pub fn spdk_env_init(opts: *const spdk_env_opts) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Release any resources of the environment library that were allocated with"]
    #[doc = " spdk_env_init(). After this call, no SPDK env function calls may be made."]
    #[doc = " It is expected that common usage of this function is to call it just before"]
    #[doc = " terminating the process or before reinitializing the environment library"]
    #[doc = " within the same process."]
    pub fn spdk_env_fini();
}
extern "C" {
    #[doc = " Allocate a pinned memory buffer with the given size and alignment."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_dma_malloc(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a pinned, memory buffer with the given size, alignment and socket id."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_dma_malloc_socket(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a pinned memory buffer with the given size and alignment. The buffer"]
    #[doc = " will be zeroed."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_dma_zmalloc(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Allocate a pinned memory buffer with the given size, alignment and socket id."]
    #[doc = " The buffer will be zeroed."]
    #[doc = ""]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory buffer."]
    pub fn spdk_dma_zmalloc_socket(
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Resize the allocated and pinned memory buffer with the given new size and"]
    #[doc = " alignment. Existing contents are preserved."]
    #[doc = ""]
    #[doc = " \\param buf Buffer to resize."]
    #[doc = " \\param size Size in bytes."]
    #[doc = " \\param align If non-zero, the allocated buffer is aligned to a multiple of"]
    #[doc = " align. In this case, it must be a power of two. The returned buffer is always"]
    #[doc = " aligned to at least cache line size."]
    #[doc = " \\param phys_addr A pointer to the variable to hold the physical address of"]
    #[doc = " the allocated buffer is passed. If NULL, the physical address is not returned."]
    #[doc = ""]
    #[doc = " \\return a pointer to the resized memory buffer."]
    pub fn spdk_dma_realloc(
        buf: *mut ::std::os::raw::c_void,
        size: size_t,
        align: size_t,
        phys_addr: *mut u64,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free a memory buffer previously allocated, for example from spdk_dma_zmalloc()."]
    #[doc = " This call is never made from the performance path."]
    #[doc = ""]
    #[doc = " \\param buf Buffer to free."]
    pub fn spdk_dma_free(buf: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Reserve a named, process shared memory zone with the given size, socket_id"]
    #[doc = " and flags. Unless `SPDK_MEMZONE_NO_IOVA_CONTIG` flag is provided, the returned"]
    #[doc = " memory will be IOVA contiguous."]
    #[doc = ""]
    #[doc = " \\param name Name to set for this memory zone."]
    #[doc = " \\param len Length in bytes."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = " \\param flags Flags to set for this memory zone."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory address on success, or NULL on failure."]
    pub fn spdk_memzone_reserve(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reserve a named, process shared memory zone with the given size, socket_id,"]
    #[doc = " flags and alignment. Unless `SPDK_MEMZONE_NO_IOVA_CONTIG` flag is provided,"]
    #[doc = " the returned memory will be IOVA contiguous."]
    #[doc = ""]
    #[doc = " \\param name Name to set for this memory zone."]
    #[doc = " \\param len Length in bytes."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = " \\param flags Flags to set for this memory zone."]
    #[doc = " \\param align Alignment for resulting memzone. Must be a power of 2."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated memory address on success, or NULL on failure."]
    pub fn spdk_memzone_reserve_aligned(
        name: *const ::std::os::raw::c_char,
        len: size_t,
        socket_id: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Lookup the memory zone identified by the given name."]
    #[doc = ""]
    #[doc = " \\param name Name of the memory zone."]
    #[doc = ""]
    #[doc = " \\return a pointer to the reserved memory address on success, or NULL on failure."]
    pub fn spdk_memzone_lookup(name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Free the memory zone identified by the given name."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_memzone_free(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Dump debug information about all memzones."]
    #[doc = ""]
    #[doc = " \\param f File to write debug information to."]
    pub fn spdk_memzone_dump(f: *mut FILE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mempool {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a thread-safe memory pool."]
    #[doc = ""]
    #[doc = " \\param name Name for the memory pool."]
    #[doc = " \\param count Count of elements."]
    #[doc = " \\param ele_size Element size in bytes."]
    #[doc = " \\param cache_size How many elements may be cached in per-core caches. Use"]
    #[doc = " SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = ""]
    #[doc = " \\return a pointer to the created memory pool."]
    pub fn spdk_mempool_create(
        name: *const ::std::os::raw::c_char,
        count: size_t,
        ele_size: size_t,
        cache_size: size_t,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut spdk_mempool;
}
#[doc = " An object callback function for memory pool."]
#[doc = ""]
#[doc = " Used by spdk_mempool_create_ctor()."]
pub type spdk_mempool_obj_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut spdk_mempool,
        opaque: *mut ::std::os::raw::c_void,
        obj: *mut ::std::os::raw::c_void,
        obj_idx: ::std::os::raw::c_uint,
    ),
>;
extern "C" {
    #[doc = " Create a thread-safe memory pool with user provided initialization function"]
    #[doc = " and argument."]
    #[doc = ""]
    #[doc = " \\param name Name for the memory pool."]
    #[doc = " \\param count Count of elements."]
    #[doc = " \\param ele_size Element size in bytes."]
    #[doc = " \\param cache_size How many elements may be cached in per-core caches. Use"]
    #[doc = " SPDK_MEMPOOL_DEFAULT_CACHE_SIZE for a reasonable default, or 0 for no per-core cache."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = " \\param obj_init User provided object calllback initialization function."]
    #[doc = " \\param obj_init_arg User provided callback initialization function argument."]
    #[doc = ""]
    #[doc = " \\return a pointer to the created memory pool."]
    pub fn spdk_mempool_create_ctor(
        name: *const ::std::os::raw::c_char,
        count: size_t,
        ele_size: size_t,
        cache_size: size_t,
        socket_id: ::std::os::raw::c_int,
        obj_init: spdk_mempool_obj_cb_t,
        obj_init_arg: *mut ::std::os::raw::c_void,
    ) -> *mut spdk_mempool;
}
extern "C" {
    #[doc = " Get the name of a memory pool."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to query."]
    #[doc = ""]
    #[doc = " \\return the name of the memory pool."]
    pub fn spdk_mempool_get_name(mp: *mut spdk_mempool) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Free a memory pool."]
    pub fn spdk_mempool_free(mp: *mut spdk_mempool);
}
extern "C" {
    #[doc = " Get an element from a memory pool. If no elements remain, return NULL."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to query."]
    #[doc = ""]
    #[doc = " \\return a pointer to the element."]
    pub fn spdk_mempool_get(mp: *mut spdk_mempool) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Get multiple elements from a memory pool."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to get multiple elements from."]
    #[doc = " \\param ele_arr Array of the elements to fill."]
    #[doc = " \\param count Count of elements to get."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_mempool_get_bulk(
        mp: *mut spdk_mempool,
        ele_arr: *mut *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Put an element back into the memory pool."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to put element back into."]
    #[doc = " \\param ele Element to put."]
    pub fn spdk_mempool_put(mp: *mut spdk_mempool, ele: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Put multiple elements back into the memory pool."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to put multiple elements back into."]
    #[doc = " \\param ele_arr Array of the elements to put."]
    #[doc = " \\param count Count of elements to put."]
    pub fn spdk_mempool_put_bulk(
        mp: *mut spdk_mempool,
        ele_arr: *mut *mut ::std::os::raw::c_void,
        count: size_t,
    );
}
extern "C" {
    #[doc = " Get the number of entries in the memory pool."]
    #[doc = ""]
    #[doc = " \\param pool Memory pool to query."]
    #[doc = ""]
    #[doc = " \\return the number of entries in the memory pool."]
    pub fn spdk_mempool_count(pool: *const spdk_mempool) -> size_t;
}
extern "C" {
    #[doc = " Iterate through all elements of the pool and call a function on each one."]
    #[doc = ""]
    #[doc = " \\param mp Memory pool to iterate on."]
    #[doc = " \\param obj_cb Function to call on each element."]
    #[doc = " \\param obj_cb_arg Opaque pointer passed to the callback function."]
    #[doc = ""]
    #[doc = " \\return Number of elements iterated."]
    pub fn spdk_mempool_obj_iter(
        mp: *mut spdk_mempool,
        obj_cb: spdk_mempool_obj_cb_t,
        obj_cb_arg: *mut ::std::os::raw::c_void,
    ) -> u32;
}
extern "C" {
    #[doc = " Lookup the memory pool identified by the given name."]
    #[doc = ""]
    #[doc = " \\param name Name of the memory pool."]
    #[doc = ""]
    #[doc = " \\return a pointer to the memory pool on success, or NULL on failure."]
    pub fn spdk_mempool_lookup(name: *const ::std::os::raw::c_char) -> *mut spdk_mempool;
}
extern "C" {
    #[doc = " Get the number of dedicated CPU cores utilized by this env abstraction."]
    #[doc = ""]
    #[doc = " \\return the number of dedicated CPU cores."]
    pub fn spdk_env_get_core_count() -> u32;
}
extern "C" {
    #[doc = " Get the CPU core index of the current thread."]
    #[doc = ""]
    #[doc = " This will only function when called from threads set up by"]
    #[doc = " this environment abstraction. For any other threads \\c SPDK_ENV_LCORE_ID_ANY"]
    #[doc = " will be returned."]
    #[doc = ""]
    #[doc = " \\return the CPU core index of the current thread."]
    pub fn spdk_env_get_current_core() -> u32;
}
extern "C" {
    #[doc = " Get the index of the first dedicated CPU core for this application."]
    #[doc = ""]
    #[doc = " \\return the index of the first dedicated CPU core."]
    pub fn spdk_env_get_first_core() -> u32;
}
extern "C" {
    #[doc = " Get the index of the last dedicated CPU core for this application."]
    #[doc = ""]
    #[doc = " \\return the index of the last dedicated CPU core."]
    pub fn spdk_env_get_last_core() -> u32;
}
extern "C" {
    #[doc = " Get the index of the next dedicated CPU core for this application."]
    #[doc = ""]
    #[doc = " If there is no next core, return UINT32_MAX."]
    #[doc = ""]
    #[doc = " \\param prev_core Index of previous core."]
    #[doc = ""]
    #[doc = " \\return the index of the next dedicated CPU core."]
    pub fn spdk_env_get_next_core(prev_core: u32) -> u32;
}
extern "C" {
    #[doc = " Get the socket ID for the given core."]
    #[doc = ""]
    #[doc = " \\param core CPU core to query."]
    #[doc = ""]
    #[doc = " \\return the socket ID for the given core."]
    pub fn spdk_env_get_socket_id(core: u32) -> u32;
}
pub type thread_start_fn = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Launch a thread pinned to the given core. Only a single pinned thread may be"]
    #[doc = " launched per core. Subsequent attempts to launch pinned threads on that core"]
    #[doc = " will fail."]
    #[doc = ""]
    #[doc = " \\param core The core to pin the thread to."]
    #[doc = " \\param fn Entry point on the new thread."]
    #[doc = " \\param arg Argument apssed to thread_start_fn"]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_env_thread_launch_pinned(
        core: u32,
        fn_: thread_start_fn,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wait for all threads to exit before returning."]
    pub fn spdk_env_thread_wait_all();
}
extern "C" {
    #[doc = " Check whether the calling process is primary process."]
    #[doc = ""]
    #[doc = " \\return true if the calling process is primary process, or false otherwise."]
    pub fn spdk_process_is_primary() -> bool;
}
extern "C" {
    #[doc = " Get a monotonic timestamp counter."]
    #[doc = ""]
    #[doc = " \\return the monotonic timestamp counter."]
    pub fn spdk_get_ticks() -> u64;
}
extern "C" {
    #[doc = " Get the tick rate of spdk_get_ticks() per second."]
    #[doc = ""]
    #[doc = " \\return the tick rate of spdk_get_ticks() per second."]
    pub fn spdk_get_ticks_hz() -> u64;
}
extern "C" {
    #[doc = " Delay the given number of microseconds."]
    #[doc = ""]
    #[doc = " \\param us Number of microseconds."]
    pub fn spdk_delay_us(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Pause CPU execution for a short while"]
    pub fn spdk_pause();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_ring {
    _unused: [u8; 0],
}
pub const spdk_ring_type_SPDK_RING_TYPE_SP_SC: spdk_ring_type = 0;
pub const spdk_ring_type_SPDK_RING_TYPE_MP_SC: spdk_ring_type = 1;
pub const spdk_ring_type_SPDK_RING_TYPE_MP_MC: spdk_ring_type = 2;
pub type spdk_ring_type = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a ring."]
    #[doc = ""]
    #[doc = " \\param type Type for the ring. (SPDK_RING_TYPE_SP_SC or SPDK_RING_TYPE_MP_SC)."]
    #[doc = " \\param count Size of the ring in elements."]
    #[doc = " \\param socket_id Socket ID to allocate memory on, or SPDK_ENV_SOCKET_ID_ANY"]
    #[doc = " for any socket."]
    #[doc = ""]
    #[doc = " \\return a pointer to the created ring."]
    pub fn spdk_ring_create(
        type_: spdk_ring_type,
        count: size_t,
        socket_id: ::std::os::raw::c_int,
    ) -> *mut spdk_ring;
}
extern "C" {
    #[doc = " Free the ring."]
    #[doc = ""]
    #[doc = " \\param ring Ring to free."]
    pub fn spdk_ring_free(ring: *mut spdk_ring);
}
extern "C" {
    #[doc = " Get the number of objects in the ring."]
    #[doc = ""]
    #[doc = " \\param ring the ring."]
    #[doc = ""]
    #[doc = " \\return the number of objects in the ring."]
    pub fn spdk_ring_count(ring: *mut spdk_ring) -> size_t;
}
extern "C" {
    #[doc = " Queue the array of objects (with length count) on the ring."]
    #[doc = ""]
    #[doc = " \\param ring A pointer to the ring."]
    #[doc = " \\param objs A pointer to the array to be queued."]
    #[doc = " \\param count Length count of the array of objects."]
    #[doc = " \\param free_space If non-NULL, amount of free space after the enqueue has finished."]
    #[doc = ""]
    #[doc = " \\return the number of objects enqueued."]
    pub fn spdk_ring_enqueue(
        ring: *mut spdk_ring,
        objs: *mut *mut ::std::os::raw::c_void,
        count: size_t,
        free_space: *mut size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Dequeue count objects from the ring into the array objs."]
    #[doc = ""]
    #[doc = " \\param ring A pointer to the ring."]
    #[doc = " \\param objs A pointer to the array to be dequeued."]
    #[doc = " \\param count Maximum number of elements to be dequeued."]
    #[doc = ""]
    #[doc = " \\return the number of objects dequeued which is less than 'count'."]
    pub fn spdk_ring_dequeue(
        ring: *mut spdk_ring,
        objs: *mut *mut ::std::os::raw::c_void,
        count: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Reports whether the SPDK application is using the IOMMU for DMA"]
    #[doc = ""]
    #[doc = " \\return True if we are using the IOMMU, false otherwise."]
    pub fn spdk_iommu_is_enabled() -> bool;
}
extern "C" {
    #[doc = " Get the physical address of a buffer."]
    #[doc = ""]
    #[doc = " \\param buf A pointer to a buffer."]
    #[doc = " \\param size Contains the size of the memory region pointed to by vaddr."]
    #[doc = " If vaddr is successfully translated, then this is updated with the size of"]
    #[doc = " the memory region for which the translation is valid."]
    #[doc = ""]
    #[doc = " \\return the physical address of this buffer on success, or SPDK_VTOPHYS_ERROR"]
    #[doc = " on failure."]
    pub fn spdk_vtophys(buf: *const ::std::os::raw::c_void, size: *mut u64) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_addr {
    pub domain: u32,
    pub bus: u8,
    pub dev: u8,
    pub func: u8,
}
#[test]
fn bindgen_test_layout_spdk_pci_addr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_addr>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_pci_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_pci_addr))
    );
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_addr),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
    fn test_field_bus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bus) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_addr),
                "::",
                stringify!(bus)
            )
        );
    }
    test_field_bus();
    fn test_field_dev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_addr),
                "::",
                stringify!(dev)
            )
        );
    }
    test_field_dev();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_addr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_addr),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_id {
    #[doc = "< Class ID or SPDK_PCI_CLASS_ANY_ID."]
    pub class_id: u32,
    #[doc = "< Vendor ID or SPDK_PCI_ANY_ID."]
    pub vendor_id: u16,
    #[doc = "< Device ID or SPDK_PCI_ANY_ID."]
    pub device_id: u16,
    #[doc = "< Subsystem vendor ID or SPDK_PCI_ANY_ID."]
    pub subvendor_id: u16,
    #[doc = "< Subsystem device ID or SPDK_PCI_ANY_ID."]
    pub subdevice_id: u16,
}
#[test]
fn bindgen_test_layout_spdk_pci_id() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_id>(),
        12usize,
        concat!("Size of: ", stringify!(spdk_pci_id))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_id>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_pci_id))
    );
    fn test_field_class_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).class_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_id),
                "::",
                stringify!(class_id)
            )
        );
    }
    test_field_class_id();
    fn test_field_vendor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_id),
                "::",
                stringify!(vendor_id)
            )
        );
    }
    test_field_vendor_id();
    fn test_field_device_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_id),
                "::",
                stringify!(device_id)
            )
        );
    }
    test_field_device_id();
    fn test_field_subvendor_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subvendor_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_id),
                "::",
                stringify!(subvendor_id)
            )
        );
    }
    test_field_subvendor_id();
    fn test_field_subdevice_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_id>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subdevice_id) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_id),
                "::",
                stringify!(subdevice_id)
            )
        );
    }
    test_field_subdevice_id();
}
extern "C" {
    pub fn spdk_pci_driver_register(
        name: *const ::std::os::raw::c_char,
        id_table: *mut spdk_pci_id,
        flags: u32,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_device {
    pub parent: *mut spdk_pci_device,
    pub dev_handle: *mut ::std::os::raw::c_void,
    pub addr: spdk_pci_addr,
    pub id: spdk_pci_id,
    pub socket_id: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub map_bar: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut spdk_pci_device,
            bar: u32,
            mapped_addr: *mut *mut ::std::os::raw::c_void,
            phys_addr: *mut u64,
            size: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub unmap_bar: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut spdk_pci_device,
            bar: u32,
            addr: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub cfg_read: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut spdk_pci_device,
            value: *mut ::std::os::raw::c_void,
            len: u32,
            offset: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub cfg_write: ::std::option::Option<
        unsafe extern "C" fn(
            dev: *mut spdk_pci_device,
            value: *mut ::std::os::raw::c_void,
            len: u32,
            offset: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub internal: spdk_pci_device__spdk_pci_device_internal,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_device__spdk_pci_device_internal {
    pub driver: *mut spdk_pci_driver,
    pub attached: bool,
    pub claim_fd: ::std::os::raw::c_int,
    pub pending_removal: bool,
    pub removed: bool,
    pub tailq: spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1 {
    pub tqe_next: *mut spdk_pci_device,
    pub tqe_prev: *mut *mut spdk_pci_device,
}
#[test]
fn bindgen_test_layout_spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1)
        )
    );
    fn test_field_tqe_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1),
                "::",
                stringify!(tqe_next)
            )
        );
    }
    test_field_tqe_next();
    fn test_field_tqe_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tqe_prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal__bindgen_ty_1),
                "::",
                stringify!(tqe_prev)
            )
        );
    }
    test_field_tqe_prev();
}
#[test]
fn bindgen_test_layout_spdk_pci_device__spdk_pci_device_internal() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_device__spdk_pci_device_internal>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(spdk_pci_device__spdk_pci_device_internal)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_device__spdk_pci_device_internal>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_pci_device__spdk_pci_device_internal)
        )
    );
    fn test_field_driver() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).driver) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(driver)
            )
        );
    }
    test_field_driver();
    fn test_field_attached() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attached) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(attached)
            )
        );
    }
    test_field_attached();
    fn test_field_claim_fd() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).claim_fd) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(claim_fd)
            )
        );
    }
    test_field_claim_fd();
    fn test_field_pending_removal() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pending_removal) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(pending_removal)
            )
        );
    }
    test_field_pending_removal();
    fn test_field_removed() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).removed) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(removed)
            )
        );
    }
    test_field_removed();
    fn test_field_tailq() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_pci_device__spdk_pci_device_internal>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tailq) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device__spdk_pci_device_internal),
                "::",
                stringify!(tailq)
            )
        );
    }
    test_field_tailq();
}
#[test]
fn bindgen_test_layout_spdk_pci_device() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_device>(),
        120usize,
        concat!("Size of: ", stringify!(spdk_pci_device))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_device>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_pci_device))
    );
    fn test_field_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(parent)
            )
        );
    }
    test_field_parent();
    fn test_field_dev_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dev_handle) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(dev_handle)
            )
        );
    }
    test_field_dev_handle();
    fn test_field_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(addr)
            )
        );
    }
    test_field_addr();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_socket_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).socket_id) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(socket_id)
            )
        );
    }
    test_field_socket_id();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_map_bar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).map_bar) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(map_bar)
            )
        );
    }
    test_field_map_bar();
    fn test_field_unmap_bar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unmap_bar) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(unmap_bar)
            )
        );
    }
    test_field_unmap_bar();
    fn test_field_cfg_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cfg_read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(cfg_read)
            )
        );
    }
    test_field_cfg_read();
    fn test_field_cfg_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cfg_write) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(cfg_write)
            )
        );
    }
    test_field_cfg_write();
    fn test_field_internal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_device>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_device),
                "::",
                stringify!(internal)
            )
        );
    }
    test_field_internal();
}
#[doc = " Callback for device attach handling."]
#[doc = ""]
#[doc = " \\param enum_ctx Opaque value."]
#[doc = " \\param dev PCI device."]
#[doc = ""]
#[doc = " \\return -1 if an error occurred,"]
#[doc = "          0 if device attached successfully,"]
#[doc = "          1 if device not attached."]
pub type spdk_pci_enum_cb = ::std::option::Option<
    unsafe extern "C" fn(
        enum_ctx: *mut ::std::os::raw::c_void,
        dev: *mut spdk_pci_device,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Get the VMD PCI driver object."]
    #[doc = ""]
    #[doc = " \\return PCI driver."]
    pub fn spdk_pci_vmd_get_driver() -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Get the I/OAT PCI driver object."]
    #[doc = ""]
    #[doc = " \\return PCI driver."]
    pub fn spdk_pci_ioat_get_driver() -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Get the IDXD PCI driver object."]
    #[doc = ""]
    #[doc = " \\return PCI driver."]
    pub fn spdk_pci_idxd_get_driver() -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Get the Virtio PCI driver object."]
    #[doc = ""]
    #[doc = " \\return PCI driver."]
    pub fn spdk_pci_virtio_get_driver() -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Get PCI driver by name (e.g. \"nvme\", \"vmd\", \"ioat\")."]
    pub fn spdk_pci_get_driver(name: *const ::std::os::raw::c_char) -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Get the NVMe PCI driver object."]
    #[doc = ""]
    #[doc = " \\return PCI driver."]
    pub fn spdk_pci_nvme_get_driver() -> *mut spdk_pci_driver;
}
extern "C" {
    #[doc = " Enumerate all PCI devices supported by the provided driver and try to"]
    #[doc = " attach those that weren't attached yet. The provided callback will be"]
    #[doc = " called for each such device and its return code will decide whether that"]
    #[doc = " device is attached or not. Attached devices have to be manually detached"]
    #[doc = " with spdk_pci_device_detach() to be attach-able again."]
    #[doc = ""]
    #[doc = " During enumeration all registered pci devices with exposed access to"]
    #[doc = " userspace are getting probed internally unless not explicitly specified"]
    #[doc = " on denylist. Because of that it becomes not possible to either use such"]
    #[doc = " devices with another application or unbind the driver (e.g. vfio)."]
    #[doc = ""]
    #[doc = " 2s asynchronous delay is introduced to avoid race conditions between"]
    #[doc = " user space software initialization and in-kernel device handling for"]
    #[doc = " newly inserted devices. Subsequent enumerate call after the delay"]
    #[doc = " shall allow for a successful device attachment."]
    #[doc = ""]
    #[doc = " \\param driver Driver for a specific device type."]
    #[doc = " \\param enum_cb Callback to be called for each non-attached PCI device."]
    #[doc = " \\param enum_ctx Additional context passed to the callback function."]
    #[doc = ""]
    #[doc = " \\return -1 if an internal error occurred or the provided callback returned -1,"]
    #[doc = "         0 otherwise"]
    pub fn spdk_pci_enumerate(
        driver: *mut spdk_pci_driver,
        enum_cb: spdk_pci_enum_cb,
        enum_ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Begin iterating over enumerated PCI device by calling this function to get"]
    #[doc = " the first PCI device. If there no PCI devices enumerated, return NULL"]
    #[doc = ""]
    #[doc = " \\return a pointer to a PCI device on success, NULL otherwise."]
    pub fn spdk_pci_get_first_device() -> *mut spdk_pci_device;
}
extern "C" {
    #[doc = " Continue iterating over enumerated PCI devices."]
    #[doc = " If no additional PCI devices, return NULL"]
    #[doc = ""]
    #[doc = " \\param prev Previous PCI device returned from \\ref spdk_pci_get_first_device"]
    #[doc = " or \\ref spdk_pci_get_next_device"]
    #[doc = ""]
    #[doc = " \\return a pointer to the next PCI device on success, NULL otherwise."]
    pub fn spdk_pci_get_next_device(prev: *mut spdk_pci_device) -> *mut spdk_pci_device;
}
extern "C" {
    #[doc = " Map a PCI BAR in the current process."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param bar BAR number."]
    #[doc = " \\param mapped_addr A variable to store the virtual address of the mapping."]
    #[doc = " \\param phys_addr A variable to store the physical address of the mapping."]
    #[doc = " \\param size A variable to store the size of the bar (in bytes)."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    pub fn spdk_pci_device_map_bar(
        dev: *mut spdk_pci_device,
        bar: u32,
        mapped_addr: *mut *mut ::std::os::raw::c_void,
        phys_addr: *mut u64,
        size: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unmap a PCI BAR from the current process. This happens automatically when"]
    #[doc = " the PCI device is detached."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param bar BAR number."]
    #[doc = " \\param mapped_addr Virtual address of the bar."]
    #[doc = ""]
    #[doc = " \\return 0 on success."]
    pub fn spdk_pci_device_unmap_bar(
        dev: *mut spdk_pci_device,
        bar: u32,
        mapped_addr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the domain of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI device domain."]
    pub fn spdk_pci_device_get_domain(dev: *mut spdk_pci_device) -> u32;
}
extern "C" {
    #[doc = " Get the bus number of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI bus number."]
    pub fn spdk_pci_device_get_bus(dev: *mut spdk_pci_device) -> u8;
}
extern "C" {
    #[doc = " Get the device number within the PCI bus the device is on."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI device number."]
    pub fn spdk_pci_device_get_dev(dev: *mut spdk_pci_device) -> u8;
}
extern "C" {
    #[doc = " Get the particular function number represented by struct spdk_pci_device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI function number."]
    pub fn spdk_pci_device_get_func(dev: *mut spdk_pci_device) -> u8;
}
extern "C" {
    #[doc = " Get the full DomainBDF address of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI address."]
    pub fn spdk_pci_device_get_addr(dev: *mut spdk_pci_device) -> spdk_pci_addr;
}
extern "C" {
    #[doc = " Get the vendor ID of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return vendor ID."]
    pub fn spdk_pci_device_get_vendor_id(dev: *mut spdk_pci_device) -> u16;
}
extern "C" {
    #[doc = " Get the device ID of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return device ID."]
    pub fn spdk_pci_device_get_device_id(dev: *mut spdk_pci_device) -> u16;
}
extern "C" {
    #[doc = " Get the subvendor ID of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return subvendor ID."]
    pub fn spdk_pci_device_get_subvendor_id(dev: *mut spdk_pci_device) -> u16;
}
extern "C" {
    #[doc = " Get the subdevice ID of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return subdevice ID."]
    pub fn spdk_pci_device_get_subdevice_id(dev: *mut spdk_pci_device) -> u16;
}
extern "C" {
    #[doc = " Get the PCI ID of a PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return PCI ID."]
    pub fn spdk_pci_device_get_id(dev: *mut spdk_pci_device) -> spdk_pci_id;
}
extern "C" {
    #[doc = " Get the NUMA node the PCI device is on."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return NUMA node index (>= 0)."]
    pub fn spdk_pci_device_get_socket_id(dev: *mut spdk_pci_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Serialize the PCIe Device Serial Number into the provided buffer."]
    #[doc = " The buffer will contain a 16-character-long serial number followed by"]
    #[doc = " a NULL terminator."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param sn Buffer to store the serial number in."]
    #[doc = " \\param len Length of buffer. Must be at least 17."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_get_serial_number(
        dev: *mut spdk_pci_device,
        sn: *mut ::std::os::raw::c_char,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Claim a PCI device for exclusive SPDK userspace access."]
    #[doc = ""]
    #[doc = " Uses F_SETLK on a shared memory file with the PCI address embedded in its name."]
    #[doc = " As long as this file remains open with the lock acquired, other processes will"]
    #[doc = " not be able to successfully call this function on the same PCI device."]
    #[doc = ""]
    #[doc = " The device can be un-claimed by the owning process with spdk_pci_device_unclaim()."]
    #[doc = " It will be also unclaimed automatically when detached."]
    #[doc = ""]
    #[doc = " \\param dev PCI device to claim."]
    #[doc = ""]
    #[doc = " \\return -EACCES if the device has already been claimed,"]
    #[doc = "\t   negative errno on unexpected errors,"]
    #[doc = "\t   0 on success."]
    pub fn spdk_pci_device_claim(dev: *mut spdk_pci_device) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Undo spdk_pci_device_claim()."]
    #[doc = ""]
    #[doc = " \\param dev PCI device to unclaim."]
    pub fn spdk_pci_device_unclaim(dev: *mut spdk_pci_device);
}
extern "C" {
    #[doc = " Release all resources associated with the given device and detach it. As long"]
    #[doc = " as the PCI device is physically available, it will attachable again."]
    #[doc = ""]
    #[doc = " \\param device PCI device."]
    pub fn spdk_pci_device_detach(device: *mut spdk_pci_device);
}
extern "C" {
    #[doc = " Attach a PCI device. This will bypass all blocked list rules and explicitly"]
    #[doc = " attach a device at the provided address. The return code of the provided"]
    #[doc = " callback will decide whether that device is attached or not. Attached"]
    #[doc = " devices have to be manually detached with spdk_pci_device_detach() to be"]
    #[doc = " attach-able again."]
    #[doc = ""]
    #[doc = " \\param driver Driver for a specific device type. The device will only be"]
    #[doc = " attached if it's supported by this driver."]
    #[doc = " \\param enum_cb Callback to be called for the PCI device once it's found."]
    #[doc = " \\param enum_ctx Additional context passed to the callback function."]
    #[doc = " \\param pci_address Address of the device to attach."]
    #[doc = ""]
    #[doc = " \\return -1 if a device at the provided PCI address couldn't be found,"]
    #[doc = "         -1 if an internal error happened or the provided callback returned non-zero,"]
    #[doc = "         0 otherwise"]
    pub fn spdk_pci_device_attach(
        driver: *mut spdk_pci_driver,
        enum_cb: spdk_pci_enum_cb,
        enum_ctx: *mut ::std::os::raw::c_void,
        pci_address: *mut spdk_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allow the specified PCI device to be probed by the calling process."]
    #[doc = ""]
    #[doc = " When using spdk_pci_enumerate(), only devices with allowed PCI addresses will"]
    #[doc = " be probed.  By default, this is all PCI addresses, but the pci_allowed"]
    #[doc = " and pci_blocked environment options can override this behavior."]
    #[doc = " This API enables the caller to allow a new PCI address that may have previously"]
    #[doc = " been blocked."]
    #[doc = ""]
    #[doc = " \\param pci_addr PCI address to allow"]
    #[doc = " \\return 0 if successful"]
    #[doc = " \\return -ENOMEM if environment-specific data structures cannot be allocated"]
    #[doc = " \\return -EINVAL if specified PCI address is not valid"]
    pub fn spdk_pci_device_allow(pci_addr: *mut spdk_pci_addr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read \\c len bytes from the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param buf A buffer to copy the data into."]
    #[doc = " \\param len Number of bytes to read."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start reading from."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_read(
        dev: *mut spdk_pci_device,
        buf: *mut ::std::os::raw::c_void,
        len: u32,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write \\c len bytes into the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param buf A buffer to copy the data from."]
    #[doc = " \\param len Number of bytes to write."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start writing to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_write(
        dev: *mut spdk_pci_device,
        buf: *mut ::std::os::raw::c_void,
        len: u32,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read 1 byte from the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A buffer to copy the data into."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start reading from."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_read8(
        dev: *mut spdk_pci_device,
        value: *mut u8,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write 1 byte into the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A value to write."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start writing to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_write8(
        dev: *mut spdk_pci_device,
        value: u8,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read 2 bytes from the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A buffer to copy the data into."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start reading from."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_read16(
        dev: *mut spdk_pci_device,
        value: *mut u16,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write 2 bytes into the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A value to write."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start writing to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_write16(
        dev: *mut spdk_pci_device,
        value: u16,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read 4 bytes from the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A buffer to copy the data into."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start reading from."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_read32(
        dev: *mut spdk_pci_device,
        value: *mut u32,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write 4 bytes into the PCI configuration space."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = " \\param value A value to write."]
    #[doc = " \\param offset Offset (in bytes) in the PCI config space to start writing to."]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on failure."]
    pub fn spdk_pci_device_cfg_write32(
        dev: *mut spdk_pci_device,
        value: u32,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if device was requested to be removed from the process. This can be"]
    #[doc = " caused either by physical device hotremoval or OS-triggered removal. In the"]
    #[doc = " latter case, the device may continue to function properly even if this"]
    #[doc = " function returns \\c true . The upper-layer driver may check this function"]
    #[doc = " periodically and eventually detach the device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device."]
    #[doc = ""]
    #[doc = " \\return if device was requested to be removed"]
    pub fn spdk_pci_device_is_removed(dev: *mut spdk_pci_device) -> bool;
}
extern "C" {
    #[doc = " Compare two PCI addresses."]
    #[doc = ""]
    #[doc = " \\param a1 PCI address 1."]
    #[doc = " \\param a2 PCI address 2."]
    #[doc = ""]
    #[doc = " \\return 0 if a1 == a2, less than 0 if a1 < a2, greater than 0 if a1 > a2"]
    pub fn spdk_pci_addr_compare(
        a1: *const spdk_pci_addr,
        a2: *const spdk_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a string representation of a PCI address into a struct spdk_pci_addr."]
    #[doc = ""]
    #[doc = " \\param addr PCI adddress output on success."]
    #[doc = " \\param bdf PCI address in domain:bus:device.function format or"]
    #[doc = "\tdomain.bus.device.function format."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_pci_addr_parse(
        addr: *mut spdk_pci_addr,
        bdf: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a struct spdk_pci_addr to a string."]
    #[doc = ""]
    #[doc = " \\param bdf String into which a string will be output in the format"]
    #[doc = "  domain:bus:device.function. The string must be at least 14 characters in size."]
    #[doc = " \\param sz Size of bdf in bytes. Must be at least 14."]
    #[doc = " \\param addr PCI address."]
    #[doc = ""]
    #[doc = " \\return 0 on success, or a negated errno on failure."]
    pub fn spdk_pci_addr_fmt(
        bdf: *mut ::std::os::raw::c_char,
        sz: size_t,
        addr: *const spdk_pci_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hook a custom PCI device into the PCI layer. The device will be attachable,"]
    #[doc = " enumerable, and will call provided callbacks on each PCI resource access"]
    #[doc = " request."]
    #[doc = ""]
    #[doc = " \\param drv driver that will be able to attach the device"]
    #[doc = " \\param dev fully initialized PCI device struct"]
    pub fn spdk_pci_hook_device(drv: *mut spdk_pci_driver, dev: *mut spdk_pci_device);
}
extern "C" {
    #[doc = " Un-hook a custom PCI device from the PCI layer. The device must not be attached."]
    #[doc = ""]
    #[doc = " \\param dev fully initialized PCI device struct"]
    pub fn spdk_pci_unhook_device(dev: *mut spdk_pci_device);
}
extern "C" {
    #[doc = " Return the type of the PCI device."]
    #[doc = ""]
    #[doc = " \\param dev PCI device"]
    #[doc = ""]
    #[doc = " \\return string representing the type of the device"]
    pub fn spdk_pci_device_get_type(dev: *const spdk_pci_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Remove any CPU affinity from the current thread."]
    pub fn spdk_unaffinitize_thread();
}
extern "C" {
    #[doc = " Call a function with CPU affinity unset."]
    #[doc = ""]
    #[doc = " This can be used to run a function that creates other threads without inheriting the calling"]
    #[doc = " thread's CPU affinity."]
    #[doc = ""]
    #[doc = " \\param cb Function to call"]
    #[doc = " \\param arg Parameter to the function cb()."]
    #[doc = ""]
    #[doc = " \\return the return value of cb()."]
    pub fn spdk_call_unaffinitized(
        cb: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " Page-granularity memory address translation table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mem_map {
    _unused: [u8; 0],
}
pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_REGISTER: spdk_mem_map_notify_action = 0;
pub const spdk_mem_map_notify_action_SPDK_MEM_MAP_NOTIFY_UNREGISTER: spdk_mem_map_notify_action = 1;
pub type spdk_mem_map_notify_action = ::std::os::raw::c_uint;
pub type spdk_mem_map_notify_cb = ::std::option::Option<
    unsafe extern "C" fn(
        cb_ctx: *mut ::std::os::raw::c_void,
        map: *mut spdk_mem_map,
        action: spdk_mem_map_notify_action,
        vaddr: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> ::std::os::raw::c_int,
>;
pub type spdk_mem_map_contiguous_translations =
    ::std::option::Option<unsafe extern "C" fn(addr_1: u64, addr_2: u64) -> ::std::os::raw::c_int>;
#[doc = " A function table to be implemented by each memory map."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_mem_map_ops {
    pub notify_cb: spdk_mem_map_notify_cb,
    pub are_contiguous: spdk_mem_map_contiguous_translations,
}
#[test]
fn bindgen_test_layout_spdk_mem_map_ops() {
    assert_eq!(
        ::std::mem::size_of::<spdk_mem_map_ops>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_mem_map_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_mem_map_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_mem_map_ops))
    );
    fn test_field_notify_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_mem_map_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_cb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_mem_map_ops),
                "::",
                stringify!(notify_cb)
            )
        );
    }
    test_field_notify_cb();
    fn test_field_are_contiguous() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_mem_map_ops>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).are_contiguous) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_mem_map_ops),
                "::",
                stringify!(are_contiguous)
            )
        );
    }
    test_field_are_contiguous();
}
extern "C" {
    #[doc = " Allocate a virtual memory address translation map."]
    #[doc = ""]
    #[doc = " \\param default_translation Default translation for the map."]
    #[doc = " \\param ops Table of callback functions for map operations."]
    #[doc = " \\param cb_ctx Argument passed to the callback function."]
    #[doc = ""]
    #[doc = " \\return a pointer to the allocated virtual memory address translation map."]
    pub fn spdk_mem_map_alloc(
        default_translation: u64,
        ops: *const spdk_mem_map_ops,
        cb_ctx: *mut ::std::os::raw::c_void,
    ) -> *mut spdk_mem_map;
}
extern "C" {
    #[doc = " Free a memory map previously allocated by spdk_mem_map_alloc()."]
    #[doc = ""]
    #[doc = " \\param pmap Memory map to free."]
    pub fn spdk_mem_map_free(pmap: *mut *mut spdk_mem_map);
}
extern "C" {
    #[doc = " Register an address translation for a range of virtual memory."]
    #[doc = ""]
    #[doc = " \\param map Memory map."]
    #[doc = " \\param vaddr Virtual address of the region to register - must be 2 MB aligned."]
    #[doc = " \\param size Size of the region in bytes - must be multiple of 2 MB in the"]
    #[doc = "  current implementation."]
    #[doc = " \\param translation Translation to store in the map for this address range."]
    #[doc = ""]
    #[doc = " \\sa spdk_mem_map_clear_translation()."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_mem_map_set_translation(
        map: *mut spdk_mem_map,
        vaddr: u64,
        size: u64,
        translation: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister an address translation."]
    #[doc = ""]
    #[doc = " \\param map Memory map."]
    #[doc = " \\param vaddr Virtual address of the region to unregister - must be 2 MB aligned."]
    #[doc = " \\param size Size of the region in bytes - must be multiple of 2 MB in the"]
    #[doc = "  current implementation."]
    #[doc = ""]
    #[doc = " \\sa spdk_mem_map_set_translation()."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_mem_map_clear_translation(
        map: *mut spdk_mem_map,
        vaddr: u64,
        size: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Look up the translation of a virtual address in a memory map."]
    #[doc = ""]
    #[doc = " \\param map Memory map."]
    #[doc = " \\param vaddr Virtual address."]
    #[doc = " \\param size Contains the size of the memory region pointed to by vaddr."]
    #[doc = " If vaddr is successfully translated, then this is updated with the size of"]
    #[doc = " the memory region for which the translation is valid."]
    #[doc = ""]
    #[doc = " \\return the translation of vaddr stored in the map, or default_translation"]
    #[doc = " as specified in spdk_mem_map_alloc() if vaddr is not present in the map."]
    pub fn spdk_mem_map_translate(map: *const spdk_mem_map, vaddr: u64, size: *mut u64) -> u64;
}
extern "C" {
    #[doc = " Register the specified memory region for address translation."]
    #[doc = ""]
    #[doc = " The memory region must map to pinned huge pages (2MB or greater)."]
    #[doc = ""]
    #[doc = " \\param vaddr Virtual address to register."]
    #[doc = " \\param len Length in bytes of the vaddr."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_mem_register(
        vaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Unregister the specified memory region from vtophys address translation."]
    #[doc = ""]
    #[doc = " The caller must ensure all in-flight DMA operations to this memory region"]
    #[doc = " are completed or cancelled before calling this function."]
    #[doc = ""]
    #[doc = " \\param vaddr Virtual address to unregister."]
    #[doc = " \\param len Length in bytes of the vaddr."]
    #[doc = ""]
    #[doc = " \\return 0 on success, negative errno on failure."]
    pub fn spdk_mem_unregister(
        vaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reserve the address space specified in all memory maps."]
    #[doc = ""]
    #[doc = " This pre-allocates the necessary space in the memory maps such that"]
    #[doc = " future calls to spdk_mem_register() on that region require no"]
    #[doc = " internal memory allocations."]
    #[doc = ""]
    #[doc = " \\param vaddr Virtual address to reserve"]
    #[doc = " \\param len Length in bytes of vaddr"]
    #[doc = ""]
    #[doc = " \\return 0 on success, negated errno on failure."]
    pub fn spdk_mem_reserve(
        vaddr: *mut ::std::os::raw::c_void,
        len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the address's file descriptor and offset, it works with spdk memory allocation APIs"]
    #[doc = ""]
    #[doc = " \\param vaddr Virtual address to get"]
    #[doc = " \\param offset Virtual address's map offset to the file descriptor"]
    #[doc = ""]
    #[doc = " \\return negative errno on failure, otherwise return the file descriptor"]
    pub fn spdk_mem_get_fd_and_offset(
        vaddr: *mut ::std::os::raw::c_void,
        offset: *mut u64,
    ) -> ::std::os::raw::c_int;
}
pub const spdk_pci_event_type_SPDK_UEVENT_ADD: spdk_pci_event_type = 0;
pub const spdk_pci_event_type_SPDK_UEVENT_REMOVE: spdk_pci_event_type = 1;
pub type spdk_pci_event_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_event {
    pub action: spdk_pci_event_type,
    pub traddr: spdk_pci_addr,
}
#[test]
fn bindgen_test_layout_spdk_pci_event() {
    assert_eq!(
        ::std::mem::size_of::<spdk_pci_event>(),
        12usize,
        concat!("Size of: ", stringify!(spdk_pci_event))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_pci_event>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_pci_event))
    );
    fn test_field_action() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_event>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).action) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_event),
                "::",
                stringify!(action)
            )
        );
    }
    test_field_action();
    fn test_field_traddr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_pci_event>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).traddr) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_pci_event),
                "::",
                stringify!(traddr)
            )
        );
    }
    test_field_traddr();
}
pub type spdk_pci_error_handler = ::std::option::Option<
    unsafe extern "C" fn(info: *mut siginfo_t, ctx: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Begin listening for PCI bus events. This is used to detect hot-insert and"]
    #[doc = " hot-remove events. Once the system is listening, events may be retrieved"]
    #[doc = " by calling spdk_pci_get_event() periodically."]
    #[doc = ""]
    #[doc = " \\return negative errno on failure, otherwise,  return a file descriptor"]
    #[doc = " that may be later passed to spdk_pci_get_event()."]
    pub fn spdk_pci_event_listen() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the next PCI bus event."]
    #[doc = ""]
    #[doc = " \\param fd A file descriptor returned by spdk_pci_event_listen()"]
    #[doc = " \\param event An event on the PCI bus"]
    #[doc = ""]
    #[doc = " \\return Negative errno on failure. 0 for no event. A positive number"]
    #[doc = " when an event has been returned"]
    pub fn spdk_pci_get_event(
        fd: ::std::os::raw::c_int,
        event: *mut spdk_pci_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a signal handler to handle bus errors on the PCI bus"]
    #[doc = ""]
    #[doc = " \\param sighandler Signal bus handler of the PCI bus"]
    #[doc = " \\param ctx The arg pass to the registered signal bus handler."]
    #[doc = ""]
    #[doc = " \\return negative errno on failure, otherwise it means successful"]
    pub fn spdk_pci_register_error_handler(
        sighandler: spdk_pci_error_handler,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Register a signal handler to handle bus errors on the PCI bus"]
    #[doc = ""]
    #[doc = " \\param sighandler Signal bus handler of the PCI bus"]
    pub fn spdk_pci_unregister_error_handler(sighandler: spdk_pci_error_handler);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cap_register {
    pub raw: u64,
    pub bits: spdk_nvme_cap_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cap_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cap_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cap_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cap_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cap_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cap_register__bindgen_ty_1 {
    #[inline]
    pub fn mqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_mqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn to(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_to(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dstrd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_dstrd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn nssrs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nssrs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn css(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn bps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn mpsmin(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mpsmin(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn mpsmax(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mpsmax(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pmrs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(57usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(57usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mqes: u32,
        cqr: u32,
        ams: u32,
        reserved1: u32,
        to: u32,
        dstrd: u32,
        nssrs: u32,
        css: u32,
        bps: u32,
        reserved2: u32,
        mpsmin: u32,
        mpsmax: u32,
        pmrs: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let mqes: u32 = unsafe { ::std::mem::transmute(mqes) };
            mqes as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cqr: u32 = unsafe { ::std::mem::transmute(cqr) };
            cqr as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let ams: u32 = unsafe { ::std::mem::transmute(ams) };
            ams as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let to: u32 = unsafe { ::std::mem::transmute(to) };
            to as u64
        });
        __bindgen_bitfield_unit.set(32usize, 4u8, {
            let dstrd: u32 = unsafe { ::std::mem::transmute(dstrd) };
            dstrd as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let nssrs: u32 = unsafe { ::std::mem::transmute(nssrs) };
            nssrs as u64
        });
        __bindgen_bitfield_unit.set(37usize, 8u8, {
            let css: u32 = unsafe { ::std::mem::transmute(css) };
            css as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let bps: u32 = unsafe { ::std::mem::transmute(bps) };
            bps as u64
        });
        __bindgen_bitfield_unit.set(46usize, 2u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 4u8, {
            let mpsmin: u32 = unsafe { ::std::mem::transmute(mpsmin) };
            mpsmin as u64
        });
        __bindgen_bitfield_unit.set(52usize, 4u8, {
            let mpsmax: u32 = unsafe { ::std::mem::transmute(mpsmax) };
            mpsmax as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let pmrs: u32 = unsafe { ::std::mem::transmute(pmrs) };
            pmrs as u64
        });
        __bindgen_bitfield_unit.set(57usize, 7u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cap_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cap_register>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_cap_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cap_register>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cap_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cap_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cap_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cap_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cap_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = "< NVM command set"]
pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_NVM: spdk_nvme_cc_css = 0;
#[doc = "< One or more I/O command sets"]
pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_IOCS: spdk_nvme_cc_css = 6;
#[doc = "< No I/O, only admin"]
pub const spdk_nvme_cc_css_SPDK_NVME_CC_CSS_NOIO: spdk_nvme_cc_css = 7;
#[doc = " I/O Command Set Selected"]
#[doc = ""]
#[doc = " Only a single command set is defined as of NVMe 1.3 (NVM). Later, it became"]
#[doc = " possible to disable I/O Command Sets, that is, configuring it to only use the"]
#[doc = " Admin Command Set. With 1.4c and Namespace Types, additional I/O Command Sets"]
#[doc = " are available."]
pub type spdk_nvme_cc_css = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cc_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cc_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cc_register__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cc_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cc_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cc_register__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn css(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_css(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ams(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ams(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn shn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn iosqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_iosqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn iocqes(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_iocqes(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        en: u32,
        reserved1: u32,
        css: u32,
        mps: u32,
        ams: u32,
        shn: u32,
        iosqes: u32,
        iocqes: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::std::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let css: u32 = unsafe { ::std::mem::transmute(css) };
            css as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let mps: u32 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let ams: u32 = unsafe { ::std::mem::transmute(ams) };
            ams as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let shn: u32 = unsafe { ::std::mem::transmute(shn) };
            shn as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let iosqes: u32 = unsafe { ::std::mem::transmute(iosqes) };
            iosqes as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let iocqes: u32 = unsafe { ::std::mem::transmute(iocqes) };
            iocqes as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cc_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cc_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cc_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cc_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cc_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cc_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cc_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
pub const spdk_nvme_shn_value_SPDK_NVME_SHN_NORMAL: spdk_nvme_shn_value = 1;
pub const spdk_nvme_shn_value_SPDK_NVME_SHN_ABRUPT: spdk_nvme_shn_value = 2;
pub type spdk_nvme_shn_value = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_csts_register {
    pub raw: u32,
    pub bits: spdk_nvme_csts_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_csts_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_csts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_csts_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_csts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_csts_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_csts_register__bindgen_ty_1 {
    #[inline]
    pub fn rdy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cfs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cfs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_shst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nssro(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nssro(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rdy: u32,
        cfs: u32,
        shst: u32,
        nssro: u32,
        pp: u32,
        reserved1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rdy: u32 = unsafe { ::std::mem::transmute(rdy) };
            rdy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cfs: u32 = unsafe { ::std::mem::transmute(cfs) };
            cfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let shst: u32 = unsafe { ::std::mem::transmute(shst) };
            shst as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nssro: u32 = unsafe { ::std::mem::transmute(nssro) };
            nssro as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pp: u32 = unsafe { ::std::mem::transmute(pp) };
            pp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_csts_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_csts_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_csts_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_csts_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_csts_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_csts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_csts_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_csts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_csts_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_NORMAL: spdk_nvme_shst_value = 0;
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_OCCURRING: spdk_nvme_shst_value = 1;
pub const spdk_nvme_shst_value_SPDK_NVME_SHST_COMPLETE: spdk_nvme_shst_value = 2;
pub type spdk_nvme_shst_value = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_aqa_register {
    pub raw: u32,
    pub bits: spdk_nvme_aqa_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_aqa_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_aqa_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_aqa_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_aqa_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_aqa_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_aqa_register__bindgen_ty_1 {
    #[inline]
    pub fn asqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_asqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn acqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_acqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        asqs: u32,
        reserved1: u32,
        acqs: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let asqs: u32 = unsafe { ::std::mem::transmute(asqs) };
            asqs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 12u8, {
            let acqs: u32 = unsafe { ::std::mem::transmute(acqs) };
            acqs as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_aqa_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_aqa_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_aqa_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_aqa_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_aqa_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_aqa_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_aqa_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_aqa_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_aqa_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_vs_register {
    pub raw: u32,
    pub bits: spdk_nvme_vs_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_vs_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_vs_register__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_vs_register__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_vs_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_vs_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_vs_register__bindgen_ty_1 {
    #[inline]
    pub fn ter(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ter(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mnr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mnr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mjr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_mjr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ter: u32, mnr: u32, mjr: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ter: u32 = unsafe { ::std::mem::transmute(ter) };
            ter as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let mnr: u32 = unsafe { ::std::mem::transmute(mnr) };
            mnr as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let mjr: u32 = unsafe { ::std::mem::transmute(mjr) };
            mjr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_vs_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_vs_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_vs_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_vs_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_vs_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_vs_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_vs_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_vs_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_vs_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbloc_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbloc_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmbloc_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbloc_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbloc_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbloc_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbloc_register__bindgen_ty_1 {
    #[inline]
    pub fn bir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn ofst(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ofst(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bir: u32,
        reserved1: u32,
        ofst: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let bir: u32 = unsafe { ::std::mem::transmute(bir) };
            bir as u64
        });
        __bindgen_bitfield_unit.set(3usize, 9u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ofst: u32 = unsafe { ::std::mem::transmute(ofst) };
            ofst as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbloc_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbloc_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbloc_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbloc_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbloc_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbloc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbloc_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbloc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbloc_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbsz_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbsz_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmbsz_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbsz_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsz_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbsz_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbsz_register__bindgen_ty_1 {
    #[inline]
    pub fn sqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cqs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cqs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lists(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_lists(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn szu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_szu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_sz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sqs: u32,
        cqs: u32,
        lists: u32,
        rds: u32,
        wds: u32,
        reserved1: u32,
        szu: u32,
        sz: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sqs: u32 = unsafe { ::std::mem::transmute(sqs) };
            sqs as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cqs: u32 = unsafe { ::std::mem::transmute(cqs) };
            cqs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let lists: u32 = unsafe { ::std::mem::transmute(lists) };
            lists as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rds: u32 = unsafe { ::std::mem::transmute(rds) };
            rds as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wds: u32 = unsafe { ::std::mem::transmute(wds) };
            wds as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let szu: u32 = unsafe { ::std::mem::transmute(szu) };
            szu as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let sz: u32 = unsafe { ::std::mem::transmute(sz) };
            sz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsz_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsz_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbsz_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsz_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbsz_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbsz_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbsz_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbsz_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbsz_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbmsc_register {
    pub raw: u64,
    pub bits: spdk_nvme_cmbmsc_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmbmsc_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbmsc_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbmsc_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbmsc_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbmsc_register__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbmsc_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbmsc_register__bindgen_ty_1 {
    #[inline]
    pub fn cre(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cre(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmse(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_cmse(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u64) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn cba(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_cba(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cre: u64,
        cmse: u64,
        reserved: u64,
        cba: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cre: u64 = unsafe { ::std::mem::transmute(cre) };
            cre as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cmse: u64 = unsafe { ::std::mem::transmute(cmse) };
            cmse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let reserved: u64 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let cba: u64 = unsafe { ::std::mem::transmute(cba) };
            cba as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbmsc_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbmsc_register>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbmsc_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbmsc_register>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbmsc_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbmsc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbmsc_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbmsc_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbmsc_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmbsts_register {
    pub raw: u32,
    pub bits: spdk_nvme_cmbsts_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmbsts_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsts_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmbsts_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmbsts_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmbsts_register__bindgen_ty_1 {
    #[inline]
    pub fn cbai(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbai(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cbai: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cbai: u32 = unsafe { ::std::mem::transmute(cbai) };
            cbai as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmbsts_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmbsts_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmbsts_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmbsts_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmbsts_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbsts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbsts_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmbsts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmbsts_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrcap_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrcap_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrcap_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrcap_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrcap_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrcap_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrcap_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrcap_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrcap_register__bindgen_ty_1 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bir(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_bir(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrtu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_pmrtu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrwbm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_pmrwbm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrto(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pmrto(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cmss(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmss(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        rds: u32,
        wds: u32,
        bir: u32,
        pmrtu: u32,
        pmrwbm: u32,
        reserved2: u32,
        pmrto: u32,
        cmss: u32,
        reserved3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rds: u32 = unsafe { ::std::mem::transmute(rds) };
            rds as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wds: u32 = unsafe { ::std::mem::transmute(wds) };
            wds as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let bir: u32 = unsafe { ::std::mem::transmute(bir) };
            bir as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let pmrtu: u32 = unsafe { ::std::mem::transmute(pmrtu) };
            pmrtu as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let pmrwbm: u32 = unsafe { ::std::mem::transmute(pmrwbm) };
            pmrwbm as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let pmrto: u32 = unsafe { ::std::mem::transmute(pmrto) };
            pmrto as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let cmss: u32 = unsafe { ::std::mem::transmute(cmss) };
            cmss as u64
        });
        __bindgen_bitfield_unit.set(25usize, 7u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrcap_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrcap_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrcap_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrcap_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrcap_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrcap_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrcap_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrcap_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrcap_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrctl_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrctl_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrctl_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrctl_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrctl_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrctl_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrctl_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrctl_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrctl_register__bindgen_ty_1 {
    #[inline]
    pub fn en(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_en(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(en: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let en: u32 = unsafe { ::std::mem::transmute(en) };
            en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrctl_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrctl_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrctl_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrctl_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrctl_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrctl_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrctl_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrctl_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrctl_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrsts_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrsts_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrsts_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrsts_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrsts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrsts_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrsts_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrsts_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrsts_register__bindgen_ty_1 {
    #[inline]
    pub fn err(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_err(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn nrdy(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nrdy(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hsts(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_hsts(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn cbai(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbai(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        err: u32,
        nrdy: u32,
        hsts: u32,
        cbai: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let err: u32 = unsafe { ::std::mem::transmute(err) };
            err as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let nrdy: u32 = unsafe { ::std::mem::transmute(nrdy) };
            nrdy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let hsts: u32 = unsafe { ::std::mem::transmute(hsts) };
            hsts as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let cbai: u32 = unsafe { ::std::mem::transmute(cbai) };
            cbai as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrsts_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrsts_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrsts_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrsts_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrsts_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrsts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrsts_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrsts_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrsts_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrebs_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrebs_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrebs_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrebs_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrebs_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrebs_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrebs_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrebs_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrebs_register__bindgen_ty_1 {
    #[inline]
    pub fn pmrszu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_pmrszu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rbb(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rbb(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrwbz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pmrwbz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pmrszu: u32,
        rbb: u32,
        reserved: u32,
        pmrwbz: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let pmrszu: u32 = unsafe { ::std::mem::transmute(pmrszu) };
            pmrszu as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rbb: u32 = unsafe { ::std::mem::transmute(rbb) };
            rbb as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let pmrwbz: u32 = unsafe { ::std::mem::transmute(pmrwbz) };
            pmrwbz as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrebs_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrebs_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrebs_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrebs_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrebs_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrebs_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrebs_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrebs_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrebs_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrswtp_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrswtp_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrswtp_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrswtp_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrswtp_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrswtp_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrswtp_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrswtp_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrswtp_register__bindgen_ty_1 {
    #[inline]
    pub fn pmrswtu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_pmrswtu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn pmrswtv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pmrswtv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pmrswtu: u32,
        reserved: u32,
        pmrswtv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let pmrswtu: u32 = unsafe { ::std::mem::transmute(pmrswtu) };
            pmrswtu as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let pmrswtv: u32 = unsafe { ::std::mem::transmute(pmrswtv) };
            pmrswtv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrswtp_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrswtp_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrswtp_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrswtp_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrswtp_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrswtp_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrswtp_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrswtp_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrswtp_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_pmrmscl_register {
    pub raw: u32,
    pub bits: spdk_nvme_pmrmscl_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_pmrmscl_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrmscl_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrmscl_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_pmrmscl_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrmscl_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_pmrmscl_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_pmrmscl_register__bindgen_ty_1 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cmse(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cmse(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn cba(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_cba(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        cmse: u32,
        reserved2: u32,
        cba: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let cmse: u32 = unsafe { ::std::mem::transmute(cmse) };
            cmse as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let cba: u32 = unsafe { ::std::mem::transmute(cba) };
            cba as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_pmrmscl_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_pmrmscl_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_pmrmscl_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_pmrmscl_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_pmrmscl_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrmscl_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrmscl_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_pmrmscl_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_pmrmscl_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Boot partition information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_bpinfo_register {
    pub raw: u32,
    pub bits: spdk_nvme_bpinfo_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_bpinfo_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_bpinfo_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bpinfo_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_bpinfo_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_bpinfo_register__bindgen_ty_1 {
    #[inline]
    pub fn bpsz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_bpsz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn brs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_brs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn abpid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_abpid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bpsz: u32,
        reserved1: u32,
        brs: u32,
        reserved2: u32,
        abpid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let bpsz: u32 = unsafe { ::std::mem::transmute(bpsz) };
            bpsz as u64
        });
        __bindgen_bitfield_unit.set(15usize, 9u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let brs: u32 = unsafe { ::std::mem::transmute(brs) };
            brs as u64
        });
        __bindgen_bitfield_unit.set(26usize, 5u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let abpid: u32 = unsafe { ::std::mem::transmute(abpid) };
            abpid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bpinfo_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bpinfo_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_bpinfo_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bpinfo_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_bpinfo_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_bpinfo_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_bpinfo_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_bpinfo_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_bpinfo_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Boot partition read select"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_bprsel_register {
    pub raw: u32,
    pub bits: spdk_nvme_bprsel_register__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_bprsel_register__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bprsel_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_bprsel_register__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bprsel_register__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_bprsel_register__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_bprsel_register__bindgen_ty_1 {
    #[inline]
    pub fn bprsz(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_bprsz(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn bprof(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_bprof(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bpid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bpid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bprsz: u32,
        bprof: u32,
        reserved: u32,
        bpid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let bprsz: u32 = unsafe { ::std::mem::transmute(bprsz) };
            bprsz as u64
        });
        __bindgen_bitfield_unit.set(10usize, 20u8, {
            let bprof: u32 = unsafe { ::std::mem::transmute(bprof) };
            bprof as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let bpid: u32 = unsafe { ::std::mem::transmute(bpid) };
            bpid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_bprsel_register() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_bprsel_register>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_bprsel_register))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_bprsel_register>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_bprsel_register))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_bprsel_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_bprsel_register),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_bprsel_register>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_bprsel_register),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_registers {
    #[doc = " controller capabilities"]
    pub cap: spdk_nvme_cap_register,
    #[doc = " version of NVMe specification"]
    pub vs: spdk_nvme_vs_register,
    pub intms: u32,
    pub intmc: u32,
    #[doc = " controller configuration"]
    pub cc: spdk_nvme_cc_register,
    pub reserved1: u32,
    pub csts: spdk_nvme_csts_register,
    pub nssr: u32,
    #[doc = " admin queue attributes"]
    pub aqa: spdk_nvme_aqa_register,
    pub asq: u64,
    pub acq: u64,
    #[doc = " controller memory buffer location"]
    pub cmbloc: spdk_nvme_cmbloc_register,
    #[doc = " controller memory buffer size"]
    pub cmbsz: spdk_nvme_cmbsz_register,
    #[doc = " boot partition information"]
    pub bpinfo: spdk_nvme_bpinfo_register,
    #[doc = " boot partition read select"]
    pub bprsel: spdk_nvme_bprsel_register,
    #[doc = " boot partition memory buffer location (must be 4KB aligned)"]
    pub bpmbl: u64,
    #[doc = " controller memory buffer memory space control"]
    pub cmbmsc: spdk_nvme_cmbmsc_register,
    #[doc = " controller memory buffer status"]
    pub cmbsts: spdk_nvme_cmbsts_register,
    pub reserved2: [u32; 873usize],
    #[doc = " persistent memory region capabilities"]
    pub pmrcap: spdk_nvme_pmrcap_register,
    #[doc = " persistent memory region control"]
    pub pmrctl: spdk_nvme_pmrctl_register,
    #[doc = " persistent memory region status"]
    pub pmrsts: spdk_nvme_pmrsts_register,
    #[doc = " persistent memory region elasticity buffer size"]
    pub pmrebs: spdk_nvme_pmrebs_register,
    #[doc = " persistent memory region sustained write throughput"]
    pub pmrswtp: spdk_nvme_pmrswtp_register,
    #[doc = " persistent memory region memory space control lower"]
    pub pmrmscl: spdk_nvme_pmrmscl_register,
    pub pmrmscu: u32,
    pub reserved3: [u32; 121usize],
    pub doorbell: [spdk_nvme_registers__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_registers__bindgen_ty_1 {
    pub sq_tdbl: u32,
    pub cq_hdbl: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registers__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_registers__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registers__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_registers__bindgen_ty_1)
        )
    );
    fn test_field_sq_tdbl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sq_tdbl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers__bindgen_ty_1),
                "::",
                stringify!(sq_tdbl)
            )
        );
    }
    test_field_sq_tdbl();
    fn test_field_cq_hdbl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cq_hdbl) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers__bindgen_ty_1),
                "::",
                stringify!(cq_hdbl)
            )
        );
    }
    test_field_cq_hdbl();
}
#[test]
fn bindgen_test_layout_spdk_nvme_registers() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registers>(),
        4104usize,
        concat!("Size of: ", stringify!(spdk_nvme_registers))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registers>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_registers))
    );
    fn test_field_cap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cap)
            )
        );
    }
    test_field_cap();
    fn test_field_vs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vs) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(vs)
            )
        );
    }
    test_field_vs();
    fn test_field_intms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intms) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(intms)
            )
        );
    }
    test_field_intms();
    fn test_field_intmc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intmc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(intmc)
            )
        );
    }
    test_field_intmc();
    fn test_field_cc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cc)
            )
        );
    }
    test_field_cc();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_csts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).csts) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(csts)
            )
        );
    }
    test_field_csts();
    fn test_field_nssr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nssr) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(nssr)
            )
        );
    }
    test_field_nssr();
    fn test_field_aqa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aqa) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(aqa)
            )
        );
    }
    test_field_aqa();
    fn test_field_asq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asq) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(asq)
            )
        );
    }
    test_field_asq();
    fn test_field_acq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).acq) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(acq)
            )
        );
    }
    test_field_acq();
    fn test_field_cmbloc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmbloc) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cmbloc)
            )
        );
    }
    test_field_cmbloc();
    fn test_field_cmbsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmbsz) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cmbsz)
            )
        );
    }
    test_field_cmbsz();
    fn test_field_bpinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpinfo) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(bpinfo)
            )
        );
    }
    test_field_bpinfo();
    fn test_field_bprsel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bprsel) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(bprsel)
            )
        );
    }
    test_field_bprsel();
    fn test_field_bpmbl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bpmbl) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(bpmbl)
            )
        );
    }
    test_field_bpmbl();
    fn test_field_cmbmsc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmbmsc) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cmbmsc)
            )
        );
    }
    test_field_cmbmsc();
    fn test_field_cmbsts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmbsts) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(cmbsts)
            )
        );
    }
    test_field_cmbsts();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_pmrcap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrcap) as usize - ptr as usize
            },
            3584usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrcap)
            )
        );
    }
    test_field_pmrcap();
    fn test_field_pmrctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrctl) as usize - ptr as usize
            },
            3588usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrctl)
            )
        );
    }
    test_field_pmrctl();
    fn test_field_pmrsts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrsts) as usize - ptr as usize
            },
            3592usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrsts)
            )
        );
    }
    test_field_pmrsts();
    fn test_field_pmrebs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrebs) as usize - ptr as usize
            },
            3596usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrebs)
            )
        );
    }
    test_field_pmrebs();
    fn test_field_pmrswtp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrswtp) as usize - ptr as usize
            },
            3600usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrswtp)
            )
        );
    }
    test_field_pmrswtp();
    fn test_field_pmrmscl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrmscl) as usize - ptr as usize
            },
            3604usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrmscl)
            )
        );
    }
    test_field_pmrmscl();
    fn test_field_pmrmscu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pmrmscu) as usize - ptr as usize
            },
            3608usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(pmrmscu)
            )
        );
    }
    test_field_pmrmscu();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            3612usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_doorbell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registers>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).doorbell) as usize - ptr as usize
            },
            4096usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registers),
                "::",
                stringify!(doorbell)
            )
        );
    }
    test_field_doorbell();
}
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 0;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_BIT_BUCKET:
    spdk_nvme_sgl_descriptor_type = 1;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_SEGMENT: spdk_nvme_sgl_descriptor_type =
    2;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_LAST_SEGMENT:
    spdk_nvme_sgl_descriptor_type = 3;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_KEYED_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 4;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_TRANSPORT_DATA_BLOCK:
    spdk_nvme_sgl_descriptor_type = 5;
pub const spdk_nvme_sgl_descriptor_type_SPDK_NVME_SGL_TYPE_VENDOR_SPECIFIC:
    spdk_nvme_sgl_descriptor_type = 15;
pub type spdk_nvme_sgl_descriptor_type = ::std::os::raw::c_uint;
pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_ADDRESS:
    spdk_nvme_sgl_descriptor_subtype = 0;
pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_OFFSET:
    spdk_nvme_sgl_descriptor_subtype = 1;
pub const spdk_nvme_sgl_descriptor_subtype_SPDK_NVME_SGL_SUBTYPE_TRANSPORT:
    spdk_nvme_sgl_descriptor_subtype = 10;
pub type spdk_nvme_sgl_descriptor_subtype = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_sgl_descriptor__bindgen_ty_1 {
    pub generic: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1,
    pub unkeyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
    pub keyed: spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub reserved: [u8; 7usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let subtype: u8 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    pub length: u32,
    pub reserved: [u8; 3usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn subtype(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subtype: u8, type_: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let subtype: u8 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let type_: u8 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_sgl_descriptor__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn length(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u64) }
    }
    #[inline]
    pub fn set_length(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn key(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_key(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn subtype(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_subtype(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(60usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(60usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        length: u64,
        key: u64,
        subtype: u64,
        type_: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let length: u64 = unsafe { ::std::mem::transmute(length) };
            length as u64
        });
        __bindgen_bitfield_unit.set(24usize, 32u8, {
            let key: u64 = unsafe { ::std::mem::transmute(key) };
            key as u64
        });
        __bindgen_bitfield_unit.set(56usize, 4u8, {
            let subtype: u64 = unsafe { ::std::mem::transmute(subtype) };
            subtype as u64
        });
        __bindgen_bitfield_unit.set(60usize, 4u8, {
            let type_: u64 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_sgl_descriptor__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sgl_descriptor__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1)
        )
    );
    fn test_field_generic() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sgl_descriptor__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1),
                "::",
                stringify!(generic)
            )
        );
    }
    test_field_generic();
    fn test_field_unkeyed() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sgl_descriptor__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unkeyed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1),
                "::",
                stringify!(unkeyed)
            )
        );
    }
    test_field_unkeyed();
    fn test_field_keyed() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sgl_descriptor__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyed) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sgl_descriptor__bindgen_ty_1),
                "::",
                stringify!(keyed)
            )
        );
    }
    test_field_keyed();
}
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_PRP: spdk_nvme_psdt_value = 0;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_CONTIG: spdk_nvme_psdt_value = 1;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_SGL_MPTR_SGL: spdk_nvme_psdt_value = 2;
pub const spdk_nvme_psdt_value_SPDK_NVME_PSDT_RESERVED: spdk_nvme_psdt_value = 3;
pub type spdk_nvme_psdt_value = ::std::os::raw::c_uint;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_URGENT: spdk_nvme_qprio = 0;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_HIGH: spdk_nvme_qprio = 1;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_MEDIUM: spdk_nvme_qprio = 2;
pub const spdk_nvme_qprio_SPDK_NVME_QPRIO_LOW: spdk_nvme_qprio = 3;
#[doc = " Submission queue priority values for Create I/O Submission Queue Command."]
#[doc = ""]
#[doc = " Only valid for weighted round robin arbitration method."]
pub type spdk_nvme_qprio = ::std::os::raw::c_uint;
#[doc = "< weighted round robin"]
pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_WRR: spdk_nvme_cap_ams = 1;
#[doc = "< vendor specific"]
pub const spdk_nvme_cap_ams_SPDK_NVME_CAP_AMS_VS: spdk_nvme_cap_ams = 2;
#[doc = " Optional Arbitration Mechanism Supported by the controller."]
#[doc = ""]
#[doc = " Two bits for CAP.AMS (18:17) field are set to '1' when the controller supports."]
#[doc = " There is no bit for AMS_RR where all controllers support and set to 0x0 by default."]
pub type spdk_nvme_cap_ams = ::std::os::raw::c_uint;
#[doc = "< default round robin"]
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_RR: spdk_nvme_cc_ams = 0;
#[doc = "< weighted round robin"]
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_WRR: spdk_nvme_cc_ams = 1;
#[doc = "< vendor specific"]
pub const spdk_nvme_cc_ams_SPDK_NVME_CC_AMS_VS: spdk_nvme_cc_ams = 7;
#[doc = " Arbitration Mechanism Selected to the controller."]
#[doc = ""]
#[doc = " Value 0x2 to 0x6 is reserved."]
pub type spdk_nvme_cc_ams = ::std::os::raw::c_uint;
#[doc = "< normal operation"]
pub const spdk_nvme_cmd_fuse_SPDK_NVME_CMD_FUSE_NONE: spdk_nvme_cmd_fuse = 0;
#[doc = "< fused operation, first command"]
pub const spdk_nvme_cmd_fuse_SPDK_NVME_CMD_FUSE_FIRST: spdk_nvme_cmd_fuse = 1;
#[doc = "< fused operation, second command"]
pub const spdk_nvme_cmd_fuse_SPDK_NVME_CMD_FUSE_SECOND: spdk_nvme_cmd_fuse = 2;
#[doc = "< fused operation flags mask"]
pub const spdk_nvme_cmd_fuse_SPDK_NVME_CMD_FUSE_MASK: spdk_nvme_cmd_fuse = 3;
#[doc = " Fused Operation"]
pub type spdk_nvme_cmd_fuse = ::std::os::raw::c_uint;
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_ARBITRATION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_arbitration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_arbitration__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_arbitration__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_arbitration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_arbitration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_arbitration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_arbitration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_arbitration__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_arbitration__bindgen_ty_1 {
    #[inline]
    pub fn ab(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ab(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn lpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn hpw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_hpw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ab: u32,
        reserved: u32,
        lpw: u32,
        mpw: u32,
        hpw: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let ab: u32 = unsafe { ::std::mem::transmute(ab) };
            ab as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let lpw: u32 = unsafe { ::std::mem::transmute(lpw) };
            lpw as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let mpw: u32 = unsafe { ::std::mem::transmute(mpw) };
            mpw as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let hpw: u32 = unsafe { ::std::mem::transmute(hpw) };
            hpw as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_arbitration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_arbitration>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_arbitration))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_arbitration>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_arbitration))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_arbitration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_arbitration),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_arbitration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_arbitration),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_POWER_MANAGEMENT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_power_management {
    pub raw: u32,
    pub bits: spdk_nvme_feat_power_management__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_power_management__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_power_management__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_power_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_power_management__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_power_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_power_management__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_power_management__bindgen_ty_1 {
    #[inline]
    pub fn ps(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_ps(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn wh(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_wh(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ps: u32, wh: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let ps: u32 = unsafe { ::std::mem::transmute(ps) };
            ps as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let wh: u32 = unsafe { ::std::mem::transmute(wh) };
            wh as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_power_management() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_power_management>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_power_management))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_power_management>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_power_management))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_power_management>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_power_management),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_power_management>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_power_management),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_LBA_RANGE_TYPE"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_lba_range_type {
    pub raw: u32,
    pub bits: spdk_nvme_feat_lba_range_type__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_lba_range_type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_lba_range_type__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_lba_range_type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_lba_range_type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_lba_range_type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_lba_range_type__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_lba_range_type__bindgen_ty_1 {
    #[inline]
    pub fn num(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_num(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(num: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let num: u32 = unsafe { ::std::mem::transmute(num) };
            num as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_lba_range_type() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_lba_range_type>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_lba_range_type))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_lba_range_type>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_lba_range_type))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_lba_range_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_lba_range_type),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_lba_range_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_lba_range_type),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_temperature_threshold {
    pub raw: u32,
    pub bits: spdk_nvme_feat_temperature_threshold__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_temperature_threshold__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_temperature_threshold__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_temperature_threshold__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_temperature_threshold__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_temperature_threshold__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_temperature_threshold__bindgen_ty_1 {
    #[inline]
    pub fn tmpth(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmpth(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tmpsel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_tmpsel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn thsel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_thsel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tmpth: u32,
        tmpsel: u32,
        thsel: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tmpth: u32 = unsafe { ::std::mem::transmute(tmpth) };
            tmpth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let tmpsel: u32 = unsafe { ::std::mem::transmute(tmpsel) };
            tmpsel as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let thsel: u32 = unsafe { ::std::mem::transmute(thsel) };
            thsel as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_temperature_threshold() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_temperature_threshold>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_temperature_threshold)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_temperature_threshold>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_temperature_threshold)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_temperature_threshold>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_temperature_threshold),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_temperature_threshold>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_temperature_threshold),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_ERROR_RECOVERY"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_error_recovery {
    pub raw: u32,
    pub bits: spdk_nvme_feat_error_recovery__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_error_recovery__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_error_recovery__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_error_recovery__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_error_recovery__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_error_recovery__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_error_recovery__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_error_recovery__bindgen_ty_1 {
    #[inline]
    pub fn tler(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tler(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn dulbe(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dulbe(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tler: u32,
        dulbe: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tler: u32 = unsafe { ::std::mem::transmute(tler) };
            tler as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let dulbe: u32 = unsafe { ::std::mem::transmute(dulbe) };
            dulbe as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_error_recovery() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_error_recovery>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_error_recovery))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_error_recovery>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_error_recovery))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_error_recovery>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_error_recovery),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_error_recovery>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_error_recovery),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_volatile_write_cache {
    pub raw: u32,
    pub bits: spdk_nvme_feat_volatile_write_cache__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_volatile_write_cache__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_volatile_write_cache__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_volatile_write_cache__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_volatile_write_cache__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_volatile_write_cache__bindgen_ty_1 {
    #[inline]
    pub fn wce(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wce(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wce: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wce: u32 = unsafe { ::std::mem::transmute(wce) };
            wce as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_volatile_write_cache() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_volatile_write_cache>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_volatile_write_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_volatile_write_cache>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_volatile_write_cache)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_volatile_write_cache>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_volatile_write_cache),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_volatile_write_cache>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_volatile_write_cache),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_NUMBER_OF_QUEUES"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_number_of_queues {
    pub raw: u32,
    pub bits: spdk_nvme_feat_number_of_queues__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_number_of_queues__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_number_of_queues__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_number_of_queues__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_number_of_queues__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_number_of_queues__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_number_of_queues__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_number_of_queues__bindgen_ty_1 {
    #[inline]
    pub fn nsqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_nsqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn ncqr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ncqr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(nsqr: u32, ncqr: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let nsqr: u32 = unsafe { ::std::mem::transmute(nsqr) };
            nsqr as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let ncqr: u32 = unsafe { ::std::mem::transmute(ncqr) };
            ncqr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_number_of_queues() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_number_of_queues>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_number_of_queues))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_number_of_queues>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_number_of_queues))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_number_of_queues>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_number_of_queues),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_number_of_queues>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_number_of_queues),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_INTERRUPT_COALESCING"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_interrupt_coalescing {
    pub raw: u32,
    pub bits: spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_interrupt_coalescing__bindgen_ty_1 {
    #[inline]
    pub fn thr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_thr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn time(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_time(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        thr: u32,
        time: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let thr: u32 = unsafe { ::std::mem::transmute(thr) };
            thr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let time: u32 = unsafe { ::std::mem::transmute(time) };
            time as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_coalescing() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_coalescing>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_interrupt_coalescing))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_coalescing>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_coalescing)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_interrupt_coalescing>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_interrupt_coalescing),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_interrupt_coalescing>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_interrupt_coalescing),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_interrupt_vector_configuration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_interrupt_vector_configuration__bindgen_ty_1 {
    #[inline]
    pub fn iv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_iv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cd(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cd(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(iv: u32, cd: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let iv: u32 = unsafe { ::std::mem::transmute(iv) };
            iv as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cd: u32 = unsafe { ::std::mem::transmute(cd) };
            cd as u64
        });
        __bindgen_bitfield_unit.set(17usize, 15u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_interrupt_vector_configuration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_interrupt_vector_configuration>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_interrupt_vector_configuration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_interrupt_vector_configuration)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < spdk_nvme_feat_interrupt_vector_configuration > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_interrupt_vector_configuration),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = :: std :: mem :: MaybeUninit :: < spdk_nvme_feat_interrupt_vector_configuration > :: uninit () ;
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_interrupt_vector_configuration),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_WRITE_ATOMICITY"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_write_atomicity {
    pub raw: u32,
    pub bits: spdk_nvme_feat_write_atomicity__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_write_atomicity__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_write_atomicity__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_write_atomicity__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_write_atomicity__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_write_atomicity__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_write_atomicity__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_write_atomicity__bindgen_ty_1 {
    #[inline]
    pub fn dn(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dn(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dn: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dn: u32 = unsafe { ::std::mem::transmute(dn) };
            dn as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_write_atomicity() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_write_atomicity>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_write_atomicity))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_write_atomicity>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_write_atomicity))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_write_atomicity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_write_atomicity),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_write_atomicity>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_write_atomicity),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_critical_warning_state {
    pub raw: u8,
    pub bits: spdk_nvme_critical_warning_state__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_critical_warning_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_critical_warning_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_critical_warning_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_critical_warning_state__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_critical_warning_state__bindgen_ty_1 {
    #[inline]
    pub fn available_spare(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_available_spare(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn temperature(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_temperature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn device_reliability(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_device_reliability(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn volatile_memory_backup(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_volatile_memory_backup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        available_spare: u8,
        temperature: u8,
        device_reliability: u8,
        read_only: u8,
        volatile_memory_backup: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let available_spare: u8 = unsafe { ::std::mem::transmute(available_spare) };
            available_spare as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let temperature: u8 = unsafe { ::std::mem::transmute(temperature) };
            temperature as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let device_reliability: u8 = unsafe { ::std::mem::transmute(device_reliability) };
            device_reliability as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let read_only: u8 = unsafe { ::std::mem::transmute(read_only) };
            read_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let volatile_memory_backup: u8 =
                unsafe { ::std::mem::transmute(volatile_memory_backup) };
            volatile_memory_backup as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_critical_warning_state() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_critical_warning_state>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_critical_warning_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_critical_warning_state>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_critical_warning_state)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_critical_warning_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_critical_warning_state),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_critical_warning_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_critical_warning_state),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features / Get Features \\ref SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_async_event_configuration {
    pub raw: u32,
    pub bits: spdk_nvme_feat_async_event_configuration__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Copy, Clone)]
pub struct spdk_nvme_feat_async_event_configuration__bindgen_ty_1 {
    pub crit_warn: spdk_nvme_critical_warning_state,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_async_event_configuration__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_async_event_configuration__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_async_event_configuration__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_async_event_configuration__bindgen_ty_1)
        )
    );
    fn test_field_crit_warn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_async_event_configuration__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crit_warn) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_async_event_configuration__bindgen_ty_1),
                "::",
                stringify!(crit_warn)
            )
        );
    }
    test_field_crit_warn();
}
impl spdk_nvme_feat_async_event_configuration__bindgen_ty_1 {
    #[inline]
    pub fn ns_attr_notice(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ns_attr_notice(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fw_activation_notice(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fw_activation_notice(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn telemetry_log_notice(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_telemetry_log_notice(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_change_notice(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_change_notice(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn discovery_log_change_notice(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_discovery_log_change_notice(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ns_attr_notice: u8,
        fw_activation_notice: u8,
        telemetry_log_notice: u8,
        ana_change_notice: u8,
        reserved1: u8,
        reserved2: u16,
        discovery_log_change_notice: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ns_attr_notice: u8 = unsafe { ::std::mem::transmute(ns_attr_notice) };
            ns_attr_notice as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fw_activation_notice: u8 = unsafe { ::std::mem::transmute(fw_activation_notice) };
            fw_activation_notice as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let telemetry_log_notice: u8 = unsafe { ::std::mem::transmute(telemetry_log_notice) };
            telemetry_log_notice as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ana_change_notice: u8 = unsafe { ::std::mem::transmute(ana_change_notice) };
            ana_change_notice as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let reserved2: u16 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let discovery_log_change_notice: u16 =
                unsafe { ::std::mem::transmute(discovery_log_change_notice) };
            discovery_log_change_notice as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_async_event_configuration() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_async_event_configuration>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_async_event_configuration)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_async_event_configuration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_async_event_configuration)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_async_event_configuration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_async_event_configuration),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_async_event_configuration>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_async_event_configuration),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_autonomous_power_state_transition {
    pub raw: u32,
    pub bits: spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_autonomous_power_state_transition__bindgen_ty_1 {
    #[inline]
    pub fn apste(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_apste(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(apste: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let apste: u32 = unsafe { ::std::mem::transmute(apste) };
            apste as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_autonomous_power_state_transition() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_autonomous_power_state_transition>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_autonomous_power_state_transition>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_autonomous_power_state_transition)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_autonomous_power_state_transition,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_autonomous_power_state_transition),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_autonomous_power_state_transition,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_autonomous_power_state_transition),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_HOST_MEM_BUFFER"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_mem_buffer {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_mem_buffer__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_mem_buffer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_mem_buffer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_mem_buffer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_mem_buffer__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_mem_buffer__bindgen_ty_1 {
    #[inline]
    pub fn ehm(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ehm(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ehm: u32, mr: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ehm: u32 = unsafe { ::std::mem::transmute(ehm) };
            ehm as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mr: u32 = unsafe { ::std::mem::transmute(mr) };
            mr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_mem_buffer() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_mem_buffer>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_host_mem_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_mem_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_host_mem_buffer))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_host_mem_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_mem_buffer),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_host_mem_buffer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_mem_buffer),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_KEEP_ALIVE_TIMER"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_keep_alive_timer {
    pub raw: u32,
    pub bits: spdk_nvme_feat_keep_alive_timer__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_keep_alive_timer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_keep_alive_timer__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_keep_alive_timer__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_keep_alive_timer__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_keep_alive_timer__bindgen_ty_1 {
    #[inline]
    pub fn kato(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_kato(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(kato: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let kato: u32 = unsafe { ::std::mem::transmute(kato) };
            kato as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_keep_alive_timer() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_keep_alive_timer>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_keep_alive_timer))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_keep_alive_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_keep_alive_timer))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_keep_alive_timer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_keep_alive_timer),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_keep_alive_timer>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_keep_alive_timer),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_controlled_thermal_management {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_controlled_thermal_management__bindgen_ty_1 {
    #[inline]
    pub fn tmt2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmt2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn tmt1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_tmt1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tmt2: u32, tmt1: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let tmt2: u32 = unsafe { ::std::mem::transmute(tmt2) };
            tmt2 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let tmt1: u32 = unsafe { ::std::mem::transmute(tmt1) };
            tmt1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_controlled_thermal_management() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_controlled_thermal_management>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_controlled_thermal_management>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_controlled_thermal_management)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_host_controlled_thermal_management,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_controlled_thermal_management),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_host_controlled_thermal_management,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_controlled_thermal_management),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_non_operational_power_state_config {
    pub raw: u32,
    pub bits: spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_non_operational_power_state_config__bindgen_ty_1 {
    #[inline]
    pub fn noppme(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_noppme(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(noppme: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let noppme: u32 = unsafe { ::std::mem::transmute(noppme) };
            noppme as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_non_operational_power_state_config() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_non_operational_power_state_config>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_non_operational_power_state_config>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_non_operational_power_state_config)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_non_operational_power_state_config,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_non_operational_power_state_config),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_feat_non_operational_power_state_config,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_non_operational_power_state_config),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_software_progress_marker {
    pub raw: u32,
    pub bits: spdk_nvme_feat_software_progress_marker__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_software_progress_marker__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_software_progress_marker__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_software_progress_marker__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_software_progress_marker__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_software_progress_marker__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_software_progress_marker__bindgen_ty_1 {
    #[inline]
    pub fn pbslc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_pbslc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pbslc: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let pbslc: u32 = unsafe { ::std::mem::transmute(pbslc) };
            pbslc as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_software_progress_marker() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_software_progress_marker>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_software_progress_marker)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_software_progress_marker>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_software_progress_marker)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_software_progress_marker>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_software_progress_marker),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_software_progress_marker>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_software_progress_marker),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_HOST_IDENTIFIER"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_host_identifier {
    pub raw: u32,
    pub bits: spdk_nvme_feat_host_identifier__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_host_identifier__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_identifier__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_identifier__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_host_identifier__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_identifier__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_host_identifier__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_host_identifier__bindgen_ty_1 {
    #[inline]
    pub fn exhid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_exhid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(exhid: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let exhid: u32 = unsafe { ::std::mem::transmute(exhid) };
            exhid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_host_identifier() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_host_identifier>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_feat_host_identifier))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_host_identifier>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_feat_host_identifier))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_host_identifier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_identifier),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_feat_host_identifier>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_host_identifier),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_HOST_RESERVE_MASK"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_reservation_notification_mask {
    pub raw: u32,
    pub bits: spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_reservation_notification_mask__bindgen_ty_1 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn regpre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_regpre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn resrel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_resrel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn respre(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_respre(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        regpre: u32,
        resrel: u32,
        respre: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let regpre: u32 = unsafe { ::std::mem::transmute(regpre) };
            regpre as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let resrel: u32 = unsafe { ::std::mem::transmute(resrel) };
            resrel as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let respre: u32 = unsafe { ::std::mem::transmute(respre) };
            respre as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_reservation_notification_mask() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_reservation_notification_mask>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_reservation_notification_mask)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_reservation_notification_mask>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_reservation_notification_mask)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_reservation_notification_mask>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_reservation_notification_mask),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_reservation_notification_mask>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_reservation_notification_mask),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Data used by Set Features/Get Features \\ref SPDK_NVME_FEAT_HOST_RESERVE_PERSIST"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_feat_reservation_persistence {
    pub raw: u32,
    pub bits: spdk_nvme_feat_reservation_persistence__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_feat_reservation_persistence__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_reservation_persistence__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_reservation_persistence__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_reservation_persistence__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_reservation_persistence__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_reservation_persistence__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_feat_reservation_persistence__bindgen_ty_1 {
    #[inline]
    pub fn ptpl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ptpl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ptpl: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ptpl: u32 = unsafe { ::std::mem::transmute(ptpl) };
            ptpl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_feat_reservation_persistence() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_feat_reservation_persistence>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_feat_reservation_persistence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_feat_reservation_persistence>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_feat_reservation_persistence)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_reservation_persistence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_reservation_persistence),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_feat_reservation_persistence>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_feat_reservation_persistence),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmd_cdw10 {
    pub raw: u32,
    pub identify: spdk_nvme_cmd_cdw10__bindgen_ty_1,
    pub get_log_page: spdk_nvme_cmd_cdw10__bindgen_ty_2,
    pub abort: spdk_nvme_cmd_cdw10__bindgen_ty_3,
    pub sec_send_recv: spdk_nvme_cmd_cdw10__bindgen_ty_4,
    pub create_io_q: spdk_nvme_cmd_cdw10__bindgen_ty_5,
    pub delete_io_q: spdk_nvme_cmd_cdw10__bindgen_ty_6,
    pub get_features: spdk_nvme_cmd_cdw10__bindgen_ty_7,
    pub set_features: spdk_nvme_cmd_cdw10__bindgen_ty_8,
    pub ns_attach: spdk_nvme_cmd_cdw10__bindgen_ty_9,
    pub ns_manage: spdk_nvme_cmd_cdw10__bindgen_ty_10,
    pub dsm: spdk_nvme_cmd_cdw10__bindgen_ty_11,
    pub resv_register: spdk_nvme_cmd_cdw10__bindgen_ty_12,
    pub resv_release: spdk_nvme_cmd_cdw10__bindgen_ty_13,
    pub resv_acquire: spdk_nvme_cmd_cdw10__bindgen_ty_14,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_1 {
    #[inline]
    pub fn cns(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_cns(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cntid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cntid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cns: u32,
        reserved: u32,
        cntid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cns: u32 = unsafe { ::std::mem::transmute(cns) };
            cns as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let cntid: u32 = unsafe { ::std::mem::transmute(cntid) };
            cntid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_2 {
    #[inline]
    pub fn lid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lsp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_lsp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rae(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rae(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numdl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_numdl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lid: u32,
        lsp: u32,
        reserved: u32,
        rae: u32,
        numdl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let lid: u32 = unsafe { ::std::mem::transmute(lid) };
            lid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let lsp: u32 = unsafe { ::std::mem::transmute(lsp) };
            lsp as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rae: u32 = unsafe { ::std::mem::transmute(rae) };
            rae as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let numdl: u32 = unsafe { ::std::mem::transmute(numdl) };
            numdl as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_3 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_3 {
    #[inline]
    pub fn sqid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_sqid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn cid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sqid: u32, cid: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let sqid: u32 = unsafe { ::std::mem::transmute(sqid) };
            sqid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let cid: u32 = unsafe { ::std::mem::transmute(cid) };
            cid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_4)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_4 {
    #[inline]
    pub fn nssf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nssf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn spsp0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_spsp0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn spsp1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_spsp1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn secp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_secp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nssf: u32,
        spsp0: u32,
        spsp1: u32,
        secp: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let nssf: u32 = unsafe { ::std::mem::transmute(nssf) };
            nssf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let spsp0: u32 = unsafe { ::std::mem::transmute(spsp0) };
            spsp0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let spsp1: u32 = unsafe { ::std::mem::transmute(spsp1) };
            spsp1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let secp: u32 = unsafe { ::std::mem::transmute(secp) };
            secp as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_5 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_5)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_5 {
    #[inline]
    pub fn qid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_qid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn qsize(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_qsize(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(qid: u32, qsize: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let qid: u32 = unsafe { ::std::mem::transmute(qid) };
            qid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let qsize: u32 = unsafe { ::std::mem::transmute(qsize) };
            qsize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_6 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_6)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_6 {
    #[inline]
    pub fn qid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_qid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(qid: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let qid: u32 = unsafe { ::std::mem::transmute(qid) };
            qid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_7 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_7)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_7 {
    #[inline]
    pub fn fid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_fid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 21u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 21u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        fid: u32,
        sel: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fid: u32 = unsafe { ::std::mem::transmute(fid) };
            fid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let sel: u32 = unsafe { ::std::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(11usize, 21u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_8 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_8>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_8)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_8 {
    #[inline]
    pub fn fid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_fid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn sv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fid: u32, reserved: u32, sv: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let fid: u32 = unsafe { ::std::mem::transmute(fid) };
            fid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 23u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sv: u32 = unsafe { ::std::mem::transmute(sv) };
            sv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_9 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_9>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_9)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_9 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sel: u32 = unsafe { ::std::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_10 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_10>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_10)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_10 {
    #[inline]
    pub fn sel(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_sel(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sel: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let sel: u32 = unsafe { ::std::mem::transmute(sel) };
            sel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_11 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_11>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_11>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_11)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_11 {
    #[inline]
    pub fn nr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_nr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(nr: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let nr: u32 = unsafe { ::std::mem::transmute(nr) };
            nr as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_12 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_12)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_12 {
    #[inline]
    pub fn rrega(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rrega(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn iekey(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iekey(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn cptpl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cptpl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rrega: u32,
        iekey: u32,
        reserved: u32,
        cptpl: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rrega: u32 = unsafe { ::std::mem::transmute(rrega) };
            rrega as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let iekey: u32 = unsafe { ::std::mem::transmute(iekey) };
            iekey as u64
        });
        __bindgen_bitfield_unit.set(4usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cptpl: u32 = unsafe { ::std::mem::transmute(cptpl) };
            cptpl as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_13 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_13>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_13)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_13 {
    #[inline]
    pub fn rrela(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_rrela(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn iekey(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iekey(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rrela: u32,
        iekey: u32,
        reserved1: u32,
        rtype: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let rrela: u32 = unsafe { ::std::mem::transmute(rrela) };
            rrela as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let iekey: u32 = unsafe { ::std::mem::transmute(iekey) };
            iekey as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let rtype: u32 = unsafe { ::std::mem::transmute(rtype) };
            rtype as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw10__bindgen_ty_14 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10__bindgen_ty_14>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw10__bindgen_ty_14)
        )
    );
}
impl spdk_nvme_cmd_cdw10__bindgen_ty_14 {
    #[inline]
    pub fn racqa(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_racqa(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn iekey(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_iekey(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        racqa: u32,
        iekey: u32,
        reserved1: u32,
        rtype: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let racqa: u32 = unsafe { ::std::mem::transmute(racqa) };
            racqa as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let iekey: u32 = unsafe { ::std::mem::transmute(iekey) };
            iekey as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let rtype: u32 = unsafe { ::std::mem::transmute(rtype) };
            rtype as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw10>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw10>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd_cdw10))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_identify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identify) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(identify)
            )
        );
    }
    test_field_identify();
    fn test_field_get_log_page() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_log_page) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(get_log_page)
            )
        );
    }
    test_field_get_log_page();
    fn test_field_abort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).abort) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(abort)
            )
        );
    }
    test_field_abort();
    fn test_field_sec_send_recv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sec_send_recv) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(sec_send_recv)
            )
        );
    }
    test_field_sec_send_recv();
    fn test_field_create_io_q() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create_io_q) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(create_io_q)
            )
        );
    }
    test_field_create_io_q();
    fn test_field_delete_io_q() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delete_io_q) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(delete_io_q)
            )
        );
    }
    test_field_delete_io_q();
    fn test_field_get_features() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_features) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(get_features)
            )
        );
    }
    test_field_get_features();
    fn test_field_set_features() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_features) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(set_features)
            )
        );
    }
    test_field_set_features();
    fn test_field_ns_attach() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns_attach) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(ns_attach)
            )
        );
    }
    test_field_ns_attach();
    fn test_field_ns_manage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns_manage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(ns_manage)
            )
        );
    }
    test_field_ns_manage();
    fn test_field_dsm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dsm) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(dsm)
            )
        );
    }
    test_field_dsm();
    fn test_field_resv_register() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resv_register) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(resv_register)
            )
        );
    }
    test_field_resv_register();
    fn test_field_resv_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resv_release) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(resv_release)
            )
        );
    }
    test_field_resv_release();
    fn test_field_resv_acquire() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resv_acquire) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw10),
                "::",
                stringify!(resv_acquire)
            )
        );
    }
    test_field_resv_acquire();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmd_cdw11 {
    pub raw: u32,
    pub identify: spdk_nvme_cmd_cdw11__bindgen_ty_1,
    pub create_io_sq: spdk_nvme_cmd_cdw11__bindgen_ty_2,
    pub create_io_cq: spdk_nvme_cmd_cdw11__bindgen_ty_3,
    pub directive: spdk_nvme_cmd_cdw11__bindgen_ty_4,
    pub get_log_page: spdk_nvme_cmd_cdw11__bindgen_ty_5,
    pub resv_report: spdk_nvme_cmd_cdw11__bindgen_ty_6,
    pub feat_arbitration: spdk_nvme_feat_arbitration,
    pub feat_power_management: spdk_nvme_feat_power_management,
    pub feat_lba_range_type: spdk_nvme_feat_lba_range_type,
    pub feat_temp_threshold: spdk_nvme_feat_temperature_threshold,
    pub feat_error_recovery: spdk_nvme_feat_error_recovery,
    pub feat_volatile_write_cache: spdk_nvme_feat_volatile_write_cache,
    pub feat_num_of_queues: spdk_nvme_feat_number_of_queues,
    pub feat_interrupt_coalescing: spdk_nvme_feat_interrupt_coalescing,
    pub feat_interrupt_vector_configuration: spdk_nvme_feat_interrupt_vector_configuration,
    pub feat_write_atomicity: spdk_nvme_feat_write_atomicity,
    pub feat_async_event_cfg: spdk_nvme_feat_async_event_configuration,
    pub feat_keep_alive_timer: spdk_nvme_feat_keep_alive_timer,
    pub feat_host_identifier: spdk_nvme_feat_host_identifier,
    pub feat_rsv_notification_mask: spdk_nvme_feat_reservation_notification_mask,
    pub feat_rsv_persistence: spdk_nvme_feat_reservation_persistence,
    pub dsm: spdk_nvme_cmd_cdw11__bindgen_ty_7,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_1 {
    #[inline]
    pub fn nvmsetid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_nvmsetid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn csi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_csi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nvmsetid: u32,
        reserved: u32,
        csi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let nvmsetid: u32 = unsafe { ::std::mem::transmute(nvmsetid) };
            nvmsetid as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let csi: u32 = unsafe { ::std::mem::transmute(csi) };
            csi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_2 {
    #[inline]
    pub fn pc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qprio(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_qprio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn cqid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_cqid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pc: u32,
        qprio: u32,
        reserved: u32,
        cqid: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pc: u32 = unsafe { ::std::mem::transmute(pc) };
            pc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let qprio: u32 = unsafe { ::std::mem::transmute(qprio) };
            qprio as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let cqid: u32 = unsafe { ::std::mem::transmute(cqid) };
            cqid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_3 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_3 {
    #[inline]
    pub fn pc(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pc(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ien(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ien(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn iv(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_iv(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pc: u32,
        ien: u32,
        reserved: u32,
        iv: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pc: u32 = unsafe { ::std::mem::transmute(pc) };
            pc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ien: u32 = unsafe { ::std::mem::transmute(ien) };
            ien as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let iv: u32 = unsafe { ::std::mem::transmute(iv) };
            iv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_4 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_4)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_4 {
    #[inline]
    pub fn doper(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_doper(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dtype(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_dtype(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn dspec(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_dspec(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        doper: u32,
        dtype: u32,
        dspec: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let doper: u32 = unsafe { ::std::mem::transmute(doper) };
            doper as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let dtype: u32 = unsafe { ::std::mem::transmute(dtype) };
            dtype as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let dspec: u32 = unsafe { ::std::mem::transmute(dspec) };
            dspec as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_5 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_5>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_5)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_5 {
    #[inline]
    pub fn numdu(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_numdu(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn lsid(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_lsid(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(numdu: u32, lsid: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let numdu: u32 = unsafe { ::std::mem::transmute(numdu) };
            numdu as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let lsid: u32 = unsafe { ::std::mem::transmute(lsid) };
            lsid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_6 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_6>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_6)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_6 {
    #[inline]
    pub fn eds(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eds(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(eds: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let eds: u32 = unsafe { ::std::mem::transmute(eds) };
            eds as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd_cdw11__bindgen_ty_7 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11__bindgen_ty_7>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd_cdw11__bindgen_ty_7)
        )
    );
}
impl spdk_nvme_cmd_cdw11__bindgen_ty_7 {
    #[inline]
    pub fn idr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn idw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ad(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ad(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        idr: u32,
        idw: u32,
        ad: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let idr: u32 = unsafe { ::std::mem::transmute(idr) };
            idr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let idw: u32 = unsafe { ::std::mem::transmute(idw) };
            idw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ad: u32 = unsafe { ::std::mem::transmute(ad) };
            ad as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd_cdw11() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd_cdw11>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd_cdw11))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd_cdw11>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd_cdw11))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_identify() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).identify) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(identify)
            )
        );
    }
    test_field_identify();
    fn test_field_create_io_sq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create_io_sq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(create_io_sq)
            )
        );
    }
    test_field_create_io_sq();
    fn test_field_create_io_cq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create_io_cq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(create_io_cq)
            )
        );
    }
    test_field_create_io_cq();
    fn test_field_directive() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directive) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(directive)
            )
        );
    }
    test_field_directive();
    fn test_field_get_log_page() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_log_page) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(get_log_page)
            )
        );
    }
    test_field_get_log_page();
    fn test_field_resv_report() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resv_report) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(resv_report)
            )
        );
    }
    test_field_resv_report();
    fn test_field_feat_arbitration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_arbitration) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_arbitration)
            )
        );
    }
    test_field_feat_arbitration();
    fn test_field_feat_power_management() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_power_management) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_power_management)
            )
        );
    }
    test_field_feat_power_management();
    fn test_field_feat_lba_range_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_lba_range_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_lba_range_type)
            )
        );
    }
    test_field_feat_lba_range_type();
    fn test_field_feat_temp_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_temp_threshold) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_temp_threshold)
            )
        );
    }
    test_field_feat_temp_threshold();
    fn test_field_feat_error_recovery() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_error_recovery) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_error_recovery)
            )
        );
    }
    test_field_feat_error_recovery();
    fn test_field_feat_volatile_write_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_volatile_write_cache) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_volatile_write_cache)
            )
        );
    }
    test_field_feat_volatile_write_cache();
    fn test_field_feat_num_of_queues() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_num_of_queues) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_num_of_queues)
            )
        );
    }
    test_field_feat_num_of_queues();
    fn test_field_feat_interrupt_coalescing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_interrupt_coalescing) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_interrupt_coalescing)
            )
        );
    }
    test_field_feat_interrupt_coalescing();
    fn test_field_feat_interrupt_vector_configuration() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_interrupt_vector_configuration) as usize
                    - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_interrupt_vector_configuration)
            )
        );
    }
    test_field_feat_interrupt_vector_configuration();
    fn test_field_feat_write_atomicity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_write_atomicity) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_write_atomicity)
            )
        );
    }
    test_field_feat_write_atomicity();
    fn test_field_feat_async_event_cfg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_async_event_cfg) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_async_event_cfg)
            )
        );
    }
    test_field_feat_async_event_cfg();
    fn test_field_feat_keep_alive_timer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_keep_alive_timer) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_keep_alive_timer)
            )
        );
    }
    test_field_feat_keep_alive_timer();
    fn test_field_feat_host_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_host_identifier) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_host_identifier)
            )
        );
    }
    test_field_feat_host_identifier();
    fn test_field_feat_rsv_notification_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_rsv_notification_mask) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_rsv_notification_mask)
            )
        );
    }
    test_field_feat_rsv_notification_mask();
    fn test_field_feat_rsv_persistence() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feat_rsv_persistence) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(feat_rsv_persistence)
            )
        );
    }
    test_field_feat_rsv_persistence();
    fn test_field_dsm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd_cdw11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dsm) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd_cdw11),
                "::",
                stringify!(dsm)
            )
        );
    }
    test_field_dsm();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1 {
    pub prp1: u64,
    pub prp2: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_prp1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prp1) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(prp1)
            )
        );
    }
    test_field_prp1();
    fn test_field_prp2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prp2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(prp2)
            )
        );
    }
    test_field_prp2();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmd__bindgen_ty_2 {
    pub cdw10: u32,
    pub cdw10_bits: spdk_nvme_cmd_cdw10,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd__bindgen_ty_2))
    );
    fn test_field_cdw10() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw10) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_2),
                "::",
                stringify!(cdw10)
            )
        );
    }
    test_field_cdw10();
    fn test_field_cdw10_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw10_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_2),
                "::",
                stringify!(cdw10_bits)
            )
        );
    }
    test_field_cdw10_bits();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cmd__bindgen_ty_3 {
    pub cdw11: u32,
    pub cdw11_bits: spdk_nvme_cmd_cdw11,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmd__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmd__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmd__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmd__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmd__bindgen_ty_3))
    );
    fn test_field_cdw11() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw11) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_3),
                "::",
                stringify!(cdw11)
            )
        );
    }
    test_field_cdw11();
    fn test_field_cdw11_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cmd__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw11_bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmd__bindgen_ty_3),
                "::",
                stringify!(cdw11_bits)
            )
        );
    }
    test_field_cdw11_bits();
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_status {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_status() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_status>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_status))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_status>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_status))
    );
}
impl spdk_nvme_status {
    #[inline]
    pub fn p(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_p(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_sc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sct(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_sct(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn crd(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_crd(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn m(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_m(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dnr(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dnr(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        p: u16,
        sc: u16,
        sct: u16,
        crd: u16,
        m: u16,
        dnr: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let p: u16 = unsafe { ::std::mem::transmute(p) };
            p as u64
        });
        __bindgen_bitfield_unit.set(1usize, 8u8, {
            let sc: u16 = unsafe { ::std::mem::transmute(sc) };
            sc as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let sct: u16 = unsafe { ::std::mem::transmute(sct) };
            sct as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let crd: u16 = unsafe { ::std::mem::transmute(crd) };
            crd as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let m: u16 = unsafe { ::std::mem::transmute(m) };
            m as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let dnr: u16 = unsafe { ::std::mem::transmute(dnr) };
            dnr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Completion queue entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_cpl {
    pub cdw0: u32,
    pub cdw1: u32,
    pub sqhd: u16,
    pub sqid: u16,
    pub cid: u16,
    pub __bindgen_anon_1: spdk_nvme_cpl__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_cpl__bindgen_ty_1 {
    pub status_raw: u16,
    pub status: spdk_nvme_status,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cpl__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cpl__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_cpl__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cpl__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cpl__bindgen_ty_1))
    );
    fn test_field_status_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status_raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl__bindgen_ty_1),
                "::",
                stringify!(status_raw)
            )
        );
    }
    test_field_status_raw();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl__bindgen_ty_1),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[test]
fn bindgen_test_layout_spdk_nvme_cpl() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cpl>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_cpl))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cpl>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cpl))
    );
    fn test_field_cdw0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw0) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl),
                "::",
                stringify!(cdw0)
            )
        );
    }
    test_field_cdw0();
    fn test_field_cdw1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cdw1) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl),
                "::",
                stringify!(cdw1)
            )
        );
    }
    test_field_cdw1();
    fn test_field_sqhd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sqhd) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl),
                "::",
                stringify!(sqhd)
            )
        );
    }
    test_field_sqhd();
    fn test_field_sqid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sqid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl),
                "::",
                stringify!(sqid)
            )
        );
    }
    test_field_sqid();
    fn test_field_cid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cpl>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cpl),
                "::",
                stringify!(cid)
            )
        );
    }
    test_field_cid();
}
#[doc = " Dataset Management range"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_dsm_range {
    pub attributes: spdk_nvme_dsm_range__bindgen_ty_1,
    pub length: u32,
    pub starting_lba: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_dsm_range__bindgen_ty_1 {
    pub bits: spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1,
    pub raw: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_dsm_range__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn af(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_af(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn al(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_al(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn sr(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sr(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sw(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn access_size(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_access_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        af: u32,
        al: u32,
        reserved0: u32,
        sr: u32,
        sw: u32,
        wp: u32,
        reserved1: u32,
        access_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let af: u32 = unsafe { ::std::mem::transmute(af) };
            af as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let al: u32 = unsafe { ::std::mem::transmute(al) };
            al as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved0: u32 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sr: u32 = unsafe { ::std::mem::transmute(sr) };
            sr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw: u32 = unsafe { ::std::mem::transmute(sw) };
            sw as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wp: u32 = unsafe { ::std::mem::transmute(wp) };
            wp as u64
        });
        __bindgen_bitfield_unit.set(11usize, 13u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let access_size: u32 = unsafe { ::std::mem::transmute(access_size) };
            access_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_dsm_range__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_dsm_range__bindgen_ty_1)
        )
    );
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_dsm_range__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_dsm_range__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_dsm_range__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_dsm_range__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
}
#[test]
fn bindgen_test_layout_spdk_nvme_dsm_range() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_dsm_range>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_dsm_range))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_dsm_range>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_dsm_range))
    );
    fn test_field_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_dsm_range>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_dsm_range),
                "::",
                stringify!(attributes)
            )
        );
    }
    test_field_attributes();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_dsm_range>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_dsm_range),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_starting_lba() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_dsm_range>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).starting_lba) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_dsm_range),
                "::",
                stringify!(starting_lba)
            )
        );
    }
    test_field_starting_lba();
}
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_GENERIC: spdk_nvme_status_code_type = 0;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_COMMAND_SPECIFIC: spdk_nvme_status_code_type = 1;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_MEDIA_ERROR: spdk_nvme_status_code_type = 2;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_PATH: spdk_nvme_status_code_type = 3;
pub const spdk_nvme_status_code_type_SPDK_NVME_SCT_VENDOR_SPECIFIC: spdk_nvme_status_code_type = 7;
#[doc = " Status code types"]
pub type spdk_nvme_status_code_type = ::std::os::raw::c_uint;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SUCCESS:
    spdk_nvme_generic_command_status_code = 0;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_OPCODE:
    spdk_nvme_generic_command_status_code = 1;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_FIELD:
    spdk_nvme_generic_command_status_code = 2;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_ID_CONFLICT:
    spdk_nvme_generic_command_status_code = 3;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_TRANSFER_ERROR:
    spdk_nvme_generic_command_status_code = 4;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_POWER_LOSS:
    spdk_nvme_generic_command_status_code = 5;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INTERNAL_DEVICE_ERROR:
    spdk_nvme_generic_command_status_code = 6;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_BY_REQUEST:
    spdk_nvme_generic_command_status_code = 7;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_SQ_DELETION:
    spdk_nvme_generic_command_status_code = 8;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_FAILED_FUSED:
    spdk_nvme_generic_command_status_code = 9;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_MISSING_FUSED:
    spdk_nvme_generic_command_status_code = 10;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NAMESPACE_OR_FORMAT:
    spdk_nvme_generic_command_status_code = 11;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_SEQUENCE_ERROR:
    spdk_nvme_generic_command_status_code = 12;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_SEG_DESCRIPTOR:
    spdk_nvme_generic_command_status_code = 13;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_NUM_SGL_DESCIRPTORS:
    spdk_nvme_generic_command_status_code = 14;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_DATA_SGL_LENGTH_INVALID:
    spdk_nvme_generic_command_status_code = 15;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_METADATA_SGL_LENGTH_INVALID:
    spdk_nvme_generic_command_status_code = 16;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DESCRIPTOR_TYPE_INVALID:
    spdk_nvme_generic_command_status_code = 17;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_CONTROLLER_MEM_BUF:
    spdk_nvme_generic_command_status_code = 18;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_PRP_OFFSET:
    spdk_nvme_generic_command_status_code = 19;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ATOMIC_WRITE_UNIT_EXCEEDED:
    spdk_nvme_generic_command_status_code = 20;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_OPERATION_DENIED:
    spdk_nvme_generic_command_status_code = 21;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_INVALID_SGL_OFFSET:
    spdk_nvme_generic_command_status_code = 22;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_HOSTID_INCONSISTENT_FORMAT:
    spdk_nvme_generic_command_status_code = 24;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_EXPIRED:
    spdk_nvme_generic_command_status_code = 25;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_KEEP_ALIVE_INVALID:
    spdk_nvme_generic_command_status_code = 26;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_ABORTED_PREEMPT:
    spdk_nvme_generic_command_status_code = 27;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_FAILED:
    spdk_nvme_generic_command_status_code = 28;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SANITIZE_IN_PROGRESS:
    spdk_nvme_generic_command_status_code = 29;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_SGL_DATA_BLOCK_GRANULARITY_INVALID:
    spdk_nvme_generic_command_status_code = 30;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_COMMAND_INVALID_IN_CMB:
    spdk_nvme_generic_command_status_code = 31;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_LBA_OUT_OF_RANGE:
    spdk_nvme_generic_command_status_code = 128;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_CAPACITY_EXCEEDED:
    spdk_nvme_generic_command_status_code = 129;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_NAMESPACE_NOT_READY:
    spdk_nvme_generic_command_status_code = 130;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_RESERVATION_CONFLICT:
    spdk_nvme_generic_command_status_code = 131;
pub const spdk_nvme_generic_command_status_code_SPDK_NVME_SC_FORMAT_IN_PROGRESS:
    spdk_nvme_generic_command_status_code = 132;
#[doc = " Generic command status codes"]
pub type spdk_nvme_generic_command_status_code = ::std::os::raw::c_uint;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_COMPLETION_QUEUE_INVALID:
    spdk_nvme_command_specific_status_code = 0;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_IDENTIFIER:
    spdk_nvme_command_specific_status_code = 1;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_SIZE:
    spdk_nvme_command_specific_status_code = 2;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ABORT_COMMAND_LIMIT_EXCEEDED:
    spdk_nvme_command_specific_status_code = 3;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ASYNC_EVENT_REQUEST_LIMIT_EXCEEDED:
    spdk_nvme_command_specific_status_code = 5;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_SLOT:
    spdk_nvme_command_specific_status_code = 6;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FIRMWARE_IMAGE:
    spdk_nvme_command_specific_status_code = 7;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_INTERRUPT_VECTOR:
    spdk_nvme_command_specific_status_code = 8;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_LOG_PAGE:
    spdk_nvme_command_specific_status_code = 9;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_FORMAT:
    spdk_nvme_command_specific_status_code = 10;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_CONVENTIONAL_RESET:
    spdk_nvme_command_specific_status_code = 11;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_QUEUE_DELETION:
    spdk_nvme_command_specific_status_code = 12;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_ID_NOT_SAVEABLE:
    spdk_nvme_command_specific_status_code = 13;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_CHANGEABLE:
    spdk_nvme_command_specific_status_code = 14;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FEATURE_NOT_NAMESPACE_SPECIFIC:
    spdk_nvme_command_specific_status_code = 15;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_NVM_RESET:
    spdk_nvme_command_specific_status_code = 16;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_RESET:
    spdk_nvme_command_specific_status_code = 17;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_REQ_MAX_TIME_VIOLATION:
    spdk_nvme_command_specific_status_code = 18;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_FIRMWARE_ACTIVATION_PROHIBITED:
    spdk_nvme_command_specific_status_code = 19;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_OVERLAPPING_RANGE:
    spdk_nvme_command_specific_status_code = 20;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_INSUFFICIENT_CAPACITY:
    spdk_nvme_command_specific_status_code = 21;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ID_UNAVAILABLE:
    spdk_nvme_command_specific_status_code = 22;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_ALREADY_ATTACHED:
    spdk_nvme_command_specific_status_code = 24;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_IS_PRIVATE:
    spdk_nvme_command_specific_status_code = 25;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_NAMESPACE_NOT_ATTACHED:
    spdk_nvme_command_specific_status_code = 26;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_THINPROVISIONING_NOT_SUPPORTED:
    spdk_nvme_command_specific_status_code = 27;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONTROLLER_LIST_INVALID:
    spdk_nvme_command_specific_status_code = 28;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_DEVICE_SELF_TEST_IN_PROGRESS:
    spdk_nvme_command_specific_status_code = 29;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_BOOT_PARTITION_WRITE_PROHIBITED:
    spdk_nvme_command_specific_status_code = 30;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_CTRLR_ID:
    spdk_nvme_command_specific_status_code = 31;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_SECONDARY_CTRLR_STATE:
    spdk_nvme_command_specific_status_code = 32;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_NUM_CTRLR_RESOURCES:
    spdk_nvme_command_specific_status_code = 33;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_RESOURCE_ID:
    spdk_nvme_command_specific_status_code = 34;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_IOCS_NOT_SUPPORTED:
    spdk_nvme_command_specific_status_code = 41;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_IOCS_NOT_ENABLED:
    spdk_nvme_command_specific_status_code = 42;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_IOCS_COMBINATION_REJECTED:
    spdk_nvme_command_specific_status_code = 43;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_IOCS:
    spdk_nvme_command_specific_status_code = 44;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_STREAM_RESOURCE_ALLOCATION_FAILED:
    spdk_nvme_command_specific_status_code = 127;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_CONFLICTING_ATTRIBUTES:
    spdk_nvme_command_specific_status_code = 128;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_INVALID_PROTECTION_INFO:
    spdk_nvme_command_specific_status_code = 129;
pub const spdk_nvme_command_specific_status_code_SPDK_NVME_SC_ATTEMPTED_WRITE_TO_RO_RANGE:
    spdk_nvme_command_specific_status_code = 130;
#[doc = " Command specific status codes"]
pub type spdk_nvme_command_specific_status_code = ::std::os::raw::c_uint;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_WRITE_FAULTS:
    spdk_nvme_media_error_status_code = 128;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_UNRECOVERED_READ_ERROR:
    spdk_nvme_media_error_status_code = 129;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_GUARD_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 130;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_APPLICATION_TAG_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 131;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_REFERENCE_TAG_CHECK_ERROR:
    spdk_nvme_media_error_status_code = 132;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_COMPARE_FAILURE:
    spdk_nvme_media_error_status_code = 133;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_ACCESS_DENIED:
    spdk_nvme_media_error_status_code = 134;
pub const spdk_nvme_media_error_status_code_SPDK_NVME_SC_DEALLOCATED_OR_UNWRITTEN_BLOCK:
    spdk_nvme_media_error_status_code = 135;
#[doc = " Media error status codes"]
pub type spdk_nvme_media_error_status_code = ::std::os::raw::c_uint;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_INTERNAL_PATH_ERROR: spdk_nvme_path_status_code =
    0;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ASYMMETRIC_ACCESS_PERSISTENT_LOSS:
    spdk_nvme_path_status_code = 1;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ASYMMETRIC_ACCESS_INACCESSIBLE:
    spdk_nvme_path_status_code = 2;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ASYMMETRIC_ACCESS_TRANSITION:
    spdk_nvme_path_status_code = 3;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_CONTROLLER_PATH_ERROR:
    spdk_nvme_path_status_code = 96;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_HOST_PATH_ERROR: spdk_nvme_path_status_code = 112;
pub const spdk_nvme_path_status_code_SPDK_NVME_SC_ABORTED_BY_HOST: spdk_nvme_path_status_code = 113;
#[doc = " Path related status codes"]
pub type spdk_nvme_path_status_code = ::std::os::raw::c_uint;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_SQ: spdk_nvme_admin_opcode = 0;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_SQ: spdk_nvme_admin_opcode = 1;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LOG_PAGE: spdk_nvme_admin_opcode = 2;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DELETE_IO_CQ: spdk_nvme_admin_opcode = 4;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_CREATE_IO_CQ: spdk_nvme_admin_opcode = 5;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_IDENTIFY: spdk_nvme_admin_opcode = 6;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ABORT: spdk_nvme_admin_opcode = 8;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SET_FEATURES: spdk_nvme_admin_opcode = 9;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_FEATURES: spdk_nvme_admin_opcode = 10;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_ASYNC_EVENT_REQUEST: spdk_nvme_admin_opcode = 12;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_MANAGEMENT: spdk_nvme_admin_opcode = 13;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_COMMIT: spdk_nvme_admin_opcode = 16;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FIRMWARE_IMAGE_DOWNLOAD: spdk_nvme_admin_opcode = 17;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DEVICE_SELF_TEST: spdk_nvme_admin_opcode = 20;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NS_ATTACHMENT: spdk_nvme_admin_opcode = 21;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_KEEP_ALIVE: spdk_nvme_admin_opcode = 24;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_SEND: spdk_nvme_admin_opcode = 25;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DIRECTIVE_RECEIVE: spdk_nvme_admin_opcode = 26;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_VIRTUALIZATION_MANAGEMENT: spdk_nvme_admin_opcode =
    28;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_SEND: spdk_nvme_admin_opcode = 29;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_NVME_MI_RECEIVE: spdk_nvme_admin_opcode = 30;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_DOORBELL_BUFFER_CONFIG: spdk_nvme_admin_opcode = 124;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_FORMAT_NVM: spdk_nvme_admin_opcode = 128;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_SEND: spdk_nvme_admin_opcode = 129;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SECURITY_RECEIVE: spdk_nvme_admin_opcode = 130;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_SANITIZE: spdk_nvme_admin_opcode = 132;
pub const spdk_nvme_admin_opcode_SPDK_NVME_OPC_GET_LBA_STATUS: spdk_nvme_admin_opcode = 134;
#[doc = " Admin opcodes"]
pub type spdk_nvme_admin_opcode = ::std::os::raw::c_uint;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_FLUSH: spdk_nvme_nvm_opcode = 0;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE: spdk_nvme_nvm_opcode = 1;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_READ: spdk_nvme_nvm_opcode = 2;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_UNCORRECTABLE: spdk_nvme_nvm_opcode = 4;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_COMPARE: spdk_nvme_nvm_opcode = 5;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_WRITE_ZEROES: spdk_nvme_nvm_opcode = 8;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_DATASET_MANAGEMENT: spdk_nvme_nvm_opcode = 9;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REGISTER: spdk_nvme_nvm_opcode = 13;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_REPORT: spdk_nvme_nvm_opcode = 14;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_ACQUIRE: spdk_nvme_nvm_opcode = 17;
pub const spdk_nvme_nvm_opcode_SPDK_NVME_OPC_RESERVATION_RELEASE: spdk_nvme_nvm_opcode = 21;
#[doc = " NVM command set opcodes"]
pub type spdk_nvme_nvm_opcode = ::std::os::raw::c_uint;
pub const spdk_nvme_zns_opcode_SPDK_NVME_OPC_ZONE_MGMT_SEND: spdk_nvme_zns_opcode = 121;
pub const spdk_nvme_zns_opcode_SPDK_NVME_OPC_ZONE_MGMT_RECV: spdk_nvme_zns_opcode = 122;
pub const spdk_nvme_zns_opcode_SPDK_NVME_OPC_ZONE_APPEND: spdk_nvme_zns_opcode = 125;
#[doc = " Zoned Namespace command set opcodes"]
#[doc = ""]
#[doc = " In addition to the opcodes of the NVM command set, the Zoned Namespace"]
#[doc = " command set supports the following opcodes."]
pub type spdk_nvme_zns_opcode = ::std::os::raw::c_uint;
#[doc = " Opcode does not transfer data"]
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_NONE: spdk_nvme_data_transfer = 0;
#[doc = " Opcode transfers data from host to controller (e.g. Write)"]
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_HOST_TO_CONTROLLER: spdk_nvme_data_transfer = 1;
#[doc = " Opcode transfers data from controller to host (e.g. Read)"]
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_CONTROLLER_TO_HOST: spdk_nvme_data_transfer = 2;
#[doc = " Opcode transfers data both directions"]
pub const spdk_nvme_data_transfer_SPDK_NVME_DATA_BIDIRECTIONAL: spdk_nvme_data_transfer = 3;
#[doc = " Data transfer (bits 1:0) of an NVMe opcode."]
#[doc = ""]
#[doc = " \\sa spdk_nvme_opc_get_data_transfer"]
pub type spdk_nvme_data_transfer = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_host_behavior {
    pub acre: u8,
    pub reserved: [u8; 511usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_host_behavior() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_host_behavior>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_host_behavior))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_host_behavior>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_host_behavior))
    );
    fn test_field_acre() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_host_behavior>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).acre) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_host_behavior),
                "::",
                stringify!(acre)
            )
        );
    }
    test_field_acre();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_host_behavior>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_host_behavior),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_arbitration"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ARBITRATION: spdk_nvme_feat = 1;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_power_management"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_POWER_MANAGEMENT: spdk_nvme_feat = 2;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_lba_range_type"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_RANGE_TYPE: spdk_nvme_feat = 3;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_temperature_threshold"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_TEMPERATURE_THRESHOLD: spdk_nvme_feat = 4;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_error_recovery"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ERROR_RECOVERY: spdk_nvme_feat = 5;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_volatile_write_cache"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_VOLATILE_WRITE_CACHE: spdk_nvme_feat = 6;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_number_of_queues"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_NUMBER_OF_QUEUES: spdk_nvme_feat = 7;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_interrupt_coalescing"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_COALESCING: spdk_nvme_feat = 8;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_interrupt_vector_configuration"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_INTERRUPT_VECTOR_CONFIGURATION: spdk_nvme_feat = 9;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_write_atomicity"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_WRITE_ATOMICITY: spdk_nvme_feat = 10;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_async_event_configuration"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ASYNC_EVENT_CONFIGURATION: spdk_nvme_feat = 11;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_autonomous_power_state_transition"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_AUTONOMOUS_POWER_STATE_TRANSITION: spdk_nvme_feat = 12;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_host_mem_buffer"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_MEM_BUFFER: spdk_nvme_feat = 13;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_host_mem_buffer"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_TIMESTAMP: spdk_nvme_feat = 14;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_keep_alive_timer"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_KEEP_ALIVE_TIMER: spdk_nvme_feat = 15;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_host_controlled_thermal_management"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_CONTROLLED_THERMAL_MANAGEMENT: spdk_nvme_feat = 16;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_non_operational_power_state_config"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_NON_OPERATIONAL_POWER_STATE_CONFIG: spdk_nvme_feat = 17;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_non_operational_power_state_config"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_READ_RECOVERY_LEVEL_CONFIG: spdk_nvme_feat = 18;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_non_operational_power_state_config"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_PREDICTABLE_LATENCY_MODE_CONFIG: spdk_nvme_feat = 19;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_non_operational_power_state_config"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_PREDICTABLE_LATENCY_MODE_WINDOW: spdk_nvme_feat = 20;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_non_operational_power_state_config"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_LBA_STATUS_INFORMATION_ATTRIBUTES: spdk_nvme_feat = 21;
#[doc = " data buffer layout  defined by \\ref spdk_nvme_host_behavior"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_BEHAVIOR_SUPPORT: spdk_nvme_feat = 22;
#[doc = " data buffer layout  defined by \\ref spdk_nvme_host_behavior"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_SANITIZE_CONFIG: spdk_nvme_feat = 23;
#[doc = " data buffer layout  defined by \\ref spdk_nvme_host_behavior"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_ENDURANCE_GROUP_EVENT: spdk_nvme_feat = 24;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_software_progress_marker"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_SOFTWARE_PROGRESS_MARKER: spdk_nvme_feat = 128;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_host_identifier"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_IDENTIFIER: spdk_nvme_feat = 129;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_reservation_notification_mask"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_MASK: spdk_nvme_feat = 130;
#[doc = " cdw11 layout defined by \\ref spdk_nvme_feat_reservation_persistence"]
pub const spdk_nvme_feat_SPDK_NVME_FEAT_HOST_RESERVE_PERSIST: spdk_nvme_feat = 131;
pub type spdk_nvme_feat = ::std::os::raw::c_uint;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_READ: spdk_nvme_dsm_attribute = 1;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_INTEGRAL_WRITE: spdk_nvme_dsm_attribute = 2;
pub const spdk_nvme_dsm_attribute_SPDK_NVME_DSM_ATTR_DEALLOCATE: spdk_nvme_dsm_attribute = 4;
#[doc = " Bit set of attributes for DATASET MANAGEMENT commands."]
pub type spdk_nvme_dsm_attribute = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_power_state {
    pub mp: u16,
    pub reserved1: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub enlat: u32,
    pub exlat: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub reserved7: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_power_state() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_power_state>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_power_state))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_power_state>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_power_state))
    );
    fn test_field_mp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_power_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_power_state),
                "::",
                stringify!(mp)
            )
        );
    }
    test_field_mp();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_power_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_power_state),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_enlat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_power_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enlat) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_power_state),
                "::",
                stringify!(enlat)
            )
        );
    }
    test_field_enlat();
    fn test_field_exlat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_power_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exlat) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_power_state),
                "::",
                stringify!(exlat)
            )
        );
    }
    test_field_exlat();
    fn test_field_reserved7() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_power_state>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_power_state),
                "::",
                stringify!(reserved7)
            )
        );
    }
    test_field_reserved7();
}
impl spdk_nvme_power_state {
    #[inline]
    pub fn mps(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mps(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nops(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nops(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mps: u8, nops: u8, reserved2: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mps: u8 = unsafe { ::std::mem::transmute(mps) };
            mps as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nops: u8 = unsafe { ::std::mem::transmute(nops) };
            nops as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved2: u8 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rrt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rrt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rrl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(8usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rrl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(13usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rwt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rwt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved5(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(21usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rwl(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(24usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_rwl(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(29usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_2.set(29usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        rrt: u8,
        reserved3: u8,
        rrl: u8,
        reserved4: u8,
        rwt: u8,
        reserved5: u8,
        rwl: u8,
        reserved6: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let rrt: u8 = unsafe { ::std::mem::transmute(rrt) };
            rrt as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let rrl: u8 = unsafe { ::std::mem::transmute(rrl) };
            rrl as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let reserved4: u8 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rwt: u8 = unsafe { ::std::mem::transmute(rwt) };
            rwt as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let reserved5: u8 = unsafe { ::std::mem::transmute(reserved5) };
            reserved5 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let rwl: u8 = unsafe { ::std::mem::transmute(rwl) };
            rwl as u64
        });
        __bindgen_bitfield_unit.set(29usize, 3u8, {
            let reserved6: u8 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Identify namespace indicated in CDW1.NSID"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS: spdk_nvme_identify_cns = 0;
#[doc = " Identify controller"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR: spdk_nvme_identify_cns = 1;
#[doc = " List active NSIDs greater than CDW1.NSID"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST: spdk_nvme_identify_cns = 2;
#[doc = " List namespace identification descriptors"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ID_DESCRIPTOR_LIST: spdk_nvme_identify_cns =
    3;
#[doc = " Identify namespace indicated in CDW1.NSID, specific to CWD11.CSI"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_IOCS: spdk_nvme_identify_cns = 5;
#[doc = " Identify controller, specific to CWD11.CSI"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_IOCS: spdk_nvme_identify_cns = 6;
#[doc = " List active NSIDs greater than CDW1.NSID, specific to CWD11.CSI"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ACTIVE_NS_LIST_IOCS: spdk_nvme_identify_cns = 7;
#[doc = " List allocated NSIDs greater than CDW1.NSID"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST: spdk_nvme_identify_cns = 16;
#[doc = " Identify namespace if CDW1.NSID is allocated"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED: spdk_nvme_identify_cns = 17;
#[doc = " Get list of controllers starting at CDW10.CNTID that are attached to CDW1.NSID"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ATTACHED_CTRLR_LIST: spdk_nvme_identify_cns =
    18;
#[doc = " Get list of controllers starting at CDW10.CNTID"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_CTRLR_LIST: spdk_nvme_identify_cns = 19;
#[doc = " Get primary controller capabilities structure"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_PRIMARY_CTRLR_CAP: spdk_nvme_identify_cns = 20;
#[doc = " Get secondary controller list"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_SECONDARY_CTRLR_LIST: spdk_nvme_identify_cns =
    21;
#[doc = " List allocated NSIDs greater than CDW1.NSID, specific to CWD11.CSI"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_ALLOCATED_NS_LIST_IOCS: spdk_nvme_identify_cns =
    26;
#[doc = " Identify namespace if CDW1.NSID is allocated, specific to CDWD11.CSI"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_NS_ALLOCATED_IOCS: spdk_nvme_identify_cns = 27;
#[doc = " Identify I/O Command Sets"]
pub const spdk_nvme_identify_cns_SPDK_NVME_IDENTIFY_IOCS: spdk_nvme_identify_cns = 28;
#[doc = " Identify command CNS value"]
pub type spdk_nvme_identify_cns = ::std::os::raw::c_uint;
#[doc = " NVM subsystem uses dynamic controller model"]
pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_DYNAMIC: spdk_nvmf_ctrlr_model = 0;
#[doc = " NVM subsystem uses static controller model"]
pub const spdk_nvmf_ctrlr_model_SPDK_NVMF_CTRLR_MODEL_STATIC: spdk_nvmf_ctrlr_model = 1;
#[doc = " NVMe over Fabrics controller model"]
pub type spdk_nvmf_ctrlr_model = ::std::os::raw::c_uint;
#[doc = " SGLs are not supported"]
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_NOT_SUPPORTED: spdk_nvme_sgls_supported = 0;
#[doc = " SGLs are supported with no alignment or granularity requirement."]
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED: spdk_nvme_sgls_supported = 1;
#[doc = " SGLs are supported with a DWORD alignment and granularity requirement."]
pub const spdk_nvme_sgls_supported_SPDK_NVME_SGLS_SUPPORTED_DWORD_ALIGNED:
    spdk_nvme_sgls_supported = 2;
#[doc = " Identify Controller data sgls.supported values"]
pub type spdk_nvme_sgls_supported = ::std::os::raw::c_uint;
#[doc = " Support for NSID=FFFFFFFFh with Flush is not indicated."]
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_INDICATED:
    spdk_nvme_flush_broadcast = 0;
#[doc = " Flush does not support NSID set to FFFFFFFFh."]
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_NOT_SUPPORTED:
    spdk_nvme_flush_broadcast = 2;
#[doc = " Flush supports NSID set to FFFFFFFFh."]
pub const spdk_nvme_flush_broadcast_SPDK_NVME_FLUSH_BROADCAST_SUPPORTED: spdk_nvme_flush_broadcast =
    3;
#[doc = " Identify Controller data vwc.flush_broadcast values"]
pub type spdk_nvme_flush_broadcast = ::std::os::raw::c_uint;
#[doc = " Identify Controller data NVMe over Fabrics-specific fields"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cdata_nvmf_specific {
    #[doc = " I/O queue command capsule supported size (16-byte units)"]
    pub ioccsz: u32,
    #[doc = " I/O queue response capsule supported size (16-byte units)"]
    pub iorcsz: u32,
    #[doc = " In-capsule data offset (16-byte units)"]
    pub icdoff: u16,
    pub ctrattr: spdk_nvme_cdata_nvmf_specific__bindgen_ty_1,
    #[doc = " Maximum SGL block descriptors (0 = no limit)"]
    pub msdbd: u8,
    pub reserved: [u8; 244usize],
}
#[doc = " Controller attributes"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cdata_nvmf_specific__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cdata_nvmf_specific__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cdata_nvmf_specific__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_cdata_nvmf_specific__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cdata_nvmf_specific__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cdata_nvmf_specific__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_cdata_nvmf_specific__bindgen_ty_1 {
    #[inline]
    pub fn ctrlr_model(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ctrlr_model(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ctrlr_model: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ctrlr_model: u8 = unsafe { ::std::mem::transmute(ctrlr_model) };
            ctrlr_model as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_cdata_nvmf_specific() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cdata_nvmf_specific>(),
        256usize,
        concat!("Size of: ", stringify!(spdk_nvme_cdata_nvmf_specific))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cdata_nvmf_specific>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cdata_nvmf_specific))
    );
    fn test_field_ioccsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ioccsz) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(ioccsz)
            )
        );
    }
    test_field_ioccsz();
    fn test_field_iorcsz() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iorcsz) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(iorcsz)
            )
        );
    }
    test_field_iorcsz();
    fn test_field_icdoff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).icdoff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(icdoff)
            )
        );
    }
    test_field_icdoff();
    fn test_field_ctrattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrattr) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(ctrattr)
            )
        );
    }
    test_field_ctrattr();
    fn test_field_msdbd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msdbd) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(msdbd)
            )
        );
    }
    test_field_msdbd();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_cdata_nvmf_specific>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cdata_nvmf_specific),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[doc = " Identify Controller data SGL support"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cdata_sgls {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cdata_sgls() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cdata_sgls>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cdata_sgls))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cdata_sgls>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cdata_sgls))
    );
}
impl spdk_nvme_cdata_sgls {
    #[inline]
    pub fn supported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn keyed_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_keyed_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_bucket_descriptor(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bit_bucket_descriptor(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_pointer(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_pointer(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oversized_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oversized_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn metadata_address(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_metadata_address(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sgl_offset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sgl_offset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport_sgl(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport_sgl(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        supported: u32,
        keyed_sgl: u32,
        reserved1: u32,
        bit_bucket_descriptor: u32,
        metadata_pointer: u32,
        oversized_sgl: u32,
        metadata_address: u32,
        sgl_offset: u32,
        transport_sgl: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let supported: u32 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let keyed_sgl: u32 = unsafe { ::std::mem::transmute(keyed_sgl) };
            keyed_sgl as u64
        });
        __bindgen_bitfield_unit.set(3usize, 13u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let bit_bucket_descriptor: u32 =
                unsafe { ::std::mem::transmute(bit_bucket_descriptor) };
            bit_bucket_descriptor as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let metadata_pointer: u32 = unsafe { ::std::mem::transmute(metadata_pointer) };
            metadata_pointer as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oversized_sgl: u32 = unsafe { ::std::mem::transmute(oversized_sgl) };
            oversized_sgl as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let metadata_address: u32 = unsafe { ::std::mem::transmute(metadata_address) };
            metadata_address as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let sgl_offset: u32 = unsafe { ::std::mem::transmute(sgl_offset) };
            sgl_offset as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let transport_sgl: u32 = unsafe { ::std::mem::transmute(transport_sgl) };
            transport_sgl as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " controller multi-path I/O and namespace sharing capabilities"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn multi_port(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multi_port(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn multi_host(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_multi_host(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sr_iov(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sr_iov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_reporting(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        multi_port: u8,
        multi_host: u8,
        sr_iov: u8,
        ana_reporting: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let multi_port: u8 = unsafe { ::std::mem::transmute(multi_port) };
            multi_port as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let multi_host: u8 = unsafe { ::std::mem::transmute(multi_host) };
            multi_host as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sr_iov: u8 = unsafe { ::std::mem::transmute(sr_iov) };
            sr_iov as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ana_reporting: u8 = unsafe { ::std::mem::transmute(ana_reporting) };
            ana_reporting as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " optional asynchronous events supported"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_2 {
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_attribute_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ns_attribute_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fw_activation_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fw_activation_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_change_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ana_change_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn discovery_log_change_notices(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_discovery_log_change_notices(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved1: u32,
        ns_attribute_notices: u32,
        fw_activation_notices: u32,
        reserved2: u32,
        ana_change_notices: u32,
        reserved3: u32,
        discovery_log_change_notices: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ns_attribute_notices: u32 = unsafe { ::std::mem::transmute(ns_attribute_notices) };
            ns_attribute_notices as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let fw_activation_notices: u32 =
                unsafe { ::std::mem::transmute(fw_activation_notices) };
            fw_activation_notices as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ana_change_notices: u32 = unsafe { ::std::mem::transmute(ana_change_notices) };
            ana_change_notices as u64
        });
        __bindgen_bitfield_unit.set(12usize, 19u8, {
            let reserved3: u32 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let discovery_log_change_notices: u32 =
                unsafe { ::std::mem::transmute(discovery_log_change_notices) };
            discovery_log_change_notices as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " controller attributes"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_3)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_3 {
    #[inline]
    pub fn host_id_exhid_supported(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_host_id_exhid_supported(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_operational_power_state_permissive_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_non_operational_power_state_permissive_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        host_id_exhid_supported: u32,
        non_operational_power_state_permissive_mode: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let host_id_exhid_supported: u32 =
                unsafe { ::std::mem::transmute(host_id_exhid_supported) };
            host_id_exhid_supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let non_operational_power_state_permissive_mode: u32 =
                unsafe { ::std::mem::transmute(non_operational_power_state_permissive_mode) };
            non_operational_power_state_permissive_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " optional admin command support"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_4)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_4 {
    #[inline]
    pub fn security(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_security(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn firmware(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_firmware(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_manage(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ns_manage(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn device_self_test(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_device_self_test(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn directives(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_directives(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nvme_mi(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_nvme_mi(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn virtualization_management(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_virtualization_management(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn doorbell_buffer_config(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_doorbell_buffer_config(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn get_lba_status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_get_lba_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oacs_rsvd(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_oacs_rsvd(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        security: u16,
        format: u16,
        firmware: u16,
        ns_manage: u16,
        device_self_test: u16,
        directives: u16,
        nvme_mi: u16,
        virtualization_management: u16,
        doorbell_buffer_config: u16,
        get_lba_status: u16,
        oacs_rsvd: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let security: u16 = unsafe { ::std::mem::transmute(security) };
            security as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let format: u16 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let firmware: u16 = unsafe { ::std::mem::transmute(firmware) };
            firmware as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ns_manage: u16 = unsafe { ::std::mem::transmute(ns_manage) };
            ns_manage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let device_self_test: u16 = unsafe { ::std::mem::transmute(device_self_test) };
            device_self_test as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let directives: u16 = unsafe { ::std::mem::transmute(directives) };
            directives as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let nvme_mi: u16 = unsafe { ::std::mem::transmute(nvme_mi) };
            nvme_mi as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let virtualization_management: u16 =
                unsafe { ::std::mem::transmute(virtualization_management) };
            virtualization_management as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let doorbell_buffer_config: u16 =
                unsafe { ::std::mem::transmute(doorbell_buffer_config) };
            doorbell_buffer_config as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let get_lba_status: u16 = unsafe { ::std::mem::transmute(get_lba_status) };
            get_lba_status as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let oacs_rsvd: u16 = unsafe { ::std::mem::transmute(oacs_rsvd) };
            oacs_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " firmware updates"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_5>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_5)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_5 {
    #[inline]
    pub fn slot1_ro(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot1_ro(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_slots(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_num_slots(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn activation_without_reset(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_activation_without_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frmw_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_frmw_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot1_ro: u8,
        num_slots: u8,
        activation_without_reset: u8,
        frmw_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slot1_ro: u8 = unsafe { ::std::mem::transmute(slot1_ro) };
            slot1_ro as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let num_slots: u8 = unsafe { ::std::mem::transmute(num_slots) };
            num_slots as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let activation_without_reset: u8 =
                unsafe { ::std::mem::transmute(activation_without_reset) };
            activation_without_reset as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let frmw_rsvd: u8 = unsafe { ::std::mem::transmute(frmw_rsvd) };
            frmw_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " log page attributes"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_6>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_6)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_6 {
    #[inline]
    pub fn ns_smart(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ns_smart(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn celp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_celp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn edlp(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_edlp(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn telemetry(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_telemetry(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lpa_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_lpa_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ns_smart: u8,
        celp: u8,
        edlp: u8,
        telemetry: u8,
        lpa_rsvd: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ns_smart: u8 = unsafe { ::std::mem::transmute(ns_smart) };
            ns_smart as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let celp: u8 = unsafe { ::std::mem::transmute(celp) };
            celp as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let edlp: u8 = unsafe { ::std::mem::transmute(edlp) };
            edlp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let telemetry: u8 = unsafe { ::std::mem::transmute(telemetry) };
            telemetry as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let lpa_rsvd: u8 = unsafe { ::std::mem::transmute(lpa_rsvd) };
            lpa_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " admin vendor specific command configuration"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_7>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_7)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_7 {
    #[inline]
    pub fn spec_format(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_spec_format(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn avscc_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_avscc_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(spec_format: u8, avscc_rsvd: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let spec_format: u8 = unsafe { ::std::mem::transmute(spec_format) };
            spec_format as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let avscc_rsvd: u8 = unsafe { ::std::mem::transmute(avscc_rsvd) };
            avscc_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " autonomous power state transition attributes"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_8>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_8)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_8 {
    #[inline]
    pub fn supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn apsta_rsvd(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_apsta_rsvd(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(supported: u8, apsta_rsvd: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u8 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let apsta_rsvd: u8 = unsafe { ::std::mem::transmute(apsta_rsvd) };
            apsta_rsvd as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " replay protected memory block support"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved2: u8,
    pub total_size: u8,
    pub access_size: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_9>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9)
        )
    );
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_9>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_total_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_9>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_size) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9),
                "::",
                stringify!(total_size)
            )
        );
    }
    test_field_total_size();
    fn test_field_access_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_9>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).access_size) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_9),
                "::",
                stringify!(access_size)
            )
        );
    }
    test_field_access_size();
}
impl spdk_nvme_ctrlr_data__bindgen_ty_9 {
    #[inline]
    pub fn num_rpmb_units(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_num_rpmb_units(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn auth_method(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_auth_method(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        num_rpmb_units: u8,
        auth_method: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let num_rpmb_units: u8 = unsafe { ::std::mem::transmute(num_rpmb_units) };
            num_rpmb_units as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let auth_method: u8 = unsafe { ::std::mem::transmute(auth_method) };
            auth_method as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " device self-test options"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_10 {
    pub raw: u8,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_10__bindgen_ty_1 {
    #[inline]
    pub fn one_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(one_only: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let one_only: u8 = unsafe { ::std::mem::transmute(one_only) };
            one_only as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_10>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_10>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_10),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Host controlled thermal management attributes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_11 {
    pub raw: u16,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_11__bindgen_ty_1 {
    #[inline]
    pub fn supported(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_supported(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(supported: u16, reserved: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let supported: u16 = unsafe { ::std::mem::transmute(supported) };
            supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_11>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_11>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_11),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Sanitize capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ctrlr_data__bindgen_ty_12 {
    pub raw: u32,
    pub bits: spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_12__bindgen_ty_1 {
    #[inline]
    pub fn crypto_erase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_crypto_erase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn block_erase(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_block_erase(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overwrite(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_overwrite(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        crypto_erase: u32,
        block_erase: u32,
        overwrite: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let crypto_erase: u32 = unsafe { ::std::mem::transmute(crypto_erase) };
            crypto_erase as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let block_erase: u32 = unsafe { ::std::mem::transmute(block_erase) };
            block_erase as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overwrite: u32 = unsafe { ::std::mem::transmute(overwrite) };
            overwrite as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_12>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_data__bindgen_ty_12>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_data__bindgen_ty_12),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_13 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_13))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_13>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_13)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_13 {
    #[inline]
    pub fn ana_optimized_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_optimized_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_non_optimized_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_non_optimized_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_inaccessible_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_inaccessible_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_persistent_loss_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_persistent_loss_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ana_change_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ana_change_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_change_anagrpid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_change_anagrpid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_zero_anagrpid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_zero_anagrpid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ana_optimized_state: u8,
        ana_non_optimized_state: u8,
        ana_inaccessible_state: u8,
        ana_persistent_loss_state: u8,
        ana_change_state: u8,
        reserved: u8,
        no_change_anagrpid: u8,
        non_zero_anagrpid: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ana_optimized_state: u8 = unsafe { ::std::mem::transmute(ana_optimized_state) };
            ana_optimized_state as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ana_non_optimized_state: u8 =
                unsafe { ::std::mem::transmute(ana_non_optimized_state) };
            ana_non_optimized_state as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ana_inaccessible_state: u8 =
                unsafe { ::std::mem::transmute(ana_inaccessible_state) };
            ana_inaccessible_state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ana_persistent_loss_state: u8 =
                unsafe { ::std::mem::transmute(ana_persistent_loss_state) };
            ana_persistent_loss_state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ana_change_state: u8 = unsafe { ::std::mem::transmute(ana_change_state) };
            ana_change_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let no_change_anagrpid: u8 = unsafe { ::std::mem::transmute(no_change_anagrpid) };
            no_change_anagrpid as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let non_zero_anagrpid: u8 = unsafe { ::std::mem::transmute(non_zero_anagrpid) };
            non_zero_anagrpid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " submission queue entry size"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_14 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_14))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_14>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_14)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_14 {
    #[inline]
    pub fn min(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let min: u8 = unsafe { ::std::mem::transmute(min) };
            min as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let max: u8 = unsafe { ::std::mem::transmute(max) };
            max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " completion queue entry size"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_15 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_15))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_15>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_15)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_15 {
    #[inline]
    pub fn min(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_min(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn max(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_max(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(min: u8, max: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let min: u8 = unsafe { ::std::mem::transmute(min) };
            min as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let max: u8 = unsafe { ::std::mem::transmute(max) };
            max as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " optional nvm command support"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_16 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_16))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_16>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_16)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_16 {
    #[inline]
    pub fn compare(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_compare(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_unc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_write_unc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsm(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dsm(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_zeroes(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_write_zeroes(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_features_save(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_set_features_save(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reservations(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reservations(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timestamp(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_timestamp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare: u16,
        write_unc: u16,
        dsm: u16,
        write_zeroes: u16,
        set_features_save: u16,
        reservations: u16,
        timestamp: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compare: u16 = unsafe { ::std::mem::transmute(compare) };
            compare as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write_unc: u16 = unsafe { ::std::mem::transmute(write_unc) };
            write_unc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dsm: u16 = unsafe { ::std::mem::transmute(dsm) };
            dsm as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_zeroes: u16 = unsafe { ::std::mem::transmute(write_zeroes) };
            write_zeroes as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let set_features_save: u16 = unsafe { ::std::mem::transmute(set_features_save) };
            set_features_save as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let reservations: u16 = unsafe { ::std::mem::transmute(reservations) };
            reservations as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let timestamp: u16 = unsafe { ::std::mem::transmute(timestamp) };
            timestamp as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " fused operation support"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_17 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_17))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_17>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_17)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_17 {
    #[inline]
    pub fn compare_and_write(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_compare_and_write(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compare_and_write: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compare_and_write: u16 = unsafe { ::std::mem::transmute(compare_and_write) };
            compare_and_write as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " format nvm attributes"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_18 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_18))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_18>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_18)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_18 {
    #[inline]
    pub fn format_all_ns(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_format_all_ns(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn erase_all_ns(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_erase_all_ns(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn crypto_erase_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_crypto_erase_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        format_all_ns: u8,
        erase_all_ns: u8,
        crypto_erase_supported: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let format_all_ns: u8 = unsafe { ::std::mem::transmute(format_all_ns) };
            format_all_ns as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let erase_all_ns: u8 = unsafe { ::std::mem::transmute(erase_all_ns) };
            erase_all_ns as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let crypto_erase_supported: u8 =
                unsafe { ::std::mem::transmute(crypto_erase_supported) };
            crypto_erase_supported as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " volatile write cache"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_data__bindgen_ty_19 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_data__bindgen_ty_19() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_data__bindgen_ty_19>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ctrlr_data__bindgen_ty_19)
        )
    );
}
impl spdk_nvme_ctrlr_data__bindgen_ty_19 {
    #[inline]
    pub fn present(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_present(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush_broadcast(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_flush_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        present: u8,
        flush_broadcast: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let present: u8 = unsafe { ::std::mem::transmute(present) };
            present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let flush_broadcast: u8 = unsafe { ::std::mem::transmute(flush_broadcast) };
            flush_broadcast as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_ctrlr_data {
    #[doc = " zone append size limit"]
    pub zasl: u8,
    pub reserved1: [u8; 4095usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_ctrlr_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_ctrlr_data>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_ctrlr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_ctrlr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_zns_ctrlr_data))
    );
    fn test_field_zasl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zasl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ctrlr_data),
                "::",
                stringify!(zasl)
            )
        );
    }
    test_field_zasl();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ctrlr_data),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_primary_ctrl_capabilities {
    #[doc = "  controller id"]
    pub cntlid: u16,
    #[doc = "  port identifier"]
    pub portid: u16,
    pub crt: spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1,
    pub reserved: [u8; 27usize],
    #[doc = " total number of VQ flexible resources"]
    pub vqfrt: u32,
    #[doc = " total number of VQ flexible resources assigned to secondary controllers"]
    pub vqrfa: u32,
    #[doc = " total number of VQ flexible resources allocated to primary controller"]
    pub vqrfap: u16,
    #[doc = " total number of VQ Private resources for the primary controller"]
    pub vqprt: u16,
    #[doc = " max number of VQ flexible Resources that may be assigned to a secondary controller"]
    pub vqfrsm: u16,
    #[doc = " preferred granularity of assigning and removing VQ Flexible Resources"]
    pub vqgran: u16,
    pub reserved1: [u8; 16usize],
    #[doc = " total number of VI flexible resources for the primary and its secondary controllers"]
    pub vifrt: u32,
    #[doc = " total number of VI flexible resources assigned to the secondary controllers"]
    pub virfa: u32,
    #[doc = " total number of VI flexible resources currently allocated to the primary controller"]
    pub virfap: u16,
    #[doc = " total number of VI private resources for the primary controller"]
    pub viprt: u16,
    #[doc = " max number of VI flexible resources that may be assigned to a secondary controller"]
    pub vifrsm: u16,
    #[doc = " preferred granularity of assigning and removing VI flexible resources"]
    pub vigran: u16,
    pub reserved2: [u8; 4016usize],
}
#[doc = "  controller resource types"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_primary_ctrl_capabilities__bindgen_ty_1 {
    #[inline]
    pub fn vq_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vq_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vi_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vi_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vq_supported: u8,
        vi_supported: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vq_supported: u8 = unsafe { ::std::mem::transmute(vq_supported) };
            vq_supported as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let vi_supported: u8 = unsafe { ::std::mem::transmute(vi_supported) };
            vi_supported as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_primary_ctrl_capabilities() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_primary_ctrl_capabilities>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_primary_ctrl_capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_primary_ctrl_capabilities>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_primary_ctrl_capabilities)
        )
    );
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_portid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).portid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(portid)
            )
        );
    }
    test_field_portid();
    fn test_field_crt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crt) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(crt)
            )
        );
    }
    test_field_crt();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_vqfrt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqfrt) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqfrt)
            )
        );
    }
    test_field_vqfrt();
    fn test_field_vqrfa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqrfa) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqrfa)
            )
        );
    }
    test_field_vqrfa();
    fn test_field_vqrfap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqrfap) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqrfap)
            )
        );
    }
    test_field_vqrfap();
    fn test_field_vqprt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqprt) as usize - ptr as usize
            },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqprt)
            )
        );
    }
    test_field_vqprt();
    fn test_field_vqfrsm() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqfrsm) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqfrsm)
            )
        );
    }
    test_field_vqfrsm();
    fn test_field_vqgran() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vqgran) as usize - ptr as usize
            },
            46usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vqgran)
            )
        );
    }
    test_field_vqgran();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_vifrt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vifrt) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vifrt)
            )
        );
    }
    test_field_vifrt();
    fn test_field_virfa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).virfa) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(virfa)
            )
        );
    }
    test_field_virfa();
    fn test_field_virfap() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).virfap) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(virfap)
            )
        );
    }
    test_field_virfap();
    fn test_field_viprt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).viprt) as usize - ptr as usize
            },
            74usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(viprt)
            )
        );
    }
    test_field_viprt();
    fn test_field_vifrsm() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vifrsm) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vifrsm)
            )
        );
    }
    test_field_vifrsm();
    fn test_field_vigran() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vigran) as usize - ptr as usize
            },
            78usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(vigran)
            )
        );
    }
    test_field_vigran();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_primary_ctrl_capabilities>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_primary_ctrl_capabilities),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_entry {
    #[doc = " controller identifier of the secondary controller"]
    pub scid: u16,
    #[doc = " controller identifier of the associated primary controller"]
    pub pcid: u16,
    pub scs: spdk_nvme_secondary_ctrl_entry__bindgen_ty_1,
    pub reserved: [u8; 3usize],
    #[doc = " VF number if the secondary controller is an SR-IOV VF"]
    pub vfn: u16,
    #[doc = " number of VQ flexible resources assigned to the indicated secondary controller"]
    pub nvq: u16,
    #[doc = " number of VI flexible resources assigned to the indicated secondary controller"]
    pub nvi: u16,
    pub reserved1: [u8; 18usize],
}
#[doc = " indicates the state of the secondary controller"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_secondary_ctrl_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_secondary_ctrl_entry__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_secondary_ctrl_entry__bindgen_ty_1 {
    #[inline]
    pub fn is_online(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_online(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_online: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_online: u8 = unsafe { ::std::mem::transmute(is_online) };
            is_online as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_entry>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_secondary_ctrl_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_entry>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_secondary_ctrl_entry))
    );
    fn test_field_scid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(scid)
            )
        );
    }
    test_field_scid();
    fn test_field_pcid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pcid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(pcid)
            )
        );
    }
    test_field_pcid();
    fn test_field_scs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scs) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(scs)
            )
        );
    }
    test_field_scs();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_vfn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vfn) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(vfn)
            )
        );
    }
    test_field_vfn();
    fn test_field_nvq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvq) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(nvq)
            )
        );
    }
    test_field_nvq();
    fn test_field_nvi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvi) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(nvi)
            )
        );
    }
    test_field_nvi();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_entry),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_secondary_ctrl_list {
    #[doc = " number of Secondary controller entries in the list"]
    pub number: u8,
    pub reserved: [u8; 31usize],
    pub entries: [spdk_nvme_secondary_ctrl_entry; 127usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_secondary_ctrl_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_secondary_ctrl_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_secondary_ctrl_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_secondary_ctrl_list>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_secondary_ctrl_list))
    );
    fn test_field_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_list),
                "::",
                stringify!(number)
            )
        );
    }
    test_field_number();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_list),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_secondary_ctrl_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_secondary_ctrl_list),
                "::",
                stringify!(entries)
            )
        );
    }
    test_field_entries();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_ns_data {
    #[doc = " namespace size"]
    pub nsze: u64,
    #[doc = " namespace capacity"]
    pub ncap: u64,
    #[doc = " namespace utilization"]
    pub nuse: u64,
    pub nsfeat: spdk_nvme_ns_data__bindgen_ty_1,
    #[doc = " number of lba formats"]
    pub nlbaf: u8,
    pub flbas: spdk_nvme_ns_data__bindgen_ty_2,
    pub mc: spdk_nvme_ns_data__bindgen_ty_3,
    pub dpc: spdk_nvme_ns_data__bindgen_ty_4,
    pub dps: spdk_nvme_ns_data__bindgen_ty_5,
    pub nmic: spdk_nvme_ns_data__bindgen_ty_6,
    pub nsrescap: spdk_nvme_ns_data__bindgen_ty_7,
    pub fpi: spdk_nvme_ns_data__bindgen_ty_8,
    pub dlfeat: spdk_nvme_ns_data__bindgen_ty_9,
    #[doc = " namespace atomic write unit normal"]
    pub nawun: u16,
    #[doc = " namespace atomic write unit power fail"]
    pub nawupf: u16,
    #[doc = " namespace atomic compare & write unit"]
    pub nacwu: u16,
    #[doc = " namespace atomic boundary size normal"]
    pub nabsn: u16,
    #[doc = " namespace atomic boundary offset"]
    pub nabo: u16,
    #[doc = " namespace atomic boundary size power fail"]
    pub nabspf: u16,
    #[doc = " namespace optimal I/O boundary in logical blocks"]
    pub noiob: u16,
    #[doc = " NVM capacity"]
    pub nvmcap: [u64; 2usize],
    #[doc = " Namespace Preferred Write Granularity"]
    pub npwg: u16,
    #[doc = " Namespace Preferred Write Alignment"]
    pub npwa: u16,
    #[doc = " Namespace Preferred Deallocate Granularity"]
    pub npdg: u16,
    #[doc = " Namespace Preferred Deallocate Alignment"]
    pub npda: u16,
    #[doc = " Namespace Optimal Write Size"]
    pub nows: u16,
    pub reserved64: [u8; 18usize],
    #[doc = " ANA group identifier"]
    pub anagrpid: u32,
    pub reserved96: [u8; 8usize],
    #[doc = " namespace globally unique identifier"]
    pub nguid: [u8; 16usize],
    #[doc = " IEEE extended unique identifier"]
    pub eui64: u64,
    pub lbaf: [spdk_nvme_ns_data__bindgen_ty_10; 16usize],
    pub reserved6: [u8; 192usize],
    pub vendor_specific: [u8; 3712usize],
}
#[doc = " namespace features"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_1))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_1 {
    #[inline]
    pub fn thin_prov(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_thin_prov(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ns_atomic_write_unit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ns_atomic_write_unit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dealloc_or_unwritten_error(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dealloc_or_unwritten_error(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn guid_never_reused(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_guid_never_reused(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn optperf(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_optperf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        thin_prov: u8,
        ns_atomic_write_unit: u8,
        dealloc_or_unwritten_error: u8,
        guid_never_reused: u8,
        optperf: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let thin_prov: u8 = unsafe { ::std::mem::transmute(thin_prov) };
            thin_prov as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ns_atomic_write_unit: u8 = unsafe { ::std::mem::transmute(ns_atomic_write_unit) };
            ns_atomic_write_unit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dealloc_or_unwritten_error: u8 =
                unsafe { ::std::mem::transmute(dealloc_or_unwritten_error) };
            dealloc_or_unwritten_error as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let guid_never_reused: u8 = unsafe { ::std::mem::transmute(guid_never_reused) };
            guid_never_reused as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let optperf: u8 = unsafe { ::std::mem::transmute(optperf) };
            optperf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " formatted lba size"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_2))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_2 {
    #[inline]
    pub fn format(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_format(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        format: u8,
        extended: u8,
        reserved2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let format: u8 = unsafe { ::std::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let extended: u8 = unsafe { ::std::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved2: u8 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " metadata capabilities"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_3>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_3>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_3))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_3 {
    #[inline]
    pub fn extended(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pointer(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pointer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        extended: u8,
        pointer: u8,
        reserved3: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let extended: u8 = unsafe { ::std::mem::transmute(extended) };
            extended as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pointer: u8 = unsafe { ::std::mem::transmute(pointer) };
            pointer as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " end-to-end data protection capabilities"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_4>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_4>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_4))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_4 {
    #[inline]
    pub fn pit1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pit2(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pit3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pit3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn md_end(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pit1: u8,
        pit2: u8,
        pit3: u8,
        md_start: u8,
        md_end: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pit1: u8 = unsafe { ::std::mem::transmute(pit1) };
            pit1 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let pit2: u8 = unsafe { ::std::mem::transmute(pit2) };
            pit2 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let pit3: u8 = unsafe { ::std::mem::transmute(pit3) };
            pit3 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let md_start: u8 = unsafe { ::std::mem::transmute(md_start) };
            md_start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let md_end: u8 = unsafe { ::std::mem::transmute(md_end) };
            md_end as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " end-to-end data protection type settings"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_5>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_5>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_5))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_5 {
    #[inline]
    pub fn pit(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn md_start(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_md_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved4(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pit: u8,
        md_start: u8,
        reserved4: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pit: u8 = unsafe { ::std::mem::transmute(pit) };
            pit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let md_start: u8 = unsafe { ::std::mem::transmute(md_start) };
            md_start as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved4: u8 = unsafe { ::std::mem::transmute(reserved4) };
            reserved4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " namespace multi-path I/O and namespace sharing capabilities"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_6>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_6>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_6))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_6 {
    #[inline]
    pub fn can_share(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_share(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(can_share: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_share: u8 = unsafe { ::std::mem::transmute(can_share) };
            can_share as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " reservation capabilities"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ns_data__bindgen_ty_7 {
    pub rescap: spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1,
    pub raw: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_7__bindgen_ty_1 {
    #[inline]
    pub fn persist(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_persist(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive_reg_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_reg_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access_reg_only(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_reg_only(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_exclusive_all_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_exclusive_all_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn exclusive_access_all_reg(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exclusive_access_all_reg(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_existing_key(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_existing_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        persist: u8,
        write_exclusive: u8,
        exclusive_access: u8,
        write_exclusive_reg_only: u8,
        exclusive_access_reg_only: u8,
        write_exclusive_all_reg: u8,
        exclusive_access_all_reg: u8,
        ignore_existing_key: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let persist: u8 = unsafe { ::std::mem::transmute(persist) };
            persist as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let write_exclusive: u8 = unsafe { ::std::mem::transmute(write_exclusive) };
            write_exclusive as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let exclusive_access: u8 = unsafe { ::std::mem::transmute(exclusive_access) };
            exclusive_access as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_exclusive_reg_only: u8 =
                unsafe { ::std::mem::transmute(write_exclusive_reg_only) };
            write_exclusive_reg_only as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let exclusive_access_reg_only: u8 =
                unsafe { ::std::mem::transmute(exclusive_access_reg_only) };
            exclusive_access_reg_only as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let write_exclusive_all_reg: u8 =
                unsafe { ::std::mem::transmute(write_exclusive_all_reg) };
            write_exclusive_all_reg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let exclusive_access_all_reg: u8 =
                unsafe { ::std::mem::transmute(exclusive_access_all_reg) };
            exclusive_access_all_reg as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ignore_existing_key: u8 = unsafe { ::std::mem::transmute(ignore_existing_key) };
            ignore_existing_key as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_7>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_7>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_7))
    );
    fn test_field_rescap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rescap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data__bindgen_ty_7),
                "::",
                stringify!(rescap)
            )
        );
    }
    test_field_rescap();
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data__bindgen_ty_7>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data__bindgen_ty_7),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
}
#[doc = " format progress indicator"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_8>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_8>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_8))
    );
}
impl spdk_nvme_ns_data__bindgen_ty_8 {
    #[inline]
    pub fn percentage_remaining(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_percentage_remaining(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn fpi_supported(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fpi_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        percentage_remaining: u8,
        fpi_supported: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let percentage_remaining: u8 = unsafe { ::std::mem::transmute(percentage_remaining) };
            percentage_remaining as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let fpi_supported: u8 = unsafe { ::std::mem::transmute(fpi_supported) };
            fpi_supported as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " deallocate logical features"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_ns_data__bindgen_ty_9 {
    pub raw: u8,
    pub bits: spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_9__bindgen_ty_1 {
    #[inline]
    pub fn read_value(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_read_value(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn write_zero_deallocate(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_zero_deallocate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn guard_value(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_guard_value(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_value: u8,
        write_zero_deallocate: u8,
        guard_value: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let read_value: u8 = unsafe { ::std::mem::transmute(read_value) };
            read_value as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let write_zero_deallocate: u8 = unsafe { ::std::mem::transmute(write_zero_deallocate) };
            write_zero_deallocate as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let guard_value: u8 = unsafe { ::std::mem::transmute(guard_value) };
            guard_value as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_9>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_9>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data__bindgen_ty_9))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data__bindgen_ty_9>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data__bindgen_ty_9),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data__bindgen_ty_9>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data__bindgen_ty_9),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " lba format support"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_data__bindgen_ty_10 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data__bindgen_ty_10>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data__bindgen_ty_10))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_data__bindgen_ty_10)
        )
    );
}
impl spdk_nvme_ns_data__bindgen_ty_10 {
    #[inline]
    pub fn ms(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn lbads(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lbads(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_rp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved6(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_reserved6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ms: u32,
        lbads: u32,
        rp: u32,
        reserved6: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ms: u32 = unsafe { ::std::mem::transmute(ms) };
            ms as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let lbads: u32 = unsafe { ::std::mem::transmute(lbads) };
            lbads as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let rp: u32 = unsafe { ::std::mem::transmute(rp) };
            rp as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let reserved6: u32 = unsafe { ::std::mem::transmute(reserved6) };
            reserved6 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_data>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_data))
    );
    fn test_field_nsze() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsze) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nsze)
            )
        );
    }
    test_field_nsze();
    fn test_field_ncap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ncap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(ncap)
            )
        );
    }
    test_field_ncap();
    fn test_field_nuse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nuse) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nuse)
            )
        );
    }
    test_field_nuse();
    fn test_field_nsfeat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsfeat) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nsfeat)
            )
        );
    }
    test_field_nsfeat();
    fn test_field_nlbaf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nlbaf) as usize - ptr as usize
            },
            25usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nlbaf)
            )
        );
    }
    test_field_nlbaf();
    fn test_field_flbas() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flbas) as usize - ptr as usize
            },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(flbas)
            )
        );
    }
    test_field_flbas();
    fn test_field_mc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mc) as usize - ptr as usize
            },
            27usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(mc)
            )
        );
    }
    test_field_mc();
    fn test_field_dpc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dpc) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(dpc)
            )
        );
    }
    test_field_dpc();
    fn test_field_dps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dps) as usize - ptr as usize
            },
            29usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(dps)
            )
        );
    }
    test_field_dps();
    fn test_field_nmic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nmic) as usize - ptr as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nmic)
            )
        );
    }
    test_field_nmic();
    fn test_field_nsrescap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsrescap) as usize - ptr as usize
            },
            31usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nsrescap)
            )
        );
    }
    test_field_nsrescap();
    fn test_field_fpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fpi) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(fpi)
            )
        );
    }
    test_field_fpi();
    fn test_field_dlfeat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dlfeat) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(dlfeat)
            )
        );
    }
    test_field_dlfeat();
    fn test_field_nawun() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nawun) as usize - ptr as usize
            },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nawun)
            )
        );
    }
    test_field_nawun();
    fn test_field_nawupf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nawupf) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nawupf)
            )
        );
    }
    test_field_nawupf();
    fn test_field_nacwu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nacwu) as usize - ptr as usize
            },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nacwu)
            )
        );
    }
    test_field_nacwu();
    fn test_field_nabsn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nabsn) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nabsn)
            )
        );
    }
    test_field_nabsn();
    fn test_field_nabo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nabo) as usize - ptr as usize
            },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nabo)
            )
        );
    }
    test_field_nabo();
    fn test_field_nabspf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nabspf) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nabspf)
            )
        );
    }
    test_field_nabspf();
    fn test_field_noiob() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).noiob) as usize - ptr as usize
            },
            46usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(noiob)
            )
        );
    }
    test_field_noiob();
    fn test_field_nvmcap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nvmcap) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nvmcap)
            )
        );
    }
    test_field_nvmcap();
    fn test_field_npwg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npwg) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(npwg)
            )
        );
    }
    test_field_npwg();
    fn test_field_npwa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npwa) as usize - ptr as usize
            },
            66usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(npwa)
            )
        );
    }
    test_field_npwa();
    fn test_field_npdg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npdg) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(npdg)
            )
        );
    }
    test_field_npdg();
    fn test_field_npda() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).npda) as usize - ptr as usize
            },
            70usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(npda)
            )
        );
    }
    test_field_npda();
    fn test_field_nows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nows) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nows)
            )
        );
    }
    test_field_nows();
    fn test_field_reserved64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved64) as usize - ptr as usize
            },
            74usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(reserved64)
            )
        );
    }
    test_field_reserved64();
    fn test_field_anagrpid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).anagrpid) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(anagrpid)
            )
        );
    }
    test_field_anagrpid();
    fn test_field_reserved96() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved96) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(reserved96)
            )
        );
    }
    test_field_reserved96();
    fn test_field_nguid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nguid) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(nguid)
            )
        );
    }
    test_field_nguid();
    fn test_field_eui64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eui64) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(eui64)
            )
        );
    }
    test_field_eui64();
    fn test_field_lbaf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lbaf) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(lbaf)
            )
        );
    }
    test_field_lbaf();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
    fn test_field_vendor_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendor_specific) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_data),
                "::",
                stringify!(vendor_specific)
            )
        );
    }
    test_field_vendor_specific();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_ns_data {
    pub zoc: spdk_nvme_zns_ns_data__bindgen_ty_1,
    pub ozcs: spdk_nvme_zns_ns_data__bindgen_ty_2,
    #[doc = " maximum active resources"]
    pub mar: u32,
    #[doc = " maximum open resources"]
    pub mor: u32,
    #[doc = " reset recommended limit"]
    pub rrl: u32,
    #[doc = " finish recommended limit"]
    pub frl: u32,
    pub reserved20: [u8; 2796usize],
    pub lbafe: [spdk_nvme_zns_ns_data__bindgen_ty_3; 16usize],
    pub reserved3072: [u8; 768usize],
    pub vendor_specific: [u8; 256usize],
}
#[doc = " zone operation characteristics"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_ns_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_ns_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_ns_data__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_ns_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_ns_data__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_zns_ns_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_zns_ns_data__bindgen_ty_1 {
    #[inline]
    pub fn variable_zone_capacity(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_variable_zone_capacity(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zone_active_excursions(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_zone_active_excursions(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        variable_zone_capacity: u16,
        zone_active_excursions: u16,
        reserved0: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let variable_zone_capacity: u16 =
                unsafe { ::std::mem::transmute(variable_zone_capacity) };
            variable_zone_capacity as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let zone_active_excursions: u16 =
                unsafe { ::std::mem::transmute(zone_active_excursions) };
            zone_active_excursions as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let reserved0: u16 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " optional zoned command support"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_ns_data__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_ns_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_ns_data__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_ns_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_ns_data__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_zns_ns_data__bindgen_ty_2)
        )
    );
}
impl spdk_nvme_zns_ns_data__bindgen_ty_2 {
    #[inline]
    pub fn read_across_zone_boundaries(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_read_across_zone_boundaries(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_across_zone_boundaries: u16,
        reserved0: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_across_zone_boundaries: u16 =
                unsafe { ::std::mem::transmute(read_across_zone_boundaries) };
            read_across_zone_boundaries as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let reserved0: u16 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " zns lba format extension support"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_ns_data__bindgen_ty_3 {
    #[doc = " zone size"]
    pub zsze: u64,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_ns_data__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_ns_data__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_ns_data__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_ns_data__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_zns_ns_data__bindgen_ty_3)
        )
    );
    fn test_field_zsze() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zsze) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data__bindgen_ty_3),
                "::",
                stringify!(zsze)
            )
        );
    }
    test_field_zsze();
}
impl spdk_nvme_zns_ns_data__bindgen_ty_3 {
    #[inline]
    pub fn zdes(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_zdes(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved15(&self) -> u64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_reserved15(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(zdes: u64, reserved15: u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let zdes: u64 = unsafe { ::std::mem::transmute(zdes) };
            zdes as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let reserved15: u64 = unsafe { ::std::mem::transmute(reserved15) };
            reserved15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_ns_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_ns_data>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_ns_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_ns_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_zns_ns_data))
    );
    fn test_field_zoc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zoc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(zoc)
            )
        );
    }
    test_field_zoc();
    fn test_field_ozcs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ozcs) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(ozcs)
            )
        );
    }
    test_field_ozcs();
    fn test_field_mar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mar) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(mar)
            )
        );
    }
    test_field_mar();
    fn test_field_mor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(mor)
            )
        );
    }
    test_field_mor();
    fn test_field_rrl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rrl) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(rrl)
            )
        );
    }
    test_field_rrl();
    fn test_field_frl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(frl)
            )
        );
    }
    test_field_frl();
    fn test_field_reserved20() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved20) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(reserved20)
            )
        );
    }
    test_field_reserved20();
    fn test_field_lbafe() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lbafe) as usize - ptr as usize
            },
            2816usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(lbafe)
            )
        );
    }
    test_field_lbafe();
    fn test_field_reserved3072() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3072) as usize - ptr as usize
            },
            3072usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(reserved3072)
            )
        );
    }
    test_field_reserved3072();
    fn test_field_vendor_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_ns_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendor_specific) as usize - ptr as usize
            },
            3840usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_ns_data),
                "::",
                stringify!(vendor_specific)
            )
        );
    }
    test_field_vendor_specific();
}
#[doc = " Not reported"]
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_NOT_REPORTED:
    spdk_nvme_dealloc_logical_block_read_value = 0;
#[doc = " Deallocated blocks read 0x00"]
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_00:
    spdk_nvme_dealloc_logical_block_read_value = 1;
#[doc = " Deallocated blocks read 0xFF"]
pub const spdk_nvme_dealloc_logical_block_read_value_SPDK_NVME_DEALLOC_READ_FF:
    spdk_nvme_dealloc_logical_block_read_value = 2;
#[doc = " Deallocated logical block features - read value"]
pub type spdk_nvme_dealloc_logical_block_read_value = ::std::os::raw::c_uint;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE: spdk_nvme_reservation_type =
    1;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS:
    spdk_nvme_reservation_type = 2;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_REG_ONLY:
    spdk_nvme_reservation_type = 3;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_REG_ONLY:
    spdk_nvme_reservation_type = 4;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_WRITE_EXCLUSIVE_ALL_REGS:
    spdk_nvme_reservation_type = 5;
pub const spdk_nvme_reservation_type_SPDK_NVME_RESERVE_EXCLUSIVE_ACCESS_ALL_REGS:
    spdk_nvme_reservation_type = 6;
#[doc = " Reservation Type Encoding"]
pub type spdk_nvme_reservation_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_acquire_data {
    #[doc = " current reservation key"]
    pub crkey: u64,
    #[doc = " preempt reservation key"]
    pub prkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_acquire_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_acquire_data>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_acquire_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_acquire_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_acquire_data)
        )
    );
    fn test_field_crkey() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_acquire_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crkey) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_acquire_data),
                "::",
                stringify!(crkey)
            )
        );
    }
    test_field_crkey();
    fn test_field_prkey() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_acquire_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prkey) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_acquire_data),
                "::",
                stringify!(prkey)
            )
        );
    }
    test_field_prkey();
}
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_ACQUIRE:
    spdk_nvme_reservation_acquire_action = 0;
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT:
    spdk_nvme_reservation_acquire_action = 1;
pub const spdk_nvme_reservation_acquire_action_SPDK_NVME_RESERVE_PREEMPT_ABORT:
    spdk_nvme_reservation_acquire_action = 2;
#[doc = " Reservation Acquire action"]
pub type spdk_nvme_reservation_acquire_action = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_status_data {
    #[doc = " reservation action generation counter"]
    pub gen: u32,
    #[doc = " reservation type"]
    pub rtype: u8,
    #[doc = " number of registered controllers"]
    pub regctl: u16,
    pub reserved1: u16,
    #[doc = " persist through power loss state"]
    pub ptpls: u8,
    pub reserved: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_status_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_status_data>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_status_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_status_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_status_data)
        )
    );
    fn test_field_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gen) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(gen)
            )
        );
    }
    test_field_gen();
    fn test_field_rtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rtype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(rtype)
            )
        );
    }
    test_field_rtype();
    fn test_field_regctl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regctl) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(regctl)
            )
        );
    }
    test_field_regctl();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_ptpls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptpls) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(ptpls)
            )
        );
    }
    test_field_ptpls();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_data),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_status_extended_data {
    pub data: spdk_nvme_reservation_status_data,
    pub reserved: [u8; 40usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_status_extended_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_status_extended_data>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_reservation_status_extended_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_status_extended_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_status_extended_data)
        )
    );
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_extended_data),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_status_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_status_extended_data),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_registered_ctrlr_data {
    #[doc = " controller id"]
    pub cntlid: u16,
    pub rcsts: spdk_nvme_registered_ctrlr_data__bindgen_ty_1,
    pub reserved2: [u8; 5usize],
    #[doc = " 64-bit host identifier"]
    pub hostid: u64,
    #[doc = " reservation key"]
    pub rkey: u64,
}
#[doc = " reservation status"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_registered_ctrlr_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registered_ctrlr_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registered_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_registered_ctrlr_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registered_ctrlr_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_registered_ctrlr_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_registered_ctrlr_data__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(status: u8, reserved1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let status: u8 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_registered_ctrlr_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registered_ctrlr_data>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_registered_ctrlr_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registered_ctrlr_data>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_registered_ctrlr_data))
    );
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_data),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_rcsts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rcsts) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_data),
                "::",
                stringify!(rcsts)
            )
        );
    }
    test_field_rcsts();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_data),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_hostid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_data),
                "::",
                stringify!(hostid)
            )
        );
    }
    test_field_hostid();
    fn test_field_rkey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rkey) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_data),
                "::",
                stringify!(rkey)
            )
        );
    }
    test_field_rkey();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_registered_ctrlr_extended_data {
    #[doc = " controller id"]
    pub cntlid: u16,
    pub rcsts: spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1,
    pub reserved2: [u8; 5usize],
    #[doc = " reservation key"]
    pub rkey: u64,
    #[doc = " 128-bit host identifier"]
    pub hostid: [u8; 16usize],
    pub reserved3: [u8; 32usize],
}
#[doc = " reservation status"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_registered_ctrlr_extended_data__bindgen_ty_1 {
    #[inline]
    pub fn status(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(status: u8, reserved1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let status: u8 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_registered_ctrlr_extended_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_registered_ctrlr_extended_data>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_registered_ctrlr_extended_data)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_registered_ctrlr_extended_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_registered_ctrlr_extended_data)
        )
    );
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_rcsts() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rcsts) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(rcsts)
            )
        );
    }
    test_field_rcsts();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_rkey() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rkey) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(rkey)
            )
        );
    }
    test_field_rkey();
    fn test_field_hostid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(hostid)
            )
        );
    }
    test_field_hostid();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_registered_ctrlr_extended_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_registered_ctrlr_extended_data),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
}
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_NO_CHANGES:
    spdk_nvme_reservation_register_cptpl = 0;
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_CLEAR_POWER_ON:
    spdk_nvme_reservation_register_cptpl = 2;
pub const spdk_nvme_reservation_register_cptpl_SPDK_NVME_RESERVE_PTPL_PERSIST_POWER_LOSS:
    spdk_nvme_reservation_register_cptpl = 3;
#[doc = " Change persist through power loss state for"]
#[doc = "  Reservation Register command"]
pub type spdk_nvme_reservation_register_cptpl = ::std::os::raw::c_uint;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REGISTER_KEY:
    spdk_nvme_reservation_register_action = 0;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_UNREGISTER_KEY:
    spdk_nvme_reservation_register_action = 1;
pub const spdk_nvme_reservation_register_action_SPDK_NVME_RESERVE_REPLACE_KEY:
    spdk_nvme_reservation_register_action = 2;
#[doc = " Registration action for Reservation Register command"]
pub type spdk_nvme_reservation_register_action = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_register_data {
    #[doc = " current reservation key"]
    pub crkey: u64,
    #[doc = " new reservation key"]
    pub nrkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_register_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_register_data>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_register_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_register_data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_register_data)
        )
    );
    fn test_field_crkey() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_register_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crkey) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_register_data),
                "::",
                stringify!(crkey)
            )
        );
    }
    test_field_crkey();
    fn test_field_nrkey() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_register_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nrkey) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_register_data),
                "::",
                stringify!(nrkey)
            )
        );
    }
    test_field_nrkey();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_key_data {
    #[doc = " current reservation key"]
    pub crkey: u64,
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_key_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_key_data>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_reservation_key_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_key_data>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_reservation_key_data))
    );
    fn test_field_crkey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_reservation_key_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crkey) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_key_data),
                "::",
                stringify!(crkey)
            )
        );
    }
    test_field_crkey();
}
pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_RELEASE:
    spdk_nvme_reservation_release_action = 0;
pub const spdk_nvme_reservation_release_action_SPDK_NVME_RESERVE_CLEAR:
    spdk_nvme_reservation_release_action = 1;
#[doc = " Reservation Release action"]
pub type spdk_nvme_reservation_release_action = ::std::os::raw::c_uint;
pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_LOG_PAGE_EMPTY:
    spdk_nvme_reservation_notification_log_page_type = 0;
pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_REGISTRATION_PREEMPTED:
    spdk_nvme_reservation_notification_log_page_type = 1;
pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_RELEASED:
    spdk_nvme_reservation_notification_log_page_type = 2;
pub const spdk_nvme_reservation_notification_log_page_type_SPDK_NVME_RESERVATION_PREEMPTED:
    spdk_nvme_reservation_notification_log_page_type = 3;
#[doc = " Reservation notification log page type"]
pub type spdk_nvme_reservation_notification_log_page_type = ::std::os::raw::c_uint;
#[doc = " Reservation notification log"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_reservation_notification_log {
    #[doc = " 64-bit incrementing reservation notification log page count"]
    pub log_page_count: u64,
    #[doc = " Reservation notification log page type"]
    pub type_: u8,
    #[doc = " Number of additional available reservation notification log pages"]
    pub num_avail_log_pages: u8,
    pub reserved: [u8; 2usize],
    pub nsid: u32,
    pub reserved1: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_reservation_notification_log() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_reservation_notification_log>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_reservation_notification_log)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_reservation_notification_log>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_reservation_notification_log)
        )
    );
    fn test_field_log_page_count() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_page_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(log_page_count)
            )
        );
    }
    test_field_log_page_count();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_num_avail_log_pages() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_avail_log_pages) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(num_avail_log_pages)
            )
        );
    }
    test_field_num_avail_log_pages();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_nsid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsid) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(nsid)
            )
        );
    }
    test_field_nsid();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_reservation_notification_log>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_reservation_notification_log),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
}
#[doc = " Error information (mandatory) - \\ref spdk_nvme_error_information_entry"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_ERROR: spdk_nvme_log_page = 1;
#[doc = " SMART / health information (mandatory) - \\ref spdk_nvme_health_information_page"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_HEALTH_INFORMATION: spdk_nvme_log_page = 2;
#[doc = " Firmware slot information (mandatory) - \\ref spdk_nvme_firmware_page"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_FIRMWARE_SLOT: spdk_nvme_log_page = 3;
#[doc = " Changed namespace list (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_CHANGED_NS_LIST: spdk_nvme_log_page = 4;
#[doc = " Command effects log (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_COMMAND_EFFECTS_LOG: spdk_nvme_log_page = 5;
#[doc = " Device self test (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_DEVICE_SELF_TEST: spdk_nvme_log_page = 6;
#[doc = " Host initiated telemetry log (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_TELEMETRY_HOST_INITIATED: spdk_nvme_log_page = 7;
#[doc = " Controller initiated telemetry log (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_TELEMETRY_CTRLR_INITIATED: spdk_nvme_log_page = 8;
#[doc = " Asymmetric namespace access log (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS: spdk_nvme_log_page = 12;
#[doc = " Discovery(refer to the NVMe over Fabrics specification)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_DISCOVERY: spdk_nvme_log_page = 112;
#[doc = " Reservation notification (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_RESERVATION_NOTIFICATION: spdk_nvme_log_page = 128;
#[doc = " Sanitize status (optional)"]
pub const spdk_nvme_log_page_SPDK_NVME_LOG_SANITIZE_STATUS: spdk_nvme_log_page = 129;
#[doc = " Log page identifiers for SPDK_NVME_OPC_GET_LOG_PAGE"]
pub type spdk_nvme_log_page = ::std::os::raw::c_uint;
#[doc = " Error information log page (\\ref SPDK_NVME_LOG_ERROR)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_error_information_entry {
    pub error_count: u64,
    pub sqid: u16,
    pub cid: u16,
    pub status: spdk_nvme_status,
    pub error_location: u16,
    pub lba: u64,
    pub nsid: u32,
    pub vendor_specific: u8,
    pub trtype: u8,
    pub reserved30: [u8; 2usize],
    pub command_specific: u64,
    pub trtype_specific: u16,
    pub reserved42: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_error_information_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_error_information_entry>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvme_error_information_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_error_information_entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_error_information_entry)
        )
    );
    fn test_field_error_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(error_count)
            )
        );
    }
    test_field_error_count();
    fn test_field_sqid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sqid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(sqid)
            )
        );
    }
    test_field_sqid();
    fn test_field_cid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(cid)
            )
        );
    }
    test_field_cid();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_error_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).error_location) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(error_location)
            )
        );
    }
    test_field_error_location();
    fn test_field_lba() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lba) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(lba)
            )
        );
    }
    test_field_lba();
    fn test_field_nsid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsid) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(nsid)
            )
        );
    }
    test_field_nsid();
    fn test_field_vendor_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendor_specific) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(vendor_specific)
            )
        );
    }
    test_field_vendor_specific();
    fn test_field_trtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trtype) as usize - ptr as usize
            },
            29usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(trtype)
            )
        );
    }
    test_field_trtype();
    fn test_field_reserved30() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved30) as usize - ptr as usize
            },
            30usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(reserved30)
            )
        );
    }
    test_field_reserved30();
    fn test_field_command_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).command_specific) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(command_specific)
            )
        );
    }
    test_field_command_specific();
    fn test_field_trtype_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trtype_specific) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(trtype_specific)
            )
        );
    }
    test_field_trtype_specific();
    fn test_field_reserved42() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_error_information_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved42) as usize - ptr as usize
            },
            42usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_error_information_entry),
                "::",
                stringify!(reserved42)
            )
        );
    }
    test_field_reserved42();
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmds_and_effect_entry {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmds_and_effect_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmds_and_effect_entry>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmds_and_effect_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmds_and_effect_entry>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_cmds_and_effect_entry))
    );
}
impl spdk_nvme_cmds_and_effect_entry {
    #[inline]
    pub fn csupp(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_csupp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn lbcc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_lbcc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ncc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ncc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nic(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_nic(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ccc(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ccc(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn cse(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cse(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        csupp: u16,
        lbcc: u16,
        ncc: u16,
        nic: u16,
        ccc: u16,
        reserved1: u16,
        cse: u16,
        reserved2: u16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let csupp: u16 = unsafe { ::std::mem::transmute(csupp) };
            csupp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let lbcc: u16 = unsafe { ::std::mem::transmute(lbcc) };
            lbcc as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ncc: u16 = unsafe { ::std::mem::transmute(ncc) };
            ncc as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let nic: u16 = unsafe { ::std::mem::transmute(nic) };
            nic as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ccc: u16 = unsafe { ::std::mem::transmute(ccc) };
            ccc as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let reserved1: u16 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let cse: u16 = unsafe { ::std::mem::transmute(cse) };
            cse as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let reserved2: u16 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_cmds_and_effect_log_page {
    #[doc = " Commands Supported and Effects Data Structure for the Admin Commands"]
    pub admin_cmds_supported: [spdk_nvme_cmds_and_effect_entry; 256usize],
    #[doc = " Commands Supported and Effects Data Structure for the IO Commands"]
    pub io_cmds_supported: [spdk_nvme_cmds_and_effect_entry; 256usize],
    pub reserved0: [u8; 2048usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_cmds_and_effect_log_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_cmds_and_effect_log_page>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_cmds_and_effect_log_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_cmds_and_effect_log_page>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_cmds_and_effect_log_page)
        )
    );
    fn test_field_admin_cmds_supported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_cmds_and_effect_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).admin_cmds_supported) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmds_and_effect_log_page),
                "::",
                stringify!(admin_cmds_supported)
            )
        );
    }
    test_field_admin_cmds_supported();
    fn test_field_io_cmds_supported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_cmds_and_effect_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_cmds_supported) as usize - ptr as usize
            },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmds_and_effect_log_page),
                "::",
                stringify!(io_cmds_supported)
            )
        );
    }
    test_field_io_cmds_supported();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_cmds_and_effect_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            2048usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_cmds_and_effect_log_page),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
}
#[repr(C)]
#[derive(Debug)]
pub struct spdk_nvme_telemetry_log_page_hdr {
    pub lpi: u8,
    pub rsvd: [u8; 4usize],
    pub ieee_oui: [u8; 3usize],
    pub dalb1: u16,
    pub dalb2: u16,
    pub dalb3: u16,
    pub rsvd1: [u8; 368usize],
    pub ctrlr_avail: u8,
    pub ctrlr_gen: u8,
    pub rsnident: [u8; 128usize],
    pub telemetry_datablock: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_telemetry_log_page_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_telemetry_log_page_hdr>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_telemetry_log_page_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_telemetry_log_page_hdr>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_telemetry_log_page_hdr)
        )
    );
    fn test_field_lpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lpi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(lpi)
            )
        );
    }
    test_field_lpi();
    fn test_field_rsvd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(rsvd)
            )
        );
    }
    test_field_rsvd();
    fn test_field_ieee_oui() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ieee_oui) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(ieee_oui)
            )
        );
    }
    test_field_ieee_oui();
    fn test_field_dalb1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dalb1) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(dalb1)
            )
        );
    }
    test_field_dalb1();
    fn test_field_dalb2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dalb2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(dalb2)
            )
        );
    }
    test_field_dalb2();
    fn test_field_dalb3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dalb3) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(dalb3)
            )
        );
    }
    test_field_dalb3();
    fn test_field_rsvd1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsvd1) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(rsvd1)
            )
        );
    }
    test_field_rsvd1();
    fn test_field_ctrlr_avail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlr_avail) as usize - ptr as usize
            },
            382usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(ctrlr_avail)
            )
        );
    }
    test_field_ctrlr_avail();
    fn test_field_ctrlr_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlr_gen) as usize - ptr as usize
            },
            383usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(ctrlr_gen)
            )
        );
    }
    test_field_ctrlr_gen();
    fn test_field_rsnident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsnident) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(rsnident)
            )
        );
    }
    test_field_rsnident();
    fn test_field_telemetry_datablock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_telemetry_log_page_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).telemetry_datablock) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_telemetry_log_page_hdr),
                "::",
                stringify!(telemetry_datablock)
            )
        );
    }
    test_field_telemetry_datablock();
}
pub const spdk_nvme_sanitize_status_type_SPDK_NVME_NEVER_BEEN_SANITIZED:
    spdk_nvme_sanitize_status_type = 0;
pub const spdk_nvme_sanitize_status_type_SPDK_NVME_RECENT_SANITIZE_SUCCESSFUL:
    spdk_nvme_sanitize_status_type = 1;
pub const spdk_nvme_sanitize_status_type_SPDK_NVME_SANITIZE_IN_PROGRESS:
    spdk_nvme_sanitize_status_type = 2;
pub const spdk_nvme_sanitize_status_type_SPDK_NVME_SANITIZE_FAILED: spdk_nvme_sanitize_status_type =
    3;
#[doc = " Sanitize Status Type"]
pub type spdk_nvme_sanitize_status_type = ::std::os::raw::c_uint;
#[doc = " Sanitize status sstat field"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sanitize_status_sstat {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sanitize_status_sstat() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sanitize_status_sstat>(),
        2usize,
        concat!("Size of: ", stringify!(spdk_nvme_sanitize_status_sstat))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sanitize_status_sstat>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_sanitize_status_sstat))
    );
}
impl spdk_nvme_sanitize_status_sstat {
    #[inline]
    pub fn status(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_status(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn complete_pass(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_complete_pass(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn global_data_erase(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_global_data_erase(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: u16,
        complete_pass: u16,
        global_data_erase: u16,
        reserved: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let status: u16 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let complete_pass: u16 = unsafe { ::std::mem::transmute(complete_pass) };
            complete_pass as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let global_data_erase: u16 = unsafe { ::std::mem::transmute(global_data_erase) };
            global_data_erase as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Sanitize log page"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sanitize_status_log_page {
    pub sprog: u16,
    pub sstat: spdk_nvme_sanitize_status_sstat,
    pub scdw10: u32,
    pub et_overwrite: u32,
    pub et_block_erase: u32,
    pub et_crypto_erase: u32,
    pub reserved: [u8; 492usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_sanitize_status_log_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sanitize_status_log_page>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_sanitize_status_log_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sanitize_status_log_page>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_sanitize_status_log_page)
        )
    );
    fn test_field_sprog() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sprog) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(sprog)
            )
        );
    }
    test_field_sprog();
    fn test_field_sstat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sstat) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(sstat)
            )
        );
    }
    test_field_sstat();
    fn test_field_scdw10() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scdw10) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(scdw10)
            )
        );
    }
    test_field_scdw10();
    fn test_field_et_overwrite() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).et_overwrite) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(et_overwrite)
            )
        );
    }
    test_field_et_overwrite();
    fn test_field_et_block_erase() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).et_block_erase) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(et_block_erase)
            )
        );
    }
    test_field_et_block_erase();
    fn test_field_et_crypto_erase() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).et_crypto_erase) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(et_crypto_erase)
            )
        );
    }
    test_field_et_crypto_erase();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_sanitize_status_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_sanitize_status_log_page),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_ERROR: spdk_nvme_async_event_type =
    0;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_SMART: spdk_nvme_async_event_type =
    1;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_NOTICE: spdk_nvme_async_event_type =
    2;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_IO: spdk_nvme_async_event_type = 6;
pub const spdk_nvme_async_event_type_SPDK_NVME_ASYNC_EVENT_TYPE_VENDOR: spdk_nvme_async_event_type =
    7;
#[doc = " Asynchronous Event Type"]
pub type spdk_nvme_async_event_type = ::std::os::raw::c_uint;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_WRITE_INVALID_DB:
    spdk_nvme_async_event_info_error = 0;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_INVALID_DB_WRITE:
    spdk_nvme_async_event_info_error = 1;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_DIAGNOSTIC_FAILURE:
    spdk_nvme_async_event_info_error = 2;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_PERSISTENT_INTERNAL:
    spdk_nvme_async_event_info_error = 3;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_TRANSIENT_INTERNAL:
    spdk_nvme_async_event_info_error = 4;
pub const spdk_nvme_async_event_info_error_SPDK_NVME_ASYNC_EVENT_FW_IMAGE_LOAD:
    spdk_nvme_async_event_info_error = 5;
#[doc = " Asynchronous Event Information for Error Status"]
pub type spdk_nvme_async_event_info_error = ::std::os::raw::c_uint;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SUBSYSTEM_RELIABILITY:
    spdk_nvme_async_event_info_smart = 0;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_TEMPERATURE_THRESHOLD:
    spdk_nvme_async_event_info_smart = 1;
pub const spdk_nvme_async_event_info_smart_SPDK_NVME_ASYNC_EVENT_SPARE_BELOW_THRESHOLD:
    spdk_nvme_async_event_info_smart = 2;
#[doc = " Asynchronous Event Information for SMART/Health Status"]
pub type spdk_nvme_async_event_info_smart = ::std::os::raw::c_uint;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_NS_ATTR_CHANGED:
    spdk_nvme_async_event_info_notice = 0;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_FW_ACTIVATION_START:
    spdk_nvme_async_event_info_notice = 1;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_TELEMETRY_LOG_CHANGED:
    spdk_nvme_async_event_info_notice = 2;
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_ANA_CHANGE:
    spdk_nvme_async_event_info_notice = 3;
#[doc = " Discovery log change event(refer to the NVMe over Fabrics specification)"]
pub const spdk_nvme_async_event_info_notice_SPDK_NVME_ASYNC_EVENT_DISCOVERY_LOG_CHANGE:
    spdk_nvme_async_event_info_notice = 240;
#[doc = " Asynchronous Event Information for Notice"]
pub type spdk_nvme_async_event_info_notice = ::std::os::raw::c_uint;
pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_RESERVATION_LOG_AVAIL:
    spdk_nvme_async_event_info_nvm_command_set = 0;
pub const spdk_nvme_async_event_info_nvm_command_set_SPDK_NVME_ASYNC_EVENT_SANITIZE_COMPLETED:
    spdk_nvme_async_event_info_nvm_command_set = 1;
#[doc = " Asynchronous Event Information for NVM Command Set Specific Status"]
pub type spdk_nvme_async_event_info_nvm_command_set = ::std::os::raw::c_uint;
#[doc = " Asynchronous Event Request Completion"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_async_event_completion {
    pub raw: u32,
    pub bits: spdk_nvme_async_event_completion__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_async_event_completion__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_async_event_completion__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_async_event_completion__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_async_event_completion__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_async_event_completion__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_async_event_completion__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_async_event_completion__bindgen_ty_1 {
    #[inline]
    pub fn async_event_type(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_async_event_type(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn async_event_info(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_async_event_info(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn log_page_identifier(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_log_page_identifier(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        async_event_type: u32,
        reserved1: u32,
        async_event_info: u32,
        log_page_identifier: u32,
        reserved2: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let async_event_type: u32 = unsafe { ::std::mem::transmute(async_event_type) };
            async_event_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved1: u32 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let async_event_info: u32 = unsafe { ::std::mem::transmute(async_event_info) };
            async_event_info as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let log_page_identifier: u32 = unsafe { ::std::mem::transmute(log_page_identifier) };
            log_page_identifier as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let reserved2: u32 = unsafe { ::std::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_async_event_completion() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_async_event_completion>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_async_event_completion))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_async_event_completion>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_async_event_completion)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_async_event_completion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_async_event_completion),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_async_event_completion>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_async_event_completion),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[doc = " Firmware slot information page (\\ref SPDK_NVME_LOG_FIRMWARE_SLOT)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_firmware_page {
    pub afi: spdk_nvme_firmware_page__bindgen_ty_1,
    pub reserved: [u8; 7usize],
    pub revision: [[u8; 8usize]; 7usize],
    #[doc = " Revisions for 7 slots (ASCII strings)"]
    pub reserved2: [u8; 448usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_firmware_page__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_firmware_page__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_firmware_page__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_firmware_page__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_firmware_page__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_firmware_page__bindgen_ty_1 {
    #[inline]
    pub fn active_slot(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_active_slot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn next_reset_slot(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_next_reset_slot(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved7(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reserved7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active_slot: u8,
        reserved3: u8,
        next_reset_slot: u8,
        reserved7: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let active_slot: u8 = unsafe { ::std::mem::transmute(active_slot) };
            active_slot as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let reserved3: u8 = unsafe { ::std::mem::transmute(reserved3) };
            reserved3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let next_reset_slot: u8 = unsafe { ::std::mem::transmute(next_reset_slot) };
            next_reset_slot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reserved7: u8 = unsafe { ::std::mem::transmute(reserved7) };
            reserved7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_firmware_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_firmware_page>(),
        512usize,
        concat!("Size of: ", stringify!(spdk_nvme_firmware_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_firmware_page>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_firmware_page))
    );
    fn test_field_afi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_firmware_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).afi) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_firmware_page),
                "::",
                stringify!(afi)
            )
        );
    }
    test_field_afi();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_firmware_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_firmware_page),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_revision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_firmware_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_firmware_page),
                "::",
                stringify!(revision)
            )
        );
    }
    test_field_revision();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_firmware_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_firmware_page),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
#[doc = " Asymmetric Namespace Acccess page (\\ref SPDK_NVME_LOG_ASYMMETRIC_NAMESPACE_ACCESS)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ana_page {
    pub change_count: u64,
    pub num_ana_group_desc: u16,
    pub reserved: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ana_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ana_page>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_nvme_ana_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ana_page>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ana_page))
    );
    fn test_field_change_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).change_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_page),
                "::",
                stringify!(change_count)
            )
        );
    }
    test_field_change_count();
    fn test_field_num_ana_group_desc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_ana_group_desc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_page),
                "::",
                stringify!(num_ana_group_desc)
            )
        );
    }
    test_field_num_ana_group_desc();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_page),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub const spdk_nvme_ana_state_SPDK_NVME_ANA_OPTIMIZED_STATE: spdk_nvme_ana_state = 1;
pub const spdk_nvme_ana_state_SPDK_NVME_ANA_NON_OPTIMIZED_STATE: spdk_nvme_ana_state = 2;
pub const spdk_nvme_ana_state_SPDK_NVME_ANA_INACCESSIBLE_STATE: spdk_nvme_ana_state = 3;
pub const spdk_nvme_ana_state_SPDK_NVME_ANA_PERSISTENT_LOSS_STATE: spdk_nvme_ana_state = 4;
pub const spdk_nvme_ana_state_SPDK_NVME_ANA_CHANGE_STATE: spdk_nvme_ana_state = 15;
pub type spdk_nvme_ana_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct spdk_nvme_ana_group_descriptor {
    pub ana_group_id: u32,
    pub num_of_nsid: u32,
    pub change_count: u64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: [u8; 15usize],
    pub nsid: __IncompleteArrayField<u32>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ana_group_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ana_group_descriptor>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_ana_group_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ana_group_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ana_group_descriptor))
    );
    fn test_field_ana_group_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_group_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ana_group_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_group_descriptor),
                "::",
                stringify!(ana_group_id)
            )
        );
    }
    test_field_ana_group_id();
    fn test_field_num_of_nsid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_group_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_of_nsid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_group_descriptor),
                "::",
                stringify!(num_of_nsid)
            )
        );
    }
    test_field_num_of_nsid();
    fn test_field_change_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_group_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).change_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_group_descriptor),
                "::",
                stringify!(change_count)
            )
        );
    }
    test_field_change_count();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_group_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_group_descriptor),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_nsid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ana_group_descriptor>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ana_group_descriptor),
                "::",
                stringify!(nsid)
            )
        );
    }
    test_field_nsid();
}
impl spdk_nvme_ana_group_descriptor {
    #[inline]
    pub fn ana_state(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ana_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reserved0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ana_state: u8, reserved0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ana_state: u8 = unsafe { ::std::mem::transmute(ana_state) };
            ana_state as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let reserved0: u8 = unsafe { ::std::mem::transmute(reserved0) };
            reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_ATTACH: spdk_nvme_ns_attach_type = 0;
pub const spdk_nvme_ns_attach_type_SPDK_NVME_NS_CTRLR_DETACH: spdk_nvme_ns_attach_type = 1;
#[doc = " Namespace attachment Type Encoding"]
pub type spdk_nvme_ns_attach_type = ::std::os::raw::c_uint;
pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_CREATE:
    spdk_nvme_ns_management_type = 0;
pub const spdk_nvme_ns_management_type_SPDK_NVME_NS_MANAGEMENT_DELETE:
    spdk_nvme_ns_management_type = 1;
#[doc = " Namespace management Type Encoding"]
pub type spdk_nvme_ns_management_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_list {
    pub ns_list: [u32; 1024usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_list>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_list))
    );
    fn test_field_ns_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ns_list) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_list),
                "::",
                stringify!(ns_list)
            )
        );
    }
    test_field_ns_list();
}
#[doc = " IEEE Extended Unique Identifier"]
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_EUI64: spdk_nvme_nidt = 1;
#[doc = " Namespace GUID"]
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_NGUID: spdk_nvme_nidt = 2;
#[doc = " Namespace UUID"]
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_UUID: spdk_nvme_nidt = 3;
#[doc = " Namespace Command Set Identifier"]
pub const spdk_nvme_nidt_SPDK_NVME_NIDT_CSI: spdk_nvme_nidt = 4;
#[doc = " Namespace identification descriptor type"]
#[doc = ""]
#[doc = " \\sa spdk_nvme_ns_id_desc"]
pub type spdk_nvme_nidt = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct spdk_nvme_ns_id_desc {
    #[doc = " Namespace identifier type"]
    pub nidt: u8,
    #[doc = " Namespace identifier length (length of nid field)"]
    pub nidl: u8,
    pub reserved2: u8,
    pub reserved3: u8,
    #[doc = " Namespace identifier"]
    pub nid: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_id_desc() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_id_desc>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_id_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_id_desc>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_id_desc))
    );
    fn test_field_nidt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_id_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nidt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_id_desc),
                "::",
                stringify!(nidt)
            )
        );
    }
    test_field_nidt();
    fn test_field_nidl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_id_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nidl) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_id_desc),
                "::",
                stringify!(nidl)
            )
        );
    }
    test_field_nidl();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_id_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_id_desc),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_id_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_id_desc),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_nid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_id_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_id_desc),
                "::",
                stringify!(nid)
            )
        );
    }
    test_field_nid();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ctrlr_list {
    pub ctrlr_count: u16,
    pub ctrlr_list: [u16; 2047usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ctrlr_list() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ctrlr_list>(),
        4096usize,
        concat!("Size of: ", stringify!(spdk_nvme_ctrlr_list))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ctrlr_list>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ctrlr_list))
    );
    fn test_field_ctrlr_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlr_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_list),
                "::",
                stringify!(ctrlr_count)
            )
        );
    }
    test_field_ctrlr_count();
    fn test_field_ctrlr_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ctrlr_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctrlr_list) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ctrlr_list),
                "::",
                stringify!(ctrlr_list)
            )
        );
    }
    test_field_ctrlr_list();
}
pub const spdk_nvme_csi_SPDK_NVME_CSI_NVM: spdk_nvme_csi = 0;
pub const spdk_nvme_csi_SPDK_NVME_CSI_KV: spdk_nvme_csi = 1;
pub const spdk_nvme_csi_SPDK_NVME_CSI_ZNS: spdk_nvme_csi = 2;
pub type spdk_nvme_csi = ::std::os::raw::c_uint;
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_NO_SECURE_ERASE:
    spdk_nvme_secure_erase_setting = 0;
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_USER_DATA_ERASE:
    spdk_nvme_secure_erase_setting = 1;
pub const spdk_nvme_secure_erase_setting_SPDK_NVME_FMT_NVM_SES_CRYPTO_ERASE:
    spdk_nvme_secure_erase_setting = 2;
pub type spdk_nvme_secure_erase_setting = ::std::os::raw::c_uint;
pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_TAIL: spdk_nvme_pi_location = 0;
pub const spdk_nvme_pi_location_SPDK_NVME_FMT_NVM_PROTECTION_AT_HEAD: spdk_nvme_pi_location = 1;
pub type spdk_nvme_pi_location = ::std::os::raw::c_uint;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_DISABLE: spdk_nvme_pi_type = 0;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE1: spdk_nvme_pi_type = 1;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE2: spdk_nvme_pi_type = 2;
pub const spdk_nvme_pi_type_SPDK_NVME_FMT_NVM_PROTECTION_TYPE3: spdk_nvme_pi_type = 3;
pub type spdk_nvme_pi_type = ::std::os::raw::c_uint;
pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_BUFFER:
    spdk_nvme_metadata_setting = 0;
pub const spdk_nvme_metadata_setting_SPDK_NVME_FMT_NVM_METADATA_TRANSFER_AS_LBA:
    spdk_nvme_metadata_setting = 1;
pub type spdk_nvme_metadata_setting = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_format {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_format() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_format>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_format))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_format>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_format))
    );
}
impl spdk_nvme_format {
    #[inline]
    pub fn lbaf(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_lbaf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ms(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ms(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pi(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pil(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pil(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ses(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ses(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        lbaf: u32,
        ms: u32,
        pi: u32,
        pil: u32,
        ses: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let lbaf: u32 = unsafe { ::std::mem::transmute(lbaf) };
            lbaf as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ms: u32 = unsafe { ::std::mem::transmute(ms) };
            ms as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let pi: u32 = unsafe { ::std::mem::transmute(pi) };
            pi as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pil: u32 = unsafe { ::std::mem::transmute(pil) };
            pil as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let ses: u32 = unsafe { ::std::mem::transmute(ses) };
            ses as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_protection_info {
    pub guard: u16,
    pub app_tag: u16,
    pub ref_tag: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_protection_info() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_protection_info>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_protection_info))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_protection_info>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_protection_info))
    );
    fn test_field_guard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_protection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).guard) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_protection_info),
                "::",
                stringify!(guard)
            )
        );
    }
    test_field_guard();
    fn test_field_app_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_protection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).app_tag) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_protection_info),
                "::",
                stringify!(app_tag)
            )
        );
    }
    test_field_app_tag();
    fn test_field_ref_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_protection_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ref_tag) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_protection_info),
                "::",
                stringify!(ref_tag)
            )
        );
    }
    test_field_ref_tag();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_sanitize {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_sanitize() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_sanitize>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_sanitize))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_sanitize>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_sanitize))
    );
}
impl spdk_nvme_sanitize {
    #[inline]
    pub fn sanact(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_sanact(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ause(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ause(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn owpass(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_owpass(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn oipbp(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_oipbp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndas(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ndas(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sanact: u32,
        ause: u32,
        owpass: u32,
        oipbp: u32,
        ndas: u32,
        reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let sanact: u32 = unsafe { ::std::mem::transmute(sanact) };
            sanact as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ause: u32 = unsafe { ::std::mem::transmute(ause) };
            ause as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let owpass: u32 = unsafe { ::std::mem::transmute(owpass) };
            owpass as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let oipbp: u32 = unsafe { ::std::mem::transmute(oipbp) };
            oipbp as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ndas: u32 = unsafe { ::std::mem::transmute(ndas) };
            ndas as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const spdk_sanitize_action_SPDK_NVME_SANITIZE_EXIT_FAILURE_MODE: spdk_sanitize_action = 1;
pub const spdk_sanitize_action_SPDK_NVME_SANITIZE_BLOCK_ERASE: spdk_sanitize_action = 2;
pub const spdk_sanitize_action_SPDK_NVME_SANITIZE_OVERWRITE: spdk_sanitize_action = 3;
pub const spdk_sanitize_action_SPDK_NVME_SANITIZE_CRYPTO_ERASE: spdk_sanitize_action = 4;
pub type spdk_sanitize_action = ::std::os::raw::c_uint;
#[doc = " Downloaded image replaces the image specified by"]
#[doc = " the Firmware Slot field. This image is not activated."]
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_IMG: spdk_nvme_fw_commit_action =
    0;
#[doc = " Downloaded image replaces the image specified by"]
#[doc = " the Firmware Slot field. This image is activated at the next reset."]
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_REPLACE_AND_ENABLE_IMG:
    spdk_nvme_fw_commit_action = 1;
#[doc = " The image specified by the Firmware Slot field is"]
#[doc = " activated at the next reset."]
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_ENABLE_IMG: spdk_nvme_fw_commit_action = 2;
#[doc = " The image specified by the Firmware Slot field is"]
#[doc = " requested to be activated immediately without reset."]
pub const spdk_nvme_fw_commit_action_SPDK_NVME_FW_COMMIT_RUN_IMG: spdk_nvme_fw_commit_action = 3;
#[doc = " Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10: commit action"]
pub type spdk_nvme_fw_commit_action = ::std::os::raw::c_uint;
#[doc = " Parameters for SPDK_NVME_OPC_FIRMWARE_COMMIT cdw10"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_fw_commit {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_fw_commit() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_fw_commit>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvme_fw_commit))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_fw_commit>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_fw_commit))
    );
}
impl spdk_nvme_fw_commit {
    #[inline]
    pub fn fs(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_fs(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ca(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_ca(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fs: u32, ca: u32, reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let fs: u32 = unsafe { ::std::mem::transmute(fs) };
            fs as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let ca: u32 = unsafe { ::std::mem::transmute(ca) };
            ca as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let reserved: u32 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const spdk_nvme_zns_zone_send_action_SPDK_NVME_ZONE_CLOSE: spdk_nvme_zns_zone_send_action = 1;
pub const spdk_nvme_zns_zone_send_action_SPDK_NVME_ZONE_FINISH: spdk_nvme_zns_zone_send_action = 2;
pub const spdk_nvme_zns_zone_send_action_SPDK_NVME_ZONE_OPEN: spdk_nvme_zns_zone_send_action = 3;
pub const spdk_nvme_zns_zone_send_action_SPDK_NVME_ZONE_RESET: spdk_nvme_zns_zone_send_action = 4;
pub const spdk_nvme_zns_zone_send_action_SPDK_NVME_ZONE_OFFLINE: spdk_nvme_zns_zone_send_action = 5;
pub type spdk_nvme_zns_zone_send_action = ::std::os::raw::c_uint;
pub const spdk_nvme_zns_zone_receive_action_SPDK_NVME_ZONE_REPORT:
    spdk_nvme_zns_zone_receive_action = 0;
pub type spdk_nvme_zns_zone_receive_action = ::std::os::raw::c_uint;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ALL: spdk_nvme_zns_zra_report_opts = 0;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSE: spdk_nvme_zns_zra_report_opts = 1;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSIO: spdk_nvme_zns_zra_report_opts = 2;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSEO: spdk_nvme_zns_zra_report_opts = 3;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSC: spdk_nvme_zns_zra_report_opts = 4;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSF: spdk_nvme_zns_zra_report_opts = 5;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSRO: spdk_nvme_zns_zra_report_opts = 6;
pub const spdk_nvme_zns_zra_report_opts_SPDK_NVME_ZRA_LIST_ZSO: spdk_nvme_zns_zra_report_opts = 7;
pub type spdk_nvme_zns_zra_report_opts = ::std::os::raw::c_uint;
pub const spdk_nvme_zns_zone_type_SPDK_NVME_ZONE_TYPE_SEQWR: spdk_nvme_zns_zone_type = 2;
pub type spdk_nvme_zns_zone_type = ::std::os::raw::c_uint;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_EMPTY: spdk_nvme_zns_zone_state = 1;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_IOPEN: spdk_nvme_zns_zone_state = 2;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_EOPEN: spdk_nvme_zns_zone_state = 3;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_CLOSED: spdk_nvme_zns_zone_state = 4;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_RONLY: spdk_nvme_zns_zone_state = 13;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_FULL: spdk_nvme_zns_zone_state = 14;
pub const spdk_nvme_zns_zone_state_SPDK_NVME_ZONE_STATE_OFFLINE: spdk_nvme_zns_zone_state = 15;
pub type spdk_nvme_zns_zone_state = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_zns_zone_desc {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub za: spdk_nvme_zns_zone_desc__bindgen_ty_1,
    pub reserved: [u8; 5usize],
    #[doc = " Zone Capacity (in number of LBAs)"]
    pub zcap: u64,
    #[doc = " Zone Start LBA"]
    pub zslba: u64,
    #[doc = " Write Pointer (LBA)"]
    pub wp: u64,
    pub reserved32: [u8; 32usize],
}
#[doc = " Zone Attributes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_zns_zone_desc__bindgen_ty_1 {
    pub raw: u8,
    pub bits: spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_zns_zone_desc__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn zfc(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zfc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn zfr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zfr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rzr(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rzr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd3(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zdev(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_zdev(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        zfc: u8,
        zfr: u8,
        rzr: u8,
        rsvd3: u8,
        zdev: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zfc: u8 = unsafe { ::std::mem::transmute(zfc) };
            zfc as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let zfr: u8 = unsafe { ::std::mem::transmute(zfr) };
            zfr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rzr: u8 = unsafe { ::std::mem::transmute(rzr) };
            rzr as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let rsvd3: u8 = unsafe { ::std::mem::transmute(rsvd3) };
            rsvd3 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let zdev: u8 = unsafe { ::std::mem::transmute(zdev) };
            zdev as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_zone_desc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_zone_desc__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_zone_desc__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_zone_desc() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_zone_desc>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_zone_desc))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_zone_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_zns_zone_desc))
    );
    fn test_field_za() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).za) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(za)
            )
        );
    }
    test_field_za();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_zcap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zcap) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(zcap)
            )
        );
    }
    test_field_zcap();
    fn test_field_zslba() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).zslba) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(zslba)
            )
        );
    }
    test_field_zslba();
    fn test_field_wp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wp) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(wp)
            )
        );
    }
    test_field_wp();
    fn test_field_reserved32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_desc>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved32) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_desc),
                "::",
                stringify!(reserved32)
            )
        );
    }
    test_field_reserved32();
}
impl spdk_nvme_zns_zone_desc {
    #[inline]
    pub fn zt(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_zt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd0(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rsvd1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_rsvd1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn zs(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_zs(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        zt: u8,
        rsvd0: u8,
        rsvd1: u8,
        zs: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let zt: u8 = unsafe { ::std::mem::transmute(zt) };
            zt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rsvd0: u8 = unsafe { ::std::mem::transmute(rsvd0) };
            rsvd0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let rsvd1: u8 = unsafe { ::std::mem::transmute(rsvd1) };
            rsvd1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let zs: u8 = unsafe { ::std::mem::transmute(zs) };
            zs as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct spdk_nvme_zns_zone_report {
    pub nr_zones: u64,
    pub reserved8: [u8; 56usize],
    pub descs: __IncompleteArrayField<spdk_nvme_zns_zone_desc>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_zns_zone_report() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_zns_zone_report>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvme_zns_zone_report))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_zns_zone_report>(),
        8usize,
        concat!("Alignment of ", stringify!(spdk_nvme_zns_zone_report))
    );
    fn test_field_nr_zones() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_report>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nr_zones) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_report),
                "::",
                stringify!(nr_zones)
            )
        );
    }
    test_field_nr_zones();
    fn test_field_reserved8() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_report>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_report),
                "::",
                stringify!(reserved8)
            )
        );
    }
    test_field_reserved8();
    fn test_field_descs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_zns_zone_report>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).descs) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_zns_zone_report),
                "::",
                stringify!(descs)
            )
        );
    }
    test_field_descs();
}
pub const spdk_nvme_directive_type_SPDK_NVME_DIRECTIVE_TYPE_IDENTIFY: spdk_nvme_directive_type = 0;
pub const spdk_nvme_directive_type_SPDK_NVME_DIRECTIVE_TYPE_STREAMS: spdk_nvme_directive_type = 1;
pub type spdk_nvme_directive_type = ::std::os::raw::c_uint;
pub const spdk_nvme_identify_directive_send_operation_SPDK_NVME_IDENTIFY_DIRECTIVE_SEND_ENABLED:
    spdk_nvme_identify_directive_send_operation = 1;
pub type spdk_nvme_identify_directive_send_operation = ::std::os::raw::c_uint;
pub const spdk_nvme_identify_directive_receive_operation_SPDK_NVME_IDENTIFY_DIRECTIVE_RECEIVE_RETURN_PARAM : spdk_nvme_identify_directive_receive_operation = 1 ;
pub type spdk_nvme_identify_directive_receive_operation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_identify_directive_param {
    pub directives_supported: spdk_nvme_ns_identify_directive_param__bindgen_ty_1,
    pub directives_enabled: spdk_nvme_ns_identify_directive_param__bindgen_ty_2,
    pub reserved: [u32; 1008usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_identify_directive_param__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved2: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_identify_directive_param__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_identify_directive_param__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_identify_directive_param__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_1)
        )
    );
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_ns_identify_directive_param__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_1),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
impl spdk_nvme_ns_identify_directive_param__bindgen_ty_1 {
    #[inline]
    pub fn identify(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_identify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn streams(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_streams(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        identify: u8,
        streams: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let identify: u8 = unsafe { ::std::mem::transmute(identify) };
            identify as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let streams: u8 = unsafe { ::std::mem::transmute(streams) };
            streams as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_identify_directive_param__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved2: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_identify_directive_param__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_identify_directive_param__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_identify_directive_param__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_2)
        )
    );
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_ns_identify_directive_param__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_identify_directive_param__bindgen_ty_2),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
impl spdk_nvme_ns_identify_directive_param__bindgen_ty_2 {
    #[inline]
    pub fn identify(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_identify(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn streams(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_streams(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        identify: u8,
        streams: u8,
        reserved1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let identify: u8 = unsafe { ::std::mem::transmute(identify) };
            identify as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let streams: u8 = unsafe { ::std::mem::transmute(streams) };
            streams as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved1: u8 = unsafe { ::std::mem::transmute(reserved1) };
            reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_identify_directive_param() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_identify_directive_param>(),
        4096usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_identify_directive_param)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_identify_directive_param>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_identify_directive_param)
        )
    );
    fn test_field_directives_supported() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ns_identify_directive_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directives_supported) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_identify_directive_param),
                "::",
                stringify!(directives_supported)
            )
        );
    }
    test_field_directives_supported();
    fn test_field_directives_enabled() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ns_identify_directive_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).directives_enabled) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_identify_directive_param),
                "::",
                stringify!(directives_enabled)
            )
        );
    }
    test_field_directives_enabled();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_ns_identify_directive_param>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_identify_directive_param),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub const spdk_nvme_streams_directive_receive_operation_SPDK_NVME_STREAMS_DIRECTIVE_RECEIVE_RETURN_PARAM : spdk_nvme_streams_directive_receive_operation = 1 ;
pub const spdk_nvme_streams_directive_receive_operation_SPDK_NVME_STREAMS_DIRECTIVE_RECEIVE_GET_STATUS : spdk_nvme_streams_directive_receive_operation = 2 ;
pub const spdk_nvme_streams_directive_receive_operation_SPDK_NVME_STREAMS_DIRECTIVE_RECEIVE_ALLOCATE_RESOURCE : spdk_nvme_streams_directive_receive_operation = 3 ;
pub type spdk_nvme_streams_directive_receive_operation = ::std::os::raw::c_uint;
pub const spdk_nvme_streams_directive_send_operation_SPDK_NVME_STREAMS_DIRECTIVE_SEND_RELEASE_ID:
    spdk_nvme_streams_directive_send_operation = 1;
pub const spdk_nvme_streams_directive_send_operation_SPDK_NVME_STREAMS_DIRECTIVE_SEND_RELEASE_RESOURCE : spdk_nvme_streams_directive_send_operation = 2 ;
pub type spdk_nvme_streams_directive_send_operation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_streams_data {
    pub msl: u16,
    pub nssa: u16,
    pub nsso: u16,
    pub nssc: spdk_nvme_ns_streams_data__bindgen_ty_1,
    pub reserved1: [u8; 9usize],
    pub sws: u32,
    pub sgs: u16,
    pub nsa: u16,
    pub nso: u16,
    pub reserved2: [u8; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_streams_data__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_streams_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_streams_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_ns_streams_data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_streams_data__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_ns_streams_data__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_ns_streams_data__bindgen_ty_1 {
    #[inline]
    pub fn ssid(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ssid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ssid: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ssid: u8 = unsafe { ::std::mem::transmute(ssid) };
            ssid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_streams_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_streams_data>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_streams_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_streams_data>(),
        4usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_streams_data))
    );
    fn test_field_msl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).msl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(msl)
            )
        );
    }
    test_field_msl();
    fn test_field_nssa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nssa) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(nssa)
            )
        );
    }
    test_field_nssa();
    fn test_field_nsso() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsso) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(nsso)
            )
        );
    }
    test_field_nsso();
    fn test_field_nssc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nssc) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(nssc)
            )
        );
    }
    test_field_nssc();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_sws() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sws) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(sws)
            )
        );
    }
    test_field_sws();
    fn test_field_sgs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sgs) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(sgs)
            )
        );
    }
    test_field_sgs();
    fn test_field_nsa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nsa) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(nsa)
            )
        );
    }
    test_field_nsa();
    fn test_field_nso() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nso) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(nso)
            )
        );
    }
    test_field_nso();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            26usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_data),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_ns_streams_status {
    pub open_streams_count: u16,
    pub stream_id: [u16; 65535usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_ns_streams_status() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_ns_streams_status>(),
        131072usize,
        concat!("Size of: ", stringify!(spdk_nvme_ns_streams_status))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_ns_streams_status>(),
        2usize,
        concat!("Alignment of ", stringify!(spdk_nvme_ns_streams_status))
    );
    fn test_field_open_streams_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open_streams_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_status),
                "::",
                stringify!(open_streams_count)
            )
        );
    }
    test_field_open_streams_count();
    fn test_field_stream_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_ns_streams_status>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stream_id) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_ns_streams_status),
                "::",
                stringify!(stream_id)
            )
        );
    }
    test_field_stream_id();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_capsule_cmd {
    pub opcode: u8,
    pub reserved1: u8,
    pub cid: u16,
    pub fctype: u8,
    pub reserved2: [u8; 35usize],
    pub fabric_specific: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_spdk_nvmf_capsule_cmd() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_capsule_cmd>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvmf_capsule_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_capsule_cmd>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_capsule_cmd))
    );
    fn test_field_opcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(opcode)
            )
        );
    }
    test_field_opcode();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_cid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(cid)
            )
        );
    }
    test_field_cid();
    fn test_field_fctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fctype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(fctype)
            )
        );
    }
    test_field_fctype();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_fabric_specific() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_capsule_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fabric_specific) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_capsule_cmd),
                "::",
                stringify!(fabric_specific)
            )
        );
    }
    test_field_fabric_specific();
}
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_SET:
    spdk_nvmf_fabric_cmd_types = 0;
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_CONNECT: spdk_nvmf_fabric_cmd_types =
    1;
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_PROPERTY_GET:
    spdk_nvmf_fabric_cmd_types = 4;
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_SEND:
    spdk_nvmf_fabric_cmd_types = 5;
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_AUTHENTICATION_RECV:
    spdk_nvmf_fabric_cmd_types = 6;
pub const spdk_nvmf_fabric_cmd_types_SPDK_NVMF_FABRIC_COMMAND_START_VENDOR_SPECIFIC:
    spdk_nvmf_fabric_cmd_types = 192;
pub type spdk_nvmf_fabric_cmd_types = ::std::os::raw::c_uint;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INCOMPATIBLE_FORMAT:
    spdk_nvmf_fabric_cmd_status_code = 128;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_CONTROLLER_BUSY:
    spdk_nvmf_fabric_cmd_status_code = 129;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_PARAM:
    spdk_nvmf_fabric_cmd_status_code = 130;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_RESTART_DISCOVERY:
    spdk_nvmf_fabric_cmd_status_code = 131;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_INVALID_HOST:
    spdk_nvmf_fabric_cmd_status_code = 132;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_LOG_RESTART_DISCOVERY:
    spdk_nvmf_fabric_cmd_status_code = 144;
pub const spdk_nvmf_fabric_cmd_status_code_SPDK_NVMF_FABRIC_SC_AUTH_REQUIRED:
    spdk_nvmf_fabric_cmd_status_code = 145;
pub type spdk_nvmf_fabric_cmd_status_code = ::std::os::raw::c_uint;
#[doc = " Reliable connected"]
pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_CONNECTED: spdk_nvmf_rdma_qptype = 1;
#[doc = " Reliable datagram"]
pub const spdk_nvmf_rdma_qptype_SPDK_NVMF_RDMA_QPTYPE_RELIABLE_DATAGRAM: spdk_nvmf_rdma_qptype = 2;
#[doc = " RDMA Queue Pair service types"]
pub type spdk_nvmf_rdma_qptype = ::std::os::raw::c_uint;
#[doc = " No provider specified"]
pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_NONE: spdk_nvmf_rdma_prtype = 1;
#[doc = " InfiniBand"]
pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IB: spdk_nvmf_rdma_prtype = 2;
#[doc = " RoCE v1"]
pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE: spdk_nvmf_rdma_prtype = 3;
#[doc = " RoCE v2"]
pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_ROCE2: spdk_nvmf_rdma_prtype = 4;
#[doc = " iWARP"]
pub const spdk_nvmf_rdma_prtype_SPDK_NVMF_RDMA_PRTYPE_IWARP: spdk_nvmf_rdma_prtype = 5;
#[doc = " RDMA provider types"]
pub type spdk_nvmf_rdma_prtype = ::std::os::raw::c_uint;
#[doc = " Sockets based endpoint addressing"]
pub const spdk_nvmf_rdma_cms_SPDK_NVMF_RDMA_CMS_RDMA_CM: spdk_nvmf_rdma_cms = 1;
#[doc = " RDMA connection management service types"]
pub type spdk_nvmf_rdma_cms = ::std::os::raw::c_uint;
#[doc = " RDMA"]
pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_RDMA: spdk_nvmf_trtype = 1;
#[doc = " Fibre Channel"]
pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_FC: spdk_nvmf_trtype = 2;
#[doc = " TCP"]
pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_TCP: spdk_nvmf_trtype = 3;
#[doc = " Intra-host transport (loopback)"]
pub const spdk_nvmf_trtype_SPDK_NVMF_TRTYPE_INTRA_HOST: spdk_nvmf_trtype = 254;
#[doc = " NVMe over Fabrics transport types"]
pub type spdk_nvmf_trtype = ::std::os::raw::c_uint;
#[doc = " IPv4 (AF_INET)"]
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV4: spdk_nvmf_adrfam = 1;
#[doc = " IPv6 (AF_INET6)"]
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IPV6: spdk_nvmf_adrfam = 2;
#[doc = " InfiniBand (AF_IB)"]
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_IB: spdk_nvmf_adrfam = 3;
#[doc = " Fibre Channel address family"]
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_FC: spdk_nvmf_adrfam = 4;
#[doc = " Intra-host transport (loopback)"]
pub const spdk_nvmf_adrfam_SPDK_NVMF_ADRFAM_INTRA_HOST: spdk_nvmf_adrfam = 254;
#[doc = " Address family types"]
pub type spdk_nvmf_adrfam = ::std::os::raw::c_uint;
#[doc = " Discovery type for NVM subsystem"]
pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_DISCOVERY: spdk_nvmf_subtype = 1;
#[doc = " NVMe type for NVM subsystem"]
pub const spdk_nvmf_subtype_SPDK_NVMF_SUBTYPE_NVME: spdk_nvmf_subtype = 2;
#[doc = " NVM subsystem types"]
pub type spdk_nvmf_subtype = ::std::os::raw::c_uint;
#[doc = " Not specified"]
pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_SPECIFIED:
    spdk_nvmf_treq_secure_channel = 0;
#[doc = " Required"]
pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_REQUIRED:
    spdk_nvmf_treq_secure_channel = 1;
#[doc = " Not required"]
pub const spdk_nvmf_treq_secure_channel_SPDK_NVMF_TREQ_SECURE_CHANNEL_NOT_REQUIRED:
    spdk_nvmf_treq_secure_channel = 2;
#[doc = " Connections shall be made over a fabric secure channel"]
pub type spdk_nvmf_treq_secure_channel = ::std::os::raw::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_connect_data {
    pub hostid: [u8; 16usize],
    pub cntlid: u16,
    pub reserved5: [u8; 238usize],
    pub subnqn: [u8; 256usize],
    pub hostnqn: [u8; 256usize],
    pub reserved6: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_connect_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_connect_data>(),
        1024usize,
        concat!("Size of: ", stringify!(spdk_nvmf_fabric_connect_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_connect_data>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_fabric_connect_data))
    );
    fn test_field_hostid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(hostid)
            )
        );
    }
    test_field_hostid();
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_reserved5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(reserved5)
            )
        );
    }
    test_field_reserved5();
    fn test_field_subnqn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subnqn) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(subnqn)
            )
        );
    }
    test_field_subnqn();
    fn test_field_hostnqn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hostnqn) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(hostnqn)
            )
        );
    }
    test_field_hostnqn();
    fn test_field_reserved6() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize
            },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_data),
                "::",
                stringify!(reserved6)
            )
        );
    }
    test_field_reserved6();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union spdk_nvmf_fabric_connect_rsp__bindgen_ty_1 {
    pub success: spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1,
    pub invalid: spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2,
    pub raw: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1 {
    pub cntlid: u16,
    pub authreq: u16,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_authreq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).authreq) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(authreq)
            )
        );
    }
    test_field_authreq();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2 {
    pub ipo: u16,
    pub iattr: u8,
    pub reserved: u8,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_ipo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ipo) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(ipo)
            )
        );
    }
    test_field_ipo();
    fn test_field_iattr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iattr) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(iattr)
            )
        );
    }
    test_field_iattr();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_connect_rsp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1)
        )
    );
    fn test_field_success() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1),
                "::",
                stringify!(success)
            )
        );
    }
    test_field_success();
    fn test_field_invalid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invalid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1),
                "::",
                stringify!(invalid)
            )
        );
    }
    test_field_invalid();
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_connect_rsp__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_connect_rsp__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_get_cmd {
    pub opcode: u8,
    pub reserved1: u8,
    pub cid: u16,
    pub fctype: u8,
    pub reserved2: [u8; 35usize],
    pub attrib: spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1,
    pub reserved3: [u8; 3usize],
    pub ofst: u32,
    pub reserved4: [u8; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1)
        )
    );
}
impl spdk_nvmf_fabric_prop_get_cmd__bindgen_ty_1 {
    #[inline]
    pub fn size(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(size: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let size: u8 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_cmd() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_get_cmd>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvmf_fabric_prop_get_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_get_cmd>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_fabric_prop_get_cmd))
    );
    fn test_field_opcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(opcode)
            )
        );
    }
    test_field_opcode();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_cid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(cid)
            )
        );
    }
    test_field_cid();
    fn test_field_fctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fctype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(fctype)
            )
        );
    }
    test_field_fctype();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_reserved3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize
            },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(reserved3)
            )
        );
    }
    test_field_reserved3();
    fn test_field_ofst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ofst) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(ofst)
            )
        );
    }
    test_field_ofst();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_cmd),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1 {
    pub u64_: u64,
    pub u32_: spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1 {
    pub low: u32,
    pub high: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_low() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(low)
            )
        );
    }
    test_field_low();
    fn test_field_high() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(high)
            )
        );
    }
    test_field_high();
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1)
        )
    );
    fn test_field_u64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1),
                "::",
                stringify!(u64_)
            )
        );
    }
    test_field_u64();
    fn test_field_u32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_get_rsp__bindgen_ty_1),
                "::",
                stringify!(u32_)
            )
        );
    }
    test_field_u32();
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_set_cmd {
    pub opcode: u8,
    pub reserved0: u8,
    pub cid: u16,
    pub fctype: u8,
    pub reserved1: [u8; 35usize],
    pub attrib: spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1,
    pub reserved2: [u8; 3usize],
    pub ofst: u32,
    pub value: spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2,
    pub reserved4: [u8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1)
        )
    );
}
impl spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_1 {
    #[inline]
    pub fn size(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(size: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let size: u8 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2 {
    pub u64_: u64,
    pub u32_: spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1 {
    pub low: u32,
    pub high: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field_low() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(low)
            )
        );
    }
    test_field_low();
    fn test_field_high() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(high)
            )
        );
    }
    test_field_high();
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2)
        )
    );
    fn test_field_u64() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u64_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2),
                "::",
                stringify!(u64_)
            )
        );
    }
    test_field_u64();
    fn test_field_u32() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd__bindgen_ty_2),
                "::",
                stringify!(u32_)
            )
        );
    }
    test_field_u32();
}
#[test]
fn bindgen_test_layout_spdk_nvmf_fabric_prop_set_cmd() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_fabric_prop_set_cmd>(),
        64usize,
        concat!("Size of: ", stringify!(spdk_nvmf_fabric_prop_set_cmd))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_fabric_prop_set_cmd>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_fabric_prop_set_cmd))
    );
    fn test_field_opcode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(opcode)
            )
        );
    }
    test_field_opcode();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_cid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(cid)
            )
        );
    }
    test_field_cid();
    fn test_field_fctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fctype) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(fctype)
            )
        );
    }
    test_field_fctype();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_attrib() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attrib) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(attrib)
            )
        );
    }
    test_field_attrib();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            41usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
    fn test_field_ofst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ofst) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(ofst)
            )
        );
    }
    test_field_ofst();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_reserved4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_fabric_prop_set_cmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_fabric_prop_set_cmd),
                "::",
                stringify!(reserved4)
            )
        );
    }
    test_field_reserved4();
}
#[doc = " RDMA transport-specific address subtype"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_rdma_transport_specific_address_subtype {
    #[doc = " RDMA QP service type (\\ref spdk_nvmf_rdma_qptype)"]
    pub rdma_qptype: u8,
    #[doc = " RDMA provider type (\\ref spdk_nvmf_rdma_prtype)"]
    pub rdma_prtype: u8,
    #[doc = " RDMA connection management service (\\ref spdk_nvmf_rdma_cms)"]
    pub rdma_cms: u8,
    pub reserved0: [u8; 5usize],
    #[doc = " RDMA partition key for AF_IB"]
    pub rdma_pkey: u16,
    pub reserved2: [u8; 246usize],
}
#[test]
fn bindgen_test_layout_spdk_nvmf_rdma_transport_specific_address_subtype() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_rdma_transport_specific_address_subtype>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_rdma_transport_specific_address_subtype)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_rdma_transport_specific_address_subtype>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_rdma_transport_specific_address_subtype)
        )
    );
    fn test_field_rdma_qptype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdma_qptype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(rdma_qptype)
            )
        );
    }
    test_field_rdma_qptype();
    fn test_field_rdma_prtype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdma_prtype) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(rdma_prtype)
            )
        );
    }
    test_field_rdma_prtype();
    fn test_field_rdma_cms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdma_cms) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(rdma_cms)
            )
        );
    }
    test_field_rdma_cms();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_rdma_pkey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdma_pkey) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(rdma_pkey)
            )
        );
    }
    test_field_rdma_pkey();
    fn test_field_reserved2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvmf_rdma_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_transport_specific_address_subtype),
                "::",
                stringify!(reserved2)
            )
        );
    }
    test_field_reserved2();
}
#[doc = " No security"]
pub const spdk_nvme_tcp_secure_socket_type_SPDK_NVME_TCP_SECURITY_NONE:
    spdk_nvme_tcp_secure_socket_type = 0;
#[doc = " TLS (Secure Sockets)"]
pub const spdk_nvme_tcp_secure_socket_type_SPDK_NVME_TCP_SECURITY_TLS:
    spdk_nvme_tcp_secure_socket_type = 1;
#[doc = " TCP Secure Socket Type"]
pub type spdk_nvme_tcp_secure_socket_type = ::std::os::raw::c_uint;
#[doc = " TCP transport-specific address subtype"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_transport_specific_address_subtype {
    #[doc = " Security type (\\ref spdk_nvme_tcp_secure_socket_type)"]
    pub sectype: u8,
    pub reserved0: [u8; 255usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_transport_specific_address_subtype() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_transport_specific_address_subtype>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_tcp_transport_specific_address_subtype)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_transport_specific_address_subtype>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_tcp_transport_specific_address_subtype)
        )
    );
    fn test_field_sectype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_tcp_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sectype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_transport_specific_address_subtype),
                "::",
                stringify!(sectype)
            )
        );
    }
    test_field_sectype();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    spdk_nvme_tcp_transport_specific_address_subtype,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_transport_specific_address_subtype),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
}
#[doc = " Transport-specific address subtype"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvmf_transport_specific_address_subtype {
    pub raw: [u8; 256usize],
    #[doc = " RDMA"]
    pub rdma: spdk_nvmf_rdma_transport_specific_address_subtype,
    #[doc = " TCP"]
    pub tcp: spdk_nvme_tcp_transport_specific_address_subtype,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_transport_specific_address_subtype() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_transport_specific_address_subtype>(),
        256usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_transport_specific_address_subtype)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_transport_specific_address_subtype>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_transport_specific_address_subtype)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_transport_specific_address_subtype>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_transport_specific_address_subtype),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_rdma() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_transport_specific_address_subtype>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rdma) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_transport_specific_address_subtype),
                "::",
                stringify!(rdma)
            )
        );
    }
    test_field_rdma();
    fn test_field_tcp() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_transport_specific_address_subtype>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tcp) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_transport_specific_address_subtype),
                "::",
                stringify!(tcp)
            )
        );
    }
    test_field_tcp();
}
#[doc = " Discovery Log Page entry"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvmf_discovery_log_page_entry {
    #[doc = " Transport type (\\ref spdk_nvmf_trtype)"]
    pub trtype: u8,
    #[doc = " Address family (\\ref spdk_nvmf_adrfam)"]
    pub adrfam: u8,
    #[doc = " Subsystem type (\\ref spdk_nvmf_subtype)"]
    pub subtype: u8,
    pub treq: spdk_nvmf_discovery_log_page_entry__bindgen_ty_1,
    #[doc = " NVM subsystem port ID"]
    pub portid: u16,
    #[doc = " Controller ID"]
    pub cntlid: u16,
    #[doc = " Admin max SQ size"]
    pub asqsz: u16,
    pub reserved0: [u8; 22usize],
    #[doc = " Transport service identifier"]
    pub trsvcid: [u8; 32usize],
    pub reserved1: [u8; 192usize],
    #[doc = " NVM subsystem qualified name"]
    pub subnqn: [u8; 256usize],
    #[doc = " Transport address"]
    pub traddr: [u8; 256usize],
    #[doc = " Transport-specific address subtype"]
    pub tsas: spdk_nvmf_transport_specific_address_subtype,
}
#[doc = " Transport requirements"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_discovery_log_page_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_discovery_log_page_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvmf_discovery_log_page_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_discovery_log_page_entry__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_discovery_log_page_entry__bindgen_ty_1)
        )
    );
}
impl spdk_nvmf_discovery_log_page_entry__bindgen_ty_1 {
    #[inline]
    pub fn secure_channel(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_secure_channel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(secure_channel: u8, reserved: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let secure_channel: u8 = unsafe { ::std::mem::transmute(secure_channel) };
            secure_channel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvmf_discovery_log_page_entry() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_discovery_log_page_entry>(),
        1024usize,
        concat!("Size of: ", stringify!(spdk_nvmf_discovery_log_page_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_discovery_log_page_entry>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_discovery_log_page_entry)
        )
    );
    fn test_field_trtype() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trtype) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(trtype)
            )
        );
    }
    test_field_trtype();
    fn test_field_adrfam() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).adrfam) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(adrfam)
            )
        );
    }
    test_field_adrfam();
    fn test_field_subtype() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(subtype)
            )
        );
    }
    test_field_subtype();
    fn test_field_treq() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).treq) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(treq)
            )
        );
    }
    test_field_treq();
    fn test_field_portid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).portid) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(portid)
            )
        );
    }
    test_field_portid();
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_asqsz() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).asqsz) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(asqsz)
            )
        );
    }
    test_field_asqsz();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_trsvcid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trsvcid) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(trsvcid)
            )
        );
    }
    test_field_trsvcid();
    fn test_field_reserved1() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(reserved1)
            )
        );
    }
    test_field_reserved1();
    fn test_field_subnqn() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).subnqn) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(subnqn)
            )
        );
    }
    test_field_subnqn();
    fn test_field_traddr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).traddr) as usize - ptr as usize
            },
            512usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(traddr)
            )
        );
    }
    test_field_traddr();
    fn test_field_tsas() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tsas) as usize - ptr as usize
            },
            768usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page_entry),
                "::",
                stringify!(tsas)
            )
        );
    }
    test_field_tsas();
}
#[repr(C, packed)]
pub struct spdk_nvmf_discovery_log_page {
    pub genctr: u64,
    pub numrec: u64,
    pub recfmt: u16,
    pub reserved0: [u8; 1006usize],
    pub entries: __IncompleteArrayField<spdk_nvmf_discovery_log_page_entry>,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_discovery_log_page() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_discovery_log_page>(),
        1024usize,
        concat!("Size of: ", stringify!(spdk_nvmf_discovery_log_page))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_discovery_log_page>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_discovery_log_page))
    );
    fn test_field_genctr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).genctr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page),
                "::",
                stringify!(genctr)
            )
        );
    }
    test_field_genctr();
    fn test_field_numrec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).numrec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page),
                "::",
                stringify!(numrec)
            )
        );
    }
    test_field_numrec();
    fn test_field_recfmt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recfmt) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page),
                "::",
                stringify!(recfmt)
            )
        );
    }
    test_field_recfmt();
    fn test_field_reserved0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page),
                "::",
                stringify!(reserved0)
            )
        );
    }
    test_field_reserved0();
    fn test_field_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_discovery_log_page>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize
            },
            1024usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_discovery_log_page),
                "::",
                stringify!(entries)
            )
        );
    }
    test_field_entries();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_rdma_request_private_data {
    pub recfmt: u16,
    pub qid: u16,
    pub hrqsize: u16,
    pub hsqsize: u16,
    pub cntlid: u16,
    pub reserved: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_spdk_nvmf_rdma_request_private_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_rdma_request_private_data>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvmf_rdma_request_private_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_rdma_request_private_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_rdma_request_private_data)
        )
    );
    fn test_field_recfmt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recfmt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(recfmt)
            )
        );
    }
    test_field_recfmt();
    fn test_field_qid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).qid) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(qid)
            )
        );
    }
    test_field_qid();
    fn test_field_hrqsize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hrqsize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(hrqsize)
            )
        );
    }
    test_field_hrqsize();
    fn test_field_hsqsize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hsqsize) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(hsqsize)
            )
        );
    }
    test_field_hsqsize();
    fn test_field_cntlid() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cntlid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(cntlid)
            )
        );
    }
    test_field_cntlid();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_request_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_request_private_data),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_rdma_accept_private_data {
    pub recfmt: u16,
    pub crqsize: u16,
    pub reserved: [u8; 28usize],
}
#[test]
fn bindgen_test_layout_spdk_nvmf_rdma_accept_private_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_rdma_accept_private_data>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvmf_rdma_accept_private_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_rdma_accept_private_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_rdma_accept_private_data)
        )
    );
    fn test_field_recfmt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_accept_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recfmt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_accept_private_data),
                "::",
                stringify!(recfmt)
            )
        );
    }
    test_field_recfmt();
    fn test_field_crqsize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_accept_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crqsize) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_accept_private_data),
                "::",
                stringify!(crqsize)
            )
        );
    }
    test_field_crqsize();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_accept_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_accept_private_data),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_rdma_reject_private_data {
    pub recfmt: u16,
    pub sts: u16,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_rdma_reject_private_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_rdma_reject_private_data>(),
        4usize,
        concat!("Size of: ", stringify!(spdk_nvmf_rdma_reject_private_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_rdma_reject_private_data>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvmf_rdma_reject_private_data)
        )
    );
    fn test_field_recfmt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_reject_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recfmt) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_reject_private_data),
                "::",
                stringify!(recfmt)
            )
        );
    }
    test_field_recfmt();
    fn test_field_sts() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvmf_rdma_reject_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sts) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_reject_private_data),
                "::",
                stringify!(sts)
            )
        );
    }
    test_field_sts();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvmf_rdma_private_data {
    pub pd_request: spdk_nvmf_rdma_request_private_data,
    pub pd_accept: spdk_nvmf_rdma_accept_private_data,
    pub pd_reject: spdk_nvmf_rdma_reject_private_data,
}
#[test]
fn bindgen_test_layout_spdk_nvmf_rdma_private_data() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvmf_rdma_private_data>(),
        32usize,
        concat!("Size of: ", stringify!(spdk_nvmf_rdma_private_data))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvmf_rdma_private_data>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvmf_rdma_private_data))
    );
    fn test_field_pd_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_rdma_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pd_request) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_private_data),
                "::",
                stringify!(pd_request)
            )
        );
    }
    test_field_pd_request();
    fn test_field_pd_accept() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_rdma_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pd_accept) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_private_data),
                "::",
                stringify!(pd_accept)
            )
        );
    }
    test_field_pd_accept();
    fn test_field_pd_reject() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvmf_rdma_private_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pd_reject) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvmf_rdma_private_data),
                "::",
                stringify!(pd_reject)
            )
        );
    }
    test_field_pd_reject();
}
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_PRIVATE_DATA_LENGTH:
    spdk_nvmf_rdma_transport_error = 1;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_RECFMT:
    spdk_nvmf_rdma_transport_error = 2;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_QID:
    spdk_nvmf_rdma_transport_error = 3;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HSQSIZE:
    spdk_nvmf_rdma_transport_error = 4;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_HRQSIZE:
    spdk_nvmf_rdma_transport_error = 5;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_NO_RESOURCES:
    spdk_nvmf_rdma_transport_error = 6;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_IRD:
    spdk_nvmf_rdma_transport_error = 7;
pub const spdk_nvmf_rdma_transport_error_SPDK_NVMF_RDMA_ERROR_INVALID_ORD:
    spdk_nvmf_rdma_transport_error = 8;
pub type spdk_nvmf_rdma_transport_error = ::std::os::raw::c_uint;
#[doc = " Initialize Connection Request (ICReq)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_IC_REQ: spdk_nvme_tcp_pdu_type = 0;
#[doc = " Initialize Connection Response (ICResp)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_IC_RESP: spdk_nvme_tcp_pdu_type = 1;
#[doc = " Terminate Connection Request (TermReq)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_H2C_TERM_REQ: spdk_nvme_tcp_pdu_type = 2;
#[doc = " Terminate Connection Response (TermResp)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_C2H_TERM_REQ: spdk_nvme_tcp_pdu_type = 3;
#[doc = " Command Capsule (CapsuleCmd)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_CAPSULE_CMD: spdk_nvme_tcp_pdu_type = 4;
#[doc = " Response Capsule (CapsuleRsp)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_CAPSULE_RESP: spdk_nvme_tcp_pdu_type = 5;
#[doc = " Host To Controller Data (H2CData)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_H2C_DATA: spdk_nvme_tcp_pdu_type = 6;
#[doc = " Controller To Host Data (C2HData)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_C2H_DATA: spdk_nvme_tcp_pdu_type = 7;
#[doc = " Ready to Transfer (R2T)"]
pub const spdk_nvme_tcp_pdu_type_SPDK_NVME_TCP_PDU_TYPE_R2T: spdk_nvme_tcp_pdu_type = 9;
#[doc = " NVMe/TCP PDU type"]
pub type spdk_nvme_tcp_pdu_type = ::std::os::raw::c_uint;
#[doc = " Common NVMe/TCP PDU header"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_common_pdu_hdr {
    #[doc = " PDU type (\\ref spdk_nvme_tcp_pdu_type)"]
    pub pdu_type: u8,
    #[doc = " pdu_type-specific flags"]
    pub flags: u8,
    #[doc = " Length of PDU header (not including the Header Digest)"]
    pub hlen: u8,
    #[doc = " PDU Data Offset from the start of the PDU"]
    pub pdo: u8,
    #[doc = " Total number of bytes in PDU, including pdu_hdr"]
    pub plen: u32,
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_common_pdu_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_common_pdu_hdr>(),
        8usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_common_pdu_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_common_pdu_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_common_pdu_hdr))
    );
    fn test_field_pdu_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_common_pdu_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pdu_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_common_pdu_hdr),
                "::",
                stringify!(pdu_type)
            )
        );
    }
    test_field_pdu_type();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_common_pdu_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_common_pdu_hdr),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_hlen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_common_pdu_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hlen) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_common_pdu_hdr),
                "::",
                stringify!(hlen)
            )
        );
    }
    test_field_hlen();
    fn test_field_pdo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_common_pdu_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pdo) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_common_pdu_hdr),
                "::",
                stringify!(pdo)
            )
        );
    }
    test_field_pdo();
    fn test_field_plen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_common_pdu_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).plen) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_common_pdu_hdr),
                "::",
                stringify!(plen)
            )
        );
    }
    test_field_plen();
}
#[doc = " ICReq"]
#[doc = ""]
#[doc = " common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_IC_REQ"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_tcp_ic_req {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub pfv: u16,
    #[doc = " Specifies the data alignment for all PDUs transferred from the controller to the host that contain data"]
    pub hpda: u8,
    pub dgst: spdk_nvme_tcp_ic_req__bindgen_ty_1,
    pub maxr2t: u32,
    pub reserved16: [u8; 112usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_tcp_ic_req__bindgen_ty_1 {
    pub raw: u8,
    pub bits: spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_tcp_ic_req__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn hdgst_enable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hdgst_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ddgst_enable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ddgst_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hdgst_enable: u8,
        ddgst_enable: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hdgst_enable: u8 = unsafe { ::std::mem::transmute(hdgst_enable) };
            hdgst_enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ddgst_enable: u8 = unsafe { ::std::mem::transmute(ddgst_enable) };
            ddgst_enable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_req__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_req__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_req__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_req() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_req>(),
        128usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_ic_req))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_req>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_ic_req))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_pfv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfv) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(pfv)
            )
        );
    }
    test_field_pfv();
    fn test_field_hpda() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hpda) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(hpda)
            )
        );
    }
    test_field_hpda();
    fn test_field_dgst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dgst) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(dgst)
            )
        );
    }
    test_field_dgst();
    fn test_field_maxr2t() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxr2t) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(maxr2t)
            )
        );
    }
    test_field_maxr2t();
    fn test_field_reserved16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_req>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved16) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_req),
                "::",
                stringify!(reserved16)
            )
        );
    }
    test_field_reserved16();
}
#[doc = " ICResp"]
#[doc = ""]
#[doc = " common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_IC_RESP"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct spdk_nvme_tcp_ic_resp {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub pfv: u16,
    #[doc = " Specifies the data alignment for all PDUs transferred from the host to the controller that contain data"]
    pub cpda: u8,
    pub dgst: spdk_nvme_tcp_ic_resp__bindgen_ty_1,
    #[doc = " Specifies the maximum number of PDU-Data bytes per H2C Data Transfer PDU"]
    pub maxh2cdata: u32,
    pub reserved16: [u8; 112usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_nvme_tcp_ic_resp__bindgen_ty_1 {
    pub raw: u8,
    pub bits: spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl spdk_nvme_tcp_ic_resp__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn hdgst_enable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hdgst_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ddgst_enable(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ddgst_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hdgst_enable: u8,
        ddgst_enable: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hdgst_enable: u8 = unsafe { ::std::mem::transmute(hdgst_enable) };
            hdgst_enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ddgst_enable: u8 = unsafe { ::std::mem::transmute(ddgst_enable) };
            ddgst_enable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let reserved: u8 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_resp__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_resp__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_resp__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1)
        )
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
    fn test_field_bits() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp__bindgen_ty_1),
                "::",
                stringify!(bits)
            )
        );
    }
    test_field_bits();
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_ic_resp() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_ic_resp>(),
        128usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_ic_resp))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_ic_resp>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_ic_resp))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_pfv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pfv) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(pfv)
            )
        );
    }
    test_field_pfv();
    fn test_field_cpda() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cpda) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(cpda)
            )
        );
    }
    test_field_cpda();
    fn test_field_dgst() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dgst) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(dgst)
            )
        );
    }
    test_field_dgst();
    fn test_field_maxh2cdata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).maxh2cdata) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(maxh2cdata)
            )
        );
    }
    test_field_maxh2cdata();
    fn test_field_reserved16() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_ic_resp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved16) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_ic_resp),
                "::",
                stringify!(reserved16)
            )
        );
    }
    test_field_reserved16();
}
#[doc = " TermReq"]
#[doc = ""]
#[doc = " common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_TERM_REQ"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_term_req_hdr {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub fes: u16,
    pub fei: [u8; 4usize],
    pub reserved14: [u8; 10usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_term_req_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_term_req_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_term_req_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_term_req_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_term_req_hdr))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_term_req_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_term_req_hdr),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_fes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_term_req_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fes) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_term_req_hdr),
                "::",
                stringify!(fes)
            )
        );
    }
    test_field_fes();
    fn test_field_fei() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_term_req_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fei) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_term_req_hdr),
                "::",
                stringify!(fei)
            )
        );
    }
    test_field_fei();
    fn test_field_reserved14() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_term_req_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved14) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_term_req_hdr),
                "::",
                stringify!(reserved14)
            )
        );
    }
    test_field_reserved14();
}
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_INVALID_HEADER_FIELD:
    spdk_nvme_tcp_term_req_fes = 1;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_PDU_SEQUENCE_ERROR:
    spdk_nvme_tcp_term_req_fes = 2;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_HDGST_ERROR:
    spdk_nvme_tcp_term_req_fes = 3;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_DATA_TRANSFER_OUT_OF_RANGE:
    spdk_nvme_tcp_term_req_fes = 4;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_DATA_TRANSFER_LIMIT_EXCEEDED:
    spdk_nvme_tcp_term_req_fes = 5;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_R2T_LIMIT_EXCEEDED:
    spdk_nvme_tcp_term_req_fes = 5;
pub const spdk_nvme_tcp_term_req_fes_SPDK_NVME_TCP_TERM_REQ_FES_INVALID_DATA_UNSUPPORTED_PARAMETER : spdk_nvme_tcp_term_req_fes = 6 ;
pub type spdk_nvme_tcp_term_req_fes = ::std::os::raw::c_uint;
#[doc = " H2CData"]
#[doc = ""]
#[doc = " hdr.pdu_type == SPDK_NVME_TCP_PDU_TYPE_H2C_DATA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_h2c_data_hdr {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub cccid: u16,
    pub ttag: u16,
    pub datao: u32,
    pub datal: u32,
    pub reserved20: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_h2c_data_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_h2c_data_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_h2c_data_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_h2c_data_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_h2c_data_hdr))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_cccid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cccid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(cccid)
            )
        );
    }
    test_field_cccid();
    fn test_field_ttag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ttag) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(ttag)
            )
        );
    }
    test_field_ttag();
    fn test_field_datao() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datao) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(datao)
            )
        );
    }
    test_field_datao();
    fn test_field_datal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datal) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(datal)
            )
        );
    }
    test_field_datal();
    fn test_field_reserved20() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_h2c_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved20) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_h2c_data_hdr),
                "::",
                stringify!(reserved20)
            )
        );
    }
    test_field_reserved20();
}
#[doc = " C2HData"]
#[doc = ""]
#[doc = " hdr.pdu_type == SPDK_NVME_TCP_PDU_TYPE_C2H_DATA"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_c2h_data_hdr {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub cccid: u16,
    pub reserved10: [u8; 2usize],
    pub datao: u32,
    pub datal: u32,
    pub reserved20: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_c2h_data_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_c2h_data_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_c2h_data_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_c2h_data_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_c2h_data_hdr))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_cccid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cccid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(cccid)
            )
        );
    }
    test_field_cccid();
    fn test_field_reserved10() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved10) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(reserved10)
            )
        );
    }
    test_field_reserved10();
    fn test_field_datao() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datao) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(datao)
            )
        );
    }
    test_field_datao();
    fn test_field_datal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).datal) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(datal)
            )
        );
    }
    test_field_datal();
    fn test_field_reserved20() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_c2h_data_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved20) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_c2h_data_hdr),
                "::",
                stringify!(reserved20)
            )
        );
    }
    test_field_reserved20();
}
#[doc = " R2T"]
#[doc = ""]
#[doc = " common.pdu_type == SPDK_NVME_TCP_PDU_TYPE_R2T"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvme_tcp_r2t_hdr {
    pub common: spdk_nvme_tcp_common_pdu_hdr,
    pub cccid: u16,
    pub ttag: u16,
    pub r2to: u32,
    pub r2tl: u32,
    pub reserved20: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_spdk_nvme_tcp_r2t_hdr() {
    assert_eq!(
        ::std::mem::size_of::<spdk_nvme_tcp_r2t_hdr>(),
        24usize,
        concat!("Size of: ", stringify!(spdk_nvme_tcp_r2t_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_nvme_tcp_r2t_hdr>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_nvme_tcp_r2t_hdr))
    );
    fn test_field_common() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).common) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(common)
            )
        );
    }
    test_field_common();
    fn test_field_cccid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cccid) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(cccid)
            )
        );
    }
    test_field_cccid();
    fn test_field_ttag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ttag) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(ttag)
            )
        );
    }
    test_field_ttag();
    fn test_field_r2to() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r2to) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(r2to)
            )
        );
    }
    test_field_r2to();
    fn test_field_r2tl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).r2tl) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(r2tl)
            )
        );
    }
    test_field_r2tl();
    fn test_field_reserved20() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_nvme_tcp_r2t_hdr>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved20) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_nvme_tcp_r2t_hdr),
                "::",
                stringify!(reserved20)
            )
        );
    }
    test_field_reserved20();
}
pub type pos_bdev_delete_callback = ::std::option::Option<
    unsafe extern "C" fn(cb_arg: *mut ::std::os::raw::c_void, bdeverrno: ::std::os::raw::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_bdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn spdk_bdev_create_pos_disk(
        volume_name: *const ::std::os::raw::c_char,
        volume_id: u32,
        bdev_uuid: *const [u8; 0usize],
        num_blocks: u64,
        block_size: u32,
        volume_type_in_memory: bool,
        array_name: *const ::std::os::raw::c_char,
        array_id: u32,
    ) -> *mut spdk_bdev;
}
extern "C" {
    pub fn spdk_bdev_delete_pos_disk(
        bdev: *mut spdk_bdev,
        cb_fn: pos_bdev_delete_callback,
        cb_arg: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Get the NQN ID of the specified subsystem."]
    #[doc = ""]
    #[doc = " \\param subsystem Subsystem to query."]
    #[doc = ""]
    #[doc = " \\return NQN ID of the specified subsystem."]
    pub fn spdk_nvmf_subsystem_get_id(subsystem: *mut [u8; 0usize]) -> u32;
}
extern "C" {
    #[doc = " This fn is used by POS QOS for initializing"]
    #[doc = " the subsystem reactor Mapping"]
    #[doc = ""]
    pub fn spdk_nvmf_initialize_reactor_subsystem_mapping();
}
extern "C" {
    #[doc = " This fn is used by POS QOS for getting"]
    #[doc = " the subsystem reactor Mapping"]
    #[doc = ""]
    pub fn spdk_nvmf_get_reactor_subsystem_mapping(reactorId: u32, subsystemId: u32) -> u32;
}
extern "C" {
    pub fn spdk_nvmf_update_reactor_subsystem_mapping(qpair: *mut [u8; 0usize]);
}
extern "C" {
    pub fn spdk_nvmf_configure_pos_qos(value: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_ctrlr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn spdk_nvmf_subsystem_get_first_ctrlr(
        subsystem: *mut [u8; 0usize],
    ) -> *mut spdk_nvmf_ctrlr;
}
extern "C" {
    pub fn spdk_nvmf_subsystem_get_next_ctrlr(
        subsystem: *mut [u8; 0usize],
        prev_ctrlr: *mut spdk_nvmf_ctrlr,
    ) -> *mut spdk_nvmf_ctrlr;
}
extern "C" {
    pub fn spdk_nvmf_subsystem_get_ctrlr_hostnqn(
        ctrlr: *mut spdk_nvmf_ctrlr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn spdk_nvmf_subsystem_set_pause_state_directly(
        subsystem: *mut [u8; 0usize],
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spdk_nvmf_initialize_numa_aware_poll_group();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_nvmf_poll_group {
    _unused: [u8; 0],
}
extern "C" {
    pub fn spdk_nvmf_get_numa_aware_poll_group(
        tgt: *mut [u8; 0usize],
        numa: ::std::os::raw::c_int,
    ) -> *mut spdk_nvmf_poll_group;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spdk_uuid {
    pub u: spdk_uuid__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spdk_uuid__bindgen_ty_1 {
    pub raw: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_spdk_uuid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<spdk_uuid__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_uuid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_uuid__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_uuid__bindgen_ty_1))
    );
    fn test_field_raw() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_uuid__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_uuid__bindgen_ty_1),
                "::",
                stringify!(raw)
            )
        );
    }
    test_field_raw();
}
#[test]
fn bindgen_test_layout_spdk_uuid() {
    assert_eq!(
        ::std::mem::size_of::<spdk_uuid>(),
        16usize,
        concat!("Size of: ", stringify!(spdk_uuid))
    );
    assert_eq!(
        ::std::mem::align_of::<spdk_uuid>(),
        1usize,
        concat!("Alignment of ", stringify!(spdk_uuid))
    );
    fn test_field_u() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<spdk_uuid>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(spdk_uuid),
                "::",
                stringify!(u)
            )
        );
    }
    test_field_u();
}
extern "C" {
    #[doc = " Convert UUID in textual format into a spdk_uuid."]
    #[doc = ""]
    #[doc = " \\param[out] uuid User-provided UUID buffer."]
    #[doc = " \\param uuid_str UUID in textual format in C string."]
    #[doc = ""]
    #[doc = " \\return 0 on success, or negative errno on failure."]
    pub fn spdk_uuid_parse(
        uuid: *mut spdk_uuid,
        uuid_str: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert UUID in spdk_uuid into lowercase textual format."]
    #[doc = ""]
    #[doc = " \\param uuid_str User-provided string buffer to write the textual format into."]
    #[doc = " \\param uuid_str_size Size of uuid_str buffer. Must be at least SPDK_UUID_STRING_LEN."]
    #[doc = " \\param uuid UUID to convert to textual format."]
    #[doc = ""]
    #[doc = " \\return 0 on success, or negative errno on failure."]
    pub fn spdk_uuid_fmt_lower(
        uuid_str: *mut ::std::os::raw::c_char,
        uuid_str_size: size_t,
        uuid: *const spdk_uuid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compare two UUIDs."]
    #[doc = ""]
    #[doc = " \\param u1 UUID 1."]
    #[doc = " \\param u2 UUID 2."]
    #[doc = ""]
    #[doc = " \\return 0 if u1 == u2, less than 0 if u1 < u2, greater than 0 if u1 > u2."]
    pub fn spdk_uuid_compare(u1: *const spdk_uuid, u2: *const spdk_uuid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a new UUID."]
    #[doc = ""]
    #[doc = " \\param[out] uuid User-provided UUID buffer to fill."]
    pub fn spdk_uuid_generate(uuid: *mut spdk_uuid);
}
extern "C" {
    #[doc = " Copy a UUID."]
    #[doc = ""]
    #[doc = " \\param src Source UUID to copy from."]
    #[doc = " \\param dst Destination UUID to store."]
    pub fn spdk_uuid_copy(dst: *mut spdk_uuid, src: *const spdk_uuid);
}
pub const IO_TYPE_READ: IO_TYPE = 0;
pub const IO_TYPE_WRITE: IO_TYPE = 1;
pub const IO_TYPE_FLUSH: IO_TYPE = 2;
pub const IO_TYPE_ADMIN: IO_TYPE = 100;
pub const IO_TYPE_GET_LOG_PAGE: IO_TYPE = 101;
pub type IO_TYPE = ::std::os::raw::c_uint;
pub type unvmf_submit_handler =
    ::std::option::Option<unsafe extern "C" fn(io: *mut pos_io) -> ::std::os::raw::c_int>;
pub type unvmf_complete_handler = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unvmf_io_handler {
    pub submit: unvmf_submit_handler,
    pub complete: unvmf_complete_handler,
}
#[test]
fn bindgen_test_layout_unvmf_io_handler() {
    assert_eq!(
        ::std::mem::size_of::<unvmf_io_handler>(),
        16usize,
        concat!("Size of: ", stringify!(unvmf_io_handler))
    );
    assert_eq!(
        ::std::mem::align_of::<unvmf_io_handler>(),
        8usize,
        concat!("Alignment of ", stringify!(unvmf_io_handler))
    );
    fn test_field_submit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<unvmf_io_handler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).submit) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(unvmf_io_handler),
                "::",
                stringify!(submit)
            )
        );
    }
    test_field_submit();
    fn test_field_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<unvmf_io_handler>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).complete) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(unvmf_io_handler),
                "::",
                stringify!(complete)
            )
        );
    }
    test_field_complete();
}
extern "C" {
    pub fn get_attached_subsystem_id(bdev_name: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn spdk_bdev_pos_register_io_handler(
        bdev_name: *const ::std::os::raw::c_char,
        handler: unvmf_io_handler,
    );
}
extern "C" {
    pub fn get_nvmf_thread_from_reactor(reactor: ::std::os::raw::c_int) -> *mut spdk_thread;
}
extern "C" {
    pub fn spdk_bdev_pos_unregister_io_handler(bdev_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn set_pos_volume_info(
        bdev_name: *const ::std::os::raw::c_char,
        nqn: *const ::std::os::raw::c_char,
        nqn_id: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn reset_pos_volume_info(bdev_name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn send_msg_to_all_nvmf_thread(
        current_core: u32,
        fn_: *mut ::std::os::raw::c_void,
        arg1: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn get_attached_subsystem_nqn(
        bdev_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_bdev_io {
    _unused: [u8; 0],
}
pub type pos_bdev_io_handler = ::std::option::Option<
    unsafe extern "C" fn(
        ch: *mut spdk_io_channel,
        bdev_io: *mut spdk_bdev_io,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pos_volume_info {
    pub id: u32,
    pub array_id: u32,
    pub name: [::std::os::raw::c_char; 256usize],
    pub nqn: [::std::os::raw::c_char; 224usize],
    pub array_name: [::std::os::raw::c_char; 64usize],
    pub uuid: [::std::os::raw::c_char; 37usize],
    pub nqn_id: u32,
    pub size_mb: u64,
    pub iops_limit: u64,
    pub bw_limit: u64,
    pub pos_bdev_io: pos_bdev_io_handler,
    pub pos_bdev_flush: pos_bdev_io_handler,
    pub pos_bdev_admin: pos_bdev_io_handler,
    pub unvmf_io: unvmf_io_handler,
}
#[test]
fn bindgen_test_layout_pos_volume_info() {
    assert_eq!(
        ::std::mem::size_of::<pos_volume_info>(),
        664usize,
        concat!("Size of: ", stringify!(pos_volume_info))
    );
    assert_eq!(
        ::std::mem::align_of::<pos_volume_info>(),
        8usize,
        concat!("Alignment of ", stringify!(pos_volume_info))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_array_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(array_id)
            )
        );
    }
    test_field_array_id();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_nqn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nqn) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(nqn)
            )
        );
    }
    test_field_nqn();
    fn test_field_array_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_name) as usize - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(array_name)
            )
        );
    }
    test_field_array_name();
    fn test_field_uuid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uuid) as usize - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(uuid)
            )
        );
    }
    test_field_uuid();
    fn test_field_nqn_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nqn_id) as usize - ptr as usize
            },
            592usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(nqn_id)
            )
        );
    }
    test_field_nqn_id();
    fn test_field_size_mb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_mb) as usize - ptr as usize
            },
            600usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(size_mb)
            )
        );
    }
    test_field_size_mb();
    fn test_field_iops_limit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iops_limit) as usize - ptr as usize
            },
            608usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(iops_limit)
            )
        );
    }
    test_field_iops_limit();
    fn test_field_bw_limit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bw_limit) as usize - ptr as usize
            },
            616usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(bw_limit)
            )
        );
    }
    test_field_bw_limit();
    fn test_field_pos_bdev_io() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_bdev_io) as usize - ptr as usize
            },
            624usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(pos_bdev_io)
            )
        );
    }
    test_field_pos_bdev_io();
    fn test_field_pos_bdev_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_bdev_flush) as usize - ptr as usize
            },
            632usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(pos_bdev_flush)
            )
        );
    }
    test_field_pos_bdev_flush();
    fn test_field_pos_bdev_admin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_bdev_admin) as usize - ptr as usize
            },
            640usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(pos_bdev_admin)
            )
        );
    }
    test_field_pos_bdev_admin();
    fn test_field_unvmf_io() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_volume_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unvmf_io) as usize - ptr as usize
            },
            648usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_volume_info),
                "::",
                stringify!(unvmf_io)
            )
        );
    }
    test_field_unvmf_io();
}
pub type pos_bdev_io_complete_callback =
    ::std::option::Option<unsafe extern "C" fn(io: *mut pos_io, status: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pos_io {
    pub ioType: ::std::os::raw::c_int,
    pub volume_id: u32,
    pub array_id: u32,
    pub iov: *mut iovec,
    pub iovcnt: ::std::os::raw::c_int,
    pub length: u64,
    pub offset: u64,
    pub context: *mut ::std::os::raw::c_void,
    pub arrayName: *mut ::std::os::raw::c_char,
    pub complete_cb: pos_bdev_io_complete_callback,
}
#[test]
fn bindgen_test_layout_pos_io() {
    assert_eq!(
        ::std::mem::size_of::<pos_io>(),
        72usize,
        concat!("Size of: ", stringify!(pos_io))
    );
    assert_eq!(
        ::std::mem::align_of::<pos_io>(),
        8usize,
        concat!("Alignment of ", stringify!(pos_io))
    );
    fn test_field_ioType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ioType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(ioType)
            )
        );
    }
    test_field_ioType();
    fn test_field_volume_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).volume_id) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(volume_id)
            )
        );
    }
    test_field_volume_id();
    fn test_field_array_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).array_id) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(array_id)
            )
        );
    }
    test_field_array_id();
    fn test_field_iov() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iov) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(iov)
            )
        );
    }
    test_field_iov();
    fn test_field_iovcnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iovcnt) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(iovcnt)
            )
        );
    }
    test_field_iovcnt();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(offset)
            )
        );
    }
    test_field_offset();
    fn test_field_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(context)
            )
        );
    }
    test_field_context();
    fn test_field_arrayName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arrayName) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(arrayName)
            )
        );
    }
    test_field_arrayName();
    fn test_field_complete_cb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pos_io>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).complete_cb) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(pos_io),
                "::",
                stringify!(complete_cb)
            )
        );
    }
    test_field_complete_cb();
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigacts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct re_guts {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_device {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spdk_pci_driver {
    pub _address: u8,
}
